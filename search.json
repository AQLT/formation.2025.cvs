[
  {
    "objectID": "manuel_installation.html",
    "href": "manuel_installation.html",
    "title": "Installer (R)JDemetra+ et le JWSACruncher",
    "section": "",
    "text": "Pour utiliser JDemetra+ il faut deux logiciels : JDemetra+ et Java. Nous recommandons d’utiliser les versions 3.x.y de JDemetra+, les versions 2.x.y n’étant plus maintenues à partir de la décembre 2026."
  },
  {
    "objectID": "manuel_installation.html#versions-3.x.y",
    "href": "manuel_installation.html#versions-3.x.y",
    "title": "Installer (R)JDemetra+ et le JWSACruncher",
    "section": "Versions 3.x.y",
    "text": "Versions 3.x.y\nLes version 3.0.0 et plus de JDemetra+ et du JWSACruncher sont disponibles ici : https://github.com/jdemetra/jdplus-main/releases. Chaque version possède un installateur comprenant directement une version portable de Java (versions “standalone”) : c’est l’approche que nous recommandons pour éviter de télécharger Java de manière indépendante et de faire la configuration. Dans le cadre de la version 3.5.1, la fichier à télécharger sous Windows est jdemetra-standalone-3.5.1-windows-x86_64.zip. Pour le trouver, une fois sur la page GitHub, il faut cliquer sur le lien Show all assets :\n Vous pouvez désormais chercher et trouver la version que vous souhaitez installer :\n Après avoir télécharger le fichier, dézipper le dans un endroit stable (i.e. un chemin qui ne changera pas)."
  },
  {
    "objectID": "manuel_installation.html#versions-2.x.y",
    "href": "manuel_installation.html#versions-2.x.y",
    "title": "Installer (R)JDemetra+ et le JWSACruncher",
    "section": "Versions 2.x.y",
    "text": "Versions 2.x.y\nLes version 2.x.y de JDemetra+ sont téléchargeables depuis le lien github de l’application : https://github.com/jdemetra/jdemetra-app/releases. Deux solutions pour l’installer : télécharger le fichier .exe qui nécessite des droits d’administrateur ou télécharger le .zip qui permet d’avoir une version portable du logiciel.\nAttention : pour la seconde option ne pas télécharger le fichier Source code (zip) mais le fichier jdemetra+-2.2.2-bin.zip (pour la version 2.2.2) :\n\nUne fois le fichier téléchargé, il suffit de le dézipper : le logiciel se trouve alors dans le dossier \\nbdemetra\\bin\\, ce sont les fichiers nbdemetra.exe (version 32-bit) et nbdemetra64.exe (version 64-bit)."
  },
  {
    "objectID": "manuel_installation.html#jPort",
    "href": "manuel_installation.html#jPort",
    "title": "Installer (R)JDemetra+ et le JWSACruncher",
    "section": "Utilisation d’une version portable de Java",
    "text": "Utilisation d’une version portable de Java\nPour utiliser la version 2.2.4 de JDemetra+ (et les packages R associés) il faut avoir la version 8 de Java (ou une version supérieure). Pour la version 3.0 de JDemetra+ (et les packages R associés) il faut avoir la version 17 de Java (ou une version supérieure) : nous utiliserons donc la version 17 de Java pour s’assurer une compatibilité avec tous les logiciels Si l’on a pas cette version d’installée et que l’on n’a pas les droits d’administrateur pour installer Java il faut alors installer une version portable de Java et lancer JDemetra+ avec cette version de java.\nPour installer une version portable de java, vous pouvez aller ici :\n\nZulu JDK\nAdoptOpenJDK\nAmazon Corretto\nOracle\n\nPour lancer JDemetra+ avec cette nouvelle version de Java il faut :\n\ncréer un raccourci vers l’application\n\nfaire un clique-droit sur le raccourci et ensuite cliquer sur « Propriétés ». Il reste alors à modifier la variable « Cible » en ajoutant le paramètre suivant : --jdkhome \"[chemin du dossier Java17]\".\n\nPar exemple, si JDemetra+ et Java sont installés sous D:\\Programmes\\, la variable Cible contiendra l’adresse D:\\Programmes\\nbdemetra\\bin\\nbdemetra64.exe --jdkhome \"D:\\Programmes\\Java17\".\nAttention : le chemin du raccourci est absolu, il doit donc être modifié à chaque fois qu’un des répertoires racines de JDemetra+ ou Java est déplacé."
  },
  {
    "objectID": "manuel_installation.html#versions-3.x.y-1",
    "href": "manuel_installation.html#versions-3.x.y-1",
    "title": "Installer (R)JDemetra+ et le JWSACruncher",
    "section": "Versions 3.x.y",
    "text": "Versions 3.x.y\nLes version 3.0.0 et plus de JDemetra+ et du JWSACruncher sont disponibles ici : https://github.com/jdemetra/jdplus-main/releases. Chaque version possède un installateur comprenant directement une version portable de Java (versions “standalone”) : c’est l’approche que nous recommandons pour éviter de télécharger Java de manière indépendante et de faire la configuration. Dans le cadre de la version 3.5.1, la fichier du JWSACruncher à télécharger sous Windows est jwsacruncher-standalone-3.5.1-osx-x86_64.zip. Pour le trouver, une fois sur la page GitHub, il faut cliquer sur le lien Show all assets :\n Vous pouvez désormais chercher et trouver la version que vous souhaitez installer :\n Après avoir télécharger le fichier, dézipper le dans un endroit stable (i.e. un chemin qui ne changera pas)."
  },
  {
    "objectID": "manuel_installation.html#versions-2.x.y-1",
    "href": "manuel_installation.html#versions-2.x.y-1",
    "title": "Installer (R)JDemetra+ et le JWSACruncher",
    "section": "Versions 2.x.y",
    "text": "Versions 2.x.y\nLa version 2.2.4 du cruncher peut être téléchargée ici https://github.com/jdemetra/jwsacruncher/releases (fichier jwsacruncher-x.y.z-bin.zip) Si l’on utilise une version portable de Java (voir section précédente) il faut encore modifier certains paramètres pour utiliser le cruncher :\n\ndézipper le fichier téléchargé ;\n\ndans le dossier dézippé, ouvrir (par exemple avec Notepad++) le fichier jwsacruncher.bat présent dans le sous-dossier \\bin\\ (c’est-à-dire sous jdemetra-cli-2.2.4\\bin\\ dans la version 2.2.4 du cruncher) ;\n\nmodifier la valeur de la variable JAVACMD de la ligne 71 (actuelle JAVACMD=java) par l’adresse vers le fichier java.exe de la version portable . Ainsi, si Java est installé sous D:\\Programmes\\, la nouvelle ligne est if \"%JAVACMD%\"==\"\" set JAVACMD=\"D:\\Programmes\\Java17\\bin\\java\".\n\nLe téléchargement et la configuration du cruncher peut également se faire via rjwsacruncher:\n\nlibrary(rjwsacruncher)\ndownload_cruncher(v3 = FALSE) # Pour télécharger le cruncher\nconfigure_jwsacruncher() # Pour le configurer avec une version portable"
  },
  {
    "objectID": "TP/R_5_JD_in_production_v3.html",
    "href": "TP/R_5_JD_in_production_v3.html",
    "title": "5 - JDemetra+ en production",
    "section": "",
    "text": "L’objectif de ce TP est d’apprendre à manipuler des workspaces pour une mise en production.\nPour installer tous les packages utiles de ce TP, lancer le programme :\npackages_to_install &lt;- c(\n  \"rjwsacruncher\",\n  \"rjd3toolkit\", \"rjd3x13\", \"rjd3tramoseats\", \"rjd3providers\", \"rjd3workspace\", \"ggdemetra3\"\n  )\n\npackages &lt;- packages_to_install[! packages_to_install %in% installed.packages()[,\"Package\"]]\nif (length(packages) &gt; 0) {\n    install.packages(\n      packages, \n      repos = c(\"https://aqlt.r-universe.dev\", \"https://cloud.r-project.org\")\n      )\n}\nLors de la mise en production, le plus simple est de manipuler des workspaces et de mettre à jour les modèles, lors de l’arrivée de nouvelles données à travers le JWSACruncher. Pour faciliter son utilisation depuis R, le package rjwsacruncher peut être utilisé.\nLorsque les workspaces sont créés depuis R, on perd toutes les métadonnées (lien vers les fichiers, commentaires, etc.), une solution pour cela : utiliser rjdworkspace (package non publié sur le CRAN) pour récupérer ces données depuis un autre workspace. Pour la version 3, rjd3workspace contient toutes les fonctionnalités de rjdworkspace.\nDans ce TP on utilisera les données du package rjd3toolkit mais n’hésitez pas à utiliser vos propres séries."
  },
  {
    "objectID": "TP/R_5_JD_in_production_v3.html#sec-installation",
    "href": "TP/R_5_JD_in_production_v3.html#sec-installation",
    "title": "5 - JDemetra+ en production",
    "section": "1.1 Configuration du JWSACruncher",
    "text": "1.1 Configuration du JWSACruncher\nPour éviter que le package rjwsacruncher soit trop volumineux, il ne contient pas le JWSAcruncher de JDemetra+. Voir manuel d’installation pour le téléchargement et la configuration du JWSACruncher.\nPour indiquer à rjwsacruncher où se trouve le JWSACruncher, le plus simple est de mettre à jour l’option cruncher_bin_directory :\n\n# install.packages(\"rjwsacruncher\") # Si pas déjà installé\nlibrary(rjwsacruncher)\n# Chemin vers le dossier bin du JWSACruncher\n# Remplacer \"D:/jwsacruncher-3.5.1/bin\" par votre propre chemin.\noptions(cruncher_bin_directory =\n            \"D:/jwsacruncher-3.5.1/bin\") \ngetOption(\"cruncher_bin_directory\") # Pour afficher la valeur actuelle\n\n[1] \"D:/jwsacruncher-3.5.1/bin\""
  },
  {
    "objectID": "TP/R_5_JD_in_production_v3.html#utilisation-du-jwsacruncher",
    "href": "TP/R_5_JD_in_production_v3.html#utilisation-du-jwsacruncher",
    "title": "5 - JDemetra+ en production",
    "section": "1.2 Utilisation du JWSACruncher",
    "text": "1.2 Utilisation du JWSACruncher\nPour lancer le JWSACruncher il faut trois fichiers :\n\nun fichier contenant les paramètres sur la méthode de rafraîchissement à utilisée pour mettre à jour le workspace (créé à partir de la fonction create_param_file() ou list2param_file()) ;\n\nun workspace valide de JDemetra+ ;\n\nl’adresse vers le JWSACruncher (option cruncher_bin_directory).\n\nDans le package rjwsacruncher, les principales fonctions associées au lancement du JWSACruncher sont :\n\ncreate_param_file() ou list2param_file() qui permet de créer le fichier de paramètres ;\n\ncruncher() qui permet de lancer le JWSACruncher sur un workspace à partir d’un fichier de paramètres ;\n\ncruncher_and_param() qui permet de lancer le JWSACruncher tout en créant le fichier de paramètres et de personnaliser certaines sorties du JWSACruncher.\n\n\n1.2.1 Création du fichier de paramètres avec create_param_file()\nLes paramètres de la fonction create_param_file() sont les mêmes que ceux décrits dans le wiki du JWSACruncher de JDemetra+ (https://github.com/jdemetra/jwsacruncher/wiki). Les trois paramètres les plus importants de create_param_file() sont :\n\npolicy qui est la méthode de rafraîchissement utilisée (voir tableau ci-dessous).\n\n\n\n\n\nLes différentes politiques de rafraîchissement\n\n\nOption sous JDemetra+\nOption du cruncher\nNom court\nSignification\n\n\n\n\nCurrent[AO]: fixed model + AO for new data\ncurrent\nn\nLe modèle ARIMA, les outliers et les autres paramètres du modèle de régression ne sont ni ré-identifiés ni ré-estimés. Le schéma de décomposition est inchangé. Un additive outlier (AO) est ajouté à chaque nouvelle donnée. (depuis v.2.2.3)\n\n\nPartial concurrent adjustment -&gt; Fixed model\nfixed\nf\nLe modèle ARIMA, les outliers et les autres paramètres du modèle de régression ne sont ni ré-identifiés ni ré-estimés. Le schéma de décomposition est inchangé. (depuis v.2.2.3)\n\n\nPartial concurrent adjustment -&gt; Estimate regression coefficients\nfixedparameters\nfp\nLe modèle ARIMA, les outliers et les autres paramètres du modèle regARIMA ne sont pas ré-identifiés. Les coefficients du modèle ARIMA sont fixés et les autres paramètres du modèle de régression sont ré-estimés. Le schéma de décomposition est inchangé.\n\n\nPartial concurrent adjustment -&gt; Estimate regression coefficients + MA parameters of the ARIMA model\nfixedarparameters\nfarp\nLe modèle ARIMA, les outliers et les autres paramètres du modèle regARIMA ne sont pas ré-identifiés. Les coefficients AR du modèle ARIMA sont fixes, les autres coefficients sont réestimés (coefficients MA + régresseurs). Le schéma de décomposition est inchangé. (since v.3.4.0)\n\n\nPartial concurrent adjustment -&gt; Estimate regression coefficients + Arima parameters\nparameters (by default)\np\nLe modèle ARIMA, les outliers et les autres paramètres du modèle de régression ne sont pas ré-identifiés mais sont tous ré-estimés. Le schéma de décomposition est inchangé.\n\n\nPartial concurrent adjustment -&gt; Estimate regression coefficients + Last outliers\nlastoutliers\nl\nLe modèle ARIMA, les outliers (sauf ceux de la dernière année) et les autres paramètres du modèle de régression ne sont pas ré-identifiés mais sont tous ré-estimés. Les outliers de la dernière année sont ré-identifiés. Le schéma de décomposition est inchangé.\n\n\nPartial concurrent adjustment -&gt; Estimate regression coefficients + All outliers\noutliers\no\nLe modèle ARIMA et les paramètres du modèle regARIMA autres que les outliers ne sont pas ré-identifiés mais ré-estimés. Tous les outliers sont ré-identifiés. Le schéma de décomposition est inchangé.\n\n\nPartial concurrent adjustment -&gt; Estimate regression coefficients + Arima model\nstochastic\ns\nRé-identification de tous les paramètres du modèle regARIMA hormis les variables calendaires. Le schéma de décomposition est inchangé.\n\n\nConcurrent\ncomplete (or concurrent)\nc\nRé-identification de tout le modèle regARIMA.\n\n\n\n\n\n\n\n\n\nmatrix_item qui est une chaîne de caractères contenant les noms des paramètres à exporter. Par défaut, ce sont ceux de l’option default_matrix_item. On peut donc au choix modifier l’option default_matrix_item ou le paramètre matrix_item :\n\n\nlibrary(rjwsacruncher)\n# Pour afficher les paramètres par défaut :\ngetOption(\"default_matrix_item\")\n# Pour modifier les paramètres par défaut pour n'exporter par exemple\n# que les critères d'information :\noptions(default_matrix_item = c(\"likelihood.aic\",\n                                \"likelihood.aicc\",\n                                \"likelihood.bic\",\n                                \"likelihood.bicc\"))\n\n\ntsmatrix_series qui est une chaîne de caractères contenant les noms des paramètres à exporter. Par défaut, ce sont ceux de l’option default_tsmatrix_series. On peut donc au choix modifier l’option default_tsmatrix_series ou le paramètre tsmatrix_series :\n\n\n# Pour afficher les paramètres par défaut :\ngetOption(\"default_tsmatrix_series\")\n# Pour modifier les paramètres par défaut pour n'exporter par exemple que\n# la série désaisonnalisée et ses prévisions :\noptions(default_tsmatrix_series = c(\"sa\", \"sa_f\"))\n\nPour voir l’ensemble des paramètres, il suffit d’utiliser sous R la commande ?create_param_file.\nAprès cela, il ne reste plus qu’à créer le fichier de paramètres. Le fichier de paramètre est différent entre la version 3.0.0 de JDemetra+ et les versions antérieures. Les fonctions de création des fichiers de paramètres ont un paramètre v3 qui permet de spécifier si l’on veut que le fichier soit compatible avec la version 3.0.0. Sa valeur par défaut est getOption(\"is_cruncher_v3\") : si l’on utilise la version 3.0.0 ou plus, le plus simple est donc de changer cette option options(is_cruncher_v3 = TRUE). Ci-dessous quelques exemples.\n\nexport_dir &lt;- tempdir() # Remplacer ici par le dossier d'export souhaité\n# Un fichier parametres.param sera créé dans le dossier export_dir\n# avec la politique de rafraîchissement \"lastoutliers\" \n# et les autres paramètres par défaut\ncreate_param_file(dir_file_param = export_dir,\n                  policy = \"lastoutliers\", v3 = TRUE)\n# Si l'on a modifié les options \"default_matrix_item\" et \"default_tsmatrix_series\" pour\n# n'exporter que les critères d'information, la série désaisonnalisée et ses\n# prévisions, la commande précédente est équivalent à : \ncreate_param_file(\n  dir_file_param = export_dir,\n  policy = \"lastoutliers\",\n  matrix_item = c(\"likelihood.aic\", \"likelihood.aicc\",\n                  \"likelihood.bic\", \"likelihood.bicc\"),\n  tsmatrix_series = c(\"sa\", \"sa_f\"), \n  v3 = TRUE\n)\n\nLes fichiers de paramètres peuvent être lus avec read_param_file() qui renvoie une liste qui peut être modifiée et exportée avec list2param_file() :\n\nparam_f &lt;- read_param_file(file.path(export_dir, \"parameters.param\"))\nstr(param_f)\n\nList of 7\n $ config         :List of 8\n  ..$ bundle              : chr \"10000\"\n  ..$ csv_layout          : chr \"list\"\n  ..$ csv_separator       : chr \";\"\n  ..$ ndecs               : chr \"6\"\n  ..$ full_series_name    : logi TRUE\n  ..$ short_column_headers: logi TRUE\n  ..$ rslt_name_level     : chr \"2\"\n  ..$ format              : chr \"JD3\"\n $ policy         : chr \"lastoutliers\"\n $ refreshall     : logi TRUE\n $ output         : NULL\n $ matrix_item    : chr [1:4] \"likelihood.aic\" \"likelihood.aicc\" \"likelihood.bic\" \"likelihood.bicc\"\n $ tsmatrix_series: chr [1:2] \"sa\" \"sa_f\"\n $ paths_path     : NULL\n\n\nLes fichiers de paramètres par défaut peuvent être obtenus avec la fonction default_param_file().\n\n\n\n\n\n\nExercice\n\n\n\nUtiliser la fonction create_param_file() pour créé un fichier de paramètres permettant de mettre à jour un workspace :\n\nEn réestimant le modèle ARIMA, les outliers et les autres paramètres du modèle de régression et en re-identifiant les outliers uniquement sur la dernière année.\nEn exportant la statistique M7, la statistique Q-M2 et les tests de jours ouvrables résiduels ;\nEn exportant la série brute, la série désaisonnalisée et la tendance (de manière verticale).\n\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nPour voir les noms des paramètres, utiliser la fonction default_param_file() ou bien aller sur la page https://github.com/jdemetra/jwsacruncher/wiki/Output-dictionaries.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ndir &lt;- tempdir()\ncreate_param_file(\n    dir_file_param = dir,\n    policy = \"lastoutliers\",\n    matrix_item = c(\n        \"m-statistics.m7\",\n        \"m-statistics.q-m2\",\n        \"diagnostics.residual trading days tests.f-test on sa (td):2\",\n        \"diagnostics.residual trading days tests.f-test on i (td):2\"\n    ),\n    tsmatrix_series = c(\"y\", \"sa\", \"t\"),\n    csv_layout = \"vtable\",\n    v3 = TRUE\n)\n\n\n\n\nLes fichiers de paramètres peuvent être lus avec read_param_file() qui renvoie une liste qui peut être modifiée et exportée avec list2param_file() :\n\nparam_f &lt;- read_param_file(file.path(dir, \"parameters.param\"))\nstr(param_f)\n\nList of 7\n $ config         :List of 8\n  ..$ bundle              : chr \"10000\"\n  ..$ csv_layout          : chr \"vtable\"\n  ..$ csv_separator       : chr \";\"\n  ..$ ndecs               : chr \"6\"\n  ..$ full_series_name    : logi TRUE\n  ..$ short_column_headers: logi TRUE\n  ..$ rslt_name_level     : chr \"2\"\n  ..$ format              : chr \"JD3\"\n $ policy         : chr \"lastoutliers\"\n $ refreshall     : logi TRUE\n $ output         : NULL\n $ matrix_item    : chr [1:4] \"m-statistics.m7\" \"m-statistics.q-m2\" \"diagnostics.residual trading days tests.f-test on sa (td):2\" \"diagnostics.residual trading days tests.f-test on i (td):2\"\n $ tsmatrix_series: chr [1:3] \"y\" \"sa\" \"t\"\n $ paths_path     : NULL\n\n\nLes fichiers de paramètres par défaut peuvent être obtenus avec la fonction default_param_file().\n\n\n1.2.2 Lancement du JWSACruncher\nPour lancer le JWSACruncher avec cruncher() ou cruncher_and_param(), il faut spécifier le chemin d’accès au dossier contenant le JWSACruncher (paramètre cruncher_bin_directory) ainsi que celui du workspace à traiter (paramètre workspace). Si cela a déjà été fait dans la section 1.1, ne pas prendre en compte le paragraphe suivant\nPar défaut, le chemin d’accès au dossier du JWSACruncher est celui contenu dans le paramètre cruncher_bin_directory : il suffit donc de modifier une seule fois cette option afin qu’elle s’applique à toutes les exécutions du JWSACruncher. Le chemin à indiquer est celui du dossier contenant le fichier jwsacruncher.bat, situé dans le dossier “Bin” du dossier d’installation du JWSACruncher. Ainsi, s’il a été installé sous D:\\jdemetra-cli-3.5.1, le fichier jwsacruncher.bat sera présent sous D:\\jdemetra-cli-3.5.1\\bin. Il faut donc modifier l’option cruncher_bin_directory de la façon suivante :\n\noptions(cruncher_bin_directory = \"D:/jdemetra-cli-3.5.1/bin/\")\n\nSi aucun chemin de workspace n’est renseigné, une fenêtre s’ouvre, invitant à sélectionner le workspace sur lequel on souhaite lancer le JWSACruncher.\n\ncruncher(\n  # Remplacer ici \"workspace.xml\" par le chemin vers votre workspace\n  workspace = \"workspace.xml\",\n  # Remplacer ici \"parameters.param\" par le chemin vers votre fichier de paramètres\n  param_file_path = \"parameters.param\"\n)\n\nSi vous n’avez pas de workspace vous pouvez utiliser le code suivant pour en générer un :\n\nspec_x13 &lt;- rjd3x13::x13_spec(\"rsa3\")\ndata &lt;- rjd3toolkit::ABS\njws &lt;- rjd3workspace::jws_new()\njsap &lt;- rjd3workspace::jws_sap_new(jws, \"SAP-1\")\n\nfor (nom_serie in names(data)){\n    rjd3workspace::add_sa_item(jsap, nom_serie, data[[nom_serie]], spec = spec_x13)\n}\n\nrjd3workspace::save_workspace(jws, \"workspace.xml\")\n\nSi non spécifié dans le fichier des paramètres, les résultats sont exportés dans le sous dossier \"Output\" du workspace (pour le workspace.xml, les résultats seront donc sous workspace/Output/). On peut aussi créer le fichier des paramètres et lancer le JWSAcruncher avec la fonction cruncher_and_param. Cette fonction permet aussi de renommer les dossiers exportées avec les noms des multi-processings utilisés dans JDemetra+ (évite d’avoir des dossiers du type SAProcessing-1).\n\ncruncher_and_param(\n    workspace = \"workspace.xml\",\n    policy = \"lastoutliers\",\n    matrix_item = c(\n        \"m-statistics.m7\",\n        \"m-statistics.q-m2\",\n        \"diagnostics.residual trading days tests.f-test on sa (td):2\",\n        \"diagnostics.residual trading days tests.f-test on i (td):2\"\n    ),\n    tsmatrix_series = c(\"y\", \"sa\", \"t\"),\n    csv_layout = \"vtable\"\n)"
  },
  {
    "objectID": "TP/R_5_JD_in_production_v3.html#mise-à-jour-des-données-avec-la-version-3",
    "href": "TP/R_5_JD_in_production_v3.html#mise-à-jour-des-données-avec-la-version-3",
    "title": "5 - JDemetra+ en production",
    "section": "1.3 Mise à jour des données avec la version 3",
    "text": "1.3 Mise à jour des données avec la version 3\nAvec les packages de la version 3 vous pouvez également directement rafraîchir les spécifications depuis R, la chaîne de production peut donc être entièrement codée en R ! Par exemple, pour X-13ARIMA il faut utiliser la fonction rjd3x13::x13_refresh() :\n\ny &lt;- RJDemetra::ipi_c_eu[,\"FR\"]\ny_est &lt;- window(y, end = 2019)\nmod &lt;- rjd3x13::x13(y_est)\nmod$result$preprocessing\n\nLog-transformation: yes \nSARIMA model: (2,1,1) (0,1,1)\n\nSARIMA coefficients:\n   phi(1)    phi(2)  theta(1) btheta(1) \n -0.01262   0.15483  -0.53470  -0.69469 \n\nRegression model:\n             td          easter LS (2008-11-01) LS (2009-01-01) AO (2011-05-01) \n       0.006923       -0.022516       -0.085520       -0.072033        0.129229 \n\nFor a more detailed output, use the 'summary()' function.\n\nspec_x13_ref &lt;- rjd3x13::x13_refresh(\n  # Point spec: la specification de laquelle on part\n    spec = mod$result_spec,\n  # Domain spec: Specification utilisée pour l'estimation \n  # permet de définir les contraintes (CJO, valeurs possibles ARIMA...)\n    refspec = mod$estimation_spec,\n  # Politique de rafraîchissement\n    policy = \"Outliers\",\n  # Période où les outliers sont figés :\n  period = 12,\n  start = start(y_est),\n  end = end(y_est) - c(1, 0)\n)\nmod_ref &lt;- rjd3x13::x13(y, spec_x13_ref)\nmod_ref$result$preprocessing\n\nLog-transformation: yes \nSARIMA model: (2,1,1) (0,1,1)\n\nSARIMA coefficients:\n   phi(1)    phi(2)  theta(1) btheta(1) \n -0.05028   0.12923  -0.56245  -0.70608 \n\nRegression model:\n             td          easter LS (2008-11-01) LS (2009-01-01) AO (2011-05-01) \n       0.007047       -0.022698       -0.085281       -0.071688        0.129041 \nAO (2020-03-01) TC (2020-04-01) \n      -0.204629       -0.423721 \n\nFor a more detailed output, use the 'summary()' function.\n\n# Le modèle est différent de celui obtenu en réestimant\n# avec la spécification par défaut\nrjd3x13::x13(y)$result$preprocessing\n\nLog-transformation: no \nSARIMA model: (2,1,1) (0,1,1)\n\nSARIMA coefficients:\n   phi(1)    phi(2)  theta(1) btheta(1) \n  0.05291   0.18672  -0.52138  -0.66132 \n\nRegression model:\n             td              lp          easter LS (2008-11-01) LS (2009-01-01) \n         0.6927          2.0903         -2.5476         -9.2744         -7.2838 \nAO (2011-05-01) AO (2020-03-01) TC (2020-04-01) \n        13.1870        -21.1492        -35.6481 \n\nFor a more detailed output, use the 'summary()' function."
  },
  {
    "objectID": "TP/R_5_JD_in_production_v3.html#ggdemetra3",
    "href": "TP/R_5_JD_in_production_v3.html#ggdemetra3",
    "title": "5 - JDemetra+ en production",
    "section": "3.1 ggdemetra3",
    "text": "3.1 ggdemetra3\nggdemetra3 permet de faire de la désaisonnalisation comme une couche supplémentaire de ggplot2.\n\ngeom_sa() : pour ajouter une série temporelle associée à la désaisonnalisation (tendance, série désaisonnalisée, etc.) ;\ngeom_outlier() : pour ajouter les points atypiques corrigés dans le pre-ajustement ;\ngeom_arima() : pour ajouter le modèle ARIMA ;\ngeom_diagnostics() : pour ajouter un tableau avec des diagnostics.\n\nPar exemple, pour tracer les séries désaisonnalisées d’un ensemble de séries temporelles :\n\nlibrary(ggdemetra3)\nlibrary(rjd3x13)\ndataGraph &lt;- ts2df(do.call(ts.union, rjd3toolkit::ABS[c(\"X0.2.09.10.M\", \"X0.2.08.10.M\", \"X0.2.07.10.M\")]))\ndataGraph &lt;- reshape2::melt(dataGraph, id = \"date\")\nggplot(data = dataGraph, aes (x = date, y = value, color = variable)) +\n    geom_sa(component = \"sa\", frequency = 12, spec = x13_spec(\"RSA4\"))\n\n\n\n\n\n\n\nFigure 1: Désaisonnalisation de plusieurs séries avec ggplot2 grâce à ggdemetra.\n\n\n\n\n\nSi vous avez déjà estimé un modèle depuis R, vous pouvez directement initialiser votre graphique grâce à la fonction init_ggplot :\n\nmod &lt;- x13(window(rjd3toolkit::ABS$X0.2.20.10.M, start = 2000))\ndiagnostics &lt;- c(`Combined test` = \"diagnostics.combined.all.summary\",\n                 `Residual qs-test (p-value)` = \"diagnostics.qs\",\n                 `Residual f-test (p-value)` = \"diagnostics.ftest\")\np_sa &lt;- init_ggplot(mod) +\n    geom_line(color =  \"#F0B400\") +\n    geom_sa(component = \"y_f\", linetype = 2,\n            color =  \"#F0B400\") + \n    geom_sa(component = \"sa\", color = \"#155692\") +\n    geom_sa(component = \"sa_f\", color = \"#155692\", linetype = 2) + \n    geom_outlier(geom = \"label_repel\",\n                 coefficients = TRUE,\n                 ylim = c(NA, 65), \n                 arrow = arrow(length = unit(0.03, \"npc\"),\n                              type = \"closed\", ends = \"last\"),\n                 digits = 2) + \n    geom_arima(geom = \"label\",\n               x_arima = -Inf, y_arima = Inf, \n               vjust = 1.2, hjust = -0.1)\np_sa +   \n    geom_diagnostics(diagnostics = diagnostics,\n                     table_theme = gridExtra::ttheme_default(base_size = 6),\n                     ymin = 115, ymax = 130, xmin = 2010,\n                     message = FALSE)\n\n\n\n\n\n\n\nFigure 2: Exemple des différentes fonctionnalités de ggdemetra.\n\n\n\n\n\nPour combiner plusieurs graphiques on peut également utiliser le package patchwork :\n\nlibrary(patchwork)\n\nWarning: package 'patchwork' was built under R version 4.4.1\n\np_diag &lt;- init_ggplot(mod)  + \n    geom_diagnostics(diagnostics = diagnostics,\n                     table_theme = gridExtra::ttheme_default(base_size = 8),\n                     message = FALSE) +\n    theme_void()\np_sa / p_diag + \n  plot_layout(heights = unit(c(4, 1.5), \"null\"))\n\n\n\n\n\n\n\nFigure 3: Combinaison de plusieurs graphiques de ggdemetra avec patchwork.\n\n\n\n\n\nLa fonction ggsiratioplot() permet de tracer les SI ratios avec ggplot2 :\n\nggsiratioplot(mod)\n\n\n\n\n\n\n\nFigure 4: S-I ratio avec ggplot2 et ggdemetra::ggsiratioplot().\n\n\n\n\n\nLes différentes composantes du modèle (ainsi que leurs prévisions) peuvent être facilement extraites via les fonctions calendar(), calendaradj(), irregular(), trendcycle(), seasonal(), seasonaladj(), trendcycle() and raw().\n\n\n\n\n\n\nExercice\n\n\n\nCréer une fonction graph_synthetique() qui prend en paramètre un modèle de rjd3x13 ou rjd3tramoseats et qui fait deux graphiques :\n\nà gauche les séries brutes, désaisonnalisée et tendance sur les 10 dernières années ;\nà droite les SI-Ratio.\n\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nPour récupérer les 10 dernières années on pourra récupérer la dernière date connue avec la fonction time() et utiliser la fonction ggplot2::coord_cartesian() (à préférer à la fonction ggplot2::xlim() qui supprime des données et refait donc une désaisonnalisation sur une autre période).\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ngraph_synthetique &lt;- function (x, titre = NULL) {\n    y &lt;- raw(x)\n    last_date &lt;- time(y)[length(y)]\n    p_sa &lt;- init_ggplot(x) +\n        geom_line(color = \"#F0B400\") +\n        geom_sa(component = \"sa\", color = \"#155692\") +\n        geom_sa(component = \"t\", color = \"#1E6C0B\") +\n        coord_cartesian(xlim = c(last_date - 10, NA)) +\n        # On change l'affichage de l'axe des abscisses\n        scale_x_continuous(labels = zoo::as.yearmon)\n    p_siratio &lt;- ggsiratioplot(x,\n                               # supprime le titre\n                               main = NULL, \n                               start = last_date - 10) \n    ((p_sa + p_siratio) &\n        # on applique la fonction theme_bw à tous les graphiques\n            theme_bw()) +\n        # On ajoute un titre global\n        plot_annotation(\n            title = titre\n        )\n}\ngraph_synthetique(mod)\n\n\n\n\n\n\n\nFigure 5: Exemple de tableau de bord grâce à ggdemetra.\n\n\n\n\n\nCi-dessous un exemple de comparaison entre ggplot2::xlim() et ggplot2::coord_cartesian() :\n\np_cc &lt;- init_ggplot(mod) +\n    geom_sa(component = \"sa\", color = \"#155692\") +\n    geom_sa(component = \"t\", color = \"#1E6C0B\") +\n    coord_cartesian(xlim = c(2010, NA), ylim = c(95, 120)) \np_xlim &lt;- init_ggplot(mod) +\n    geom_sa(component = \"sa\", color = \"#155692\") +\n    geom_sa(component = \"t\", color = \"#1E6C0B\") +\n    xlim(c(2010, NA)) +\n    coord_cartesian(ylim = c(95, 120)) \np_cc / p_xlim\n\nWarning: Removed 120 rows containing non-finite outside the scale range\n(`stat_sa()`).\n\n\nFrequency used: 12\n\n\nWarning: Removed 120 rows containing non-finite outside the scale range\n(`stat_sa()`).\n\n\n\n\n\n\n\n\nFigure 6: Comparaison des fonctions ggplot2::xlim() et ggplot2::coord_cartesian().\n\n\n\n\n\nUn message et deux warnings sont générés : c’est parce que les données avant 2010 sont supprimées avec la fonction xlim() et qu’une nouvelle désaisonnalisation est alors effectuée (avec une spécification par défaut qui peut être différente de celle utilisée pour créer le modèle). Cela explique les différences entre les deux graphiques\n\n\n\nÀ partir de la fonction précédente, on peut par exemple faire une fonction qui va lire un workspace et faire un cahier pdf le graphique précédent pour tous les modèles de chaque multiprocessing :\n\n# Construisons d'abord un workspace exemple :\ny &lt;- rjd3toolkit::ABS$X0.2.20.10.M\njws &lt;- rjd3workspace::jws_new()\njsap_x13 &lt;- rjd3workspace::jws_sap_new(jws, \"X-13\")\njsap_ts &lt;- rjd3workspace::jws_sap_new(jws, \"TRAMO-SEATS\")\nfor (spec in c(\"RSA5c\", \"RSA0\", \"RSA1\", \"RSA2c\", \"RSA3\", \"RSA4\")) {\n    rjd3workspace::add_sa_item(jsap_x13, spec, rjd3x13::x13(y, spec))\n}\nfor (spec in c(\"RSAfull\", \"RSA0\", \"RSA1\", \"RSA2\", \"RSA3\", \"RSA4\", \"RSA5\")) {\n    rjd3workspace::add_sa_item(jsap_ts, spec, rjd3tramoseats::tramoseats(y, spec))\n}\ndir &lt;- tempdir()\nsave_workspace(jws, file.path(dir, \"workspace.xml\"))\n\n\njws &lt;- load_workspace(file.path(dir, \"workspace.xml\"))\ncompute(jws)\nall_m &lt;- get_model(jws, progress_bar = FALSE)\nall_m &lt;- lapply(all_m, function(x){\n  # On enlève les espaces à la fin des noms,\n  # cela arrive souvent avec les fichiers Excel\n  names(x) &lt;- gsub(\" *$\", \"\", names(x))\n  x\n})\n# Booléen pour supprimer les fichiers existants\nreplace_existing_file &lt;- TRUE\n# dossier contenant tous les graphiques\ndir_exp &lt;- \"graph\"\nif (!dir.exists(dir_exp))\n  dir.create(dir_exp)\nfor (sap in names(all_m)) {\n  if (!dir.exists(file.path(dir_exp, sap)))\n    dir.create(file.path(dir_exp, sap))\n  for(series in names(all_m[[sap]])) {\n    # Si le fichier existe déjà on ne fait pas l'export\n    file &lt;- file.path(\n        dir_exp, sap, paste0(\n    # on ne prend que les 20 premiers caractères pour les noms des fichiers\n    # (vite trop long si on part de fichiers Excel)\n            substr(series, 1, 20), \n            \".pdf\"))\n\n    if (!replace_existing_file && file.exists(file))\n      next;\n    print(sprintf(\"%s : %s\", sap, series))\n    p_dashboard &lt;- graph_synthetique(x = all_m[[sap]][[series]],\n                                     titre = series)\n    ggsave(filename = file, plot = p_dashboard,\n           # format A4 paysage\n           width = 29.7, height = 21, units = \"cm\")\n  }\n}\n\n# Ensuite on va créer un cahier avec tous les pdfs\nfor (sap in names(all_m)) {\n  qpdf::pdf_combine(input = sprintf(\"%s/%s/%s.pdf\", dir_exp, sap,\n                                  substr(names(all_m[[sap]]), 1, 20)),\n                    output = sprintf(\"%s/%s.pdf\", dir_exp, sap))\n}"
  },
  {
    "objectID": "TP/R_5_JD_in_production_v3.html#rj3report",
    "href": "TP/R_5_JD_in_production_v3.html#rj3report",
    "title": "5 - JDemetra+ en production",
    "section": "3.2 rj3report",
    "text": "3.2 rj3report\nrj3report permet de reproduire des tableaux de bord avec les fonctions simple_dashboard() et simple_dashboard2() (légère variante avec en plus les derniers points atypiques).\nSi vous avez d’autres idées n’hésitez pas à contribuer au package ou à faire une issue sur github !\n\nlibrary(rjd3report)\n\nWarning: package 'rjd3report' was built under R version 4.4.3\n\nmod &lt;- rjd3tramoseats::tramoseats(window(RJDemetra::ipi_c_eu[,\"FR\"], end = 2019))\nplot(simple_dashboard2(mod))\n\n\n\n\n\n\n\nFigure 7: Tableau de bord de Statistique Canada avec simple_dashboard2()."
  },
  {
    "objectID": "TP/R_4_X11_v3.html",
    "href": "TP/R_4_X11_v3.html",
    "title": "4 - Qualité de la décomposition sous R",
    "section": "",
    "text": "L’objectif de ce TP est d’apprendre à étudier la qualité de la décomposition.\n\nPour installer tous les packages utiles de ce TP, lancer le programme :\n\npackages_to_install &lt;- c(\n  \"rjd3toolkit\", \"rjd3x13\", \"RJDemetra\"\n  )\n\npackages &lt;- packages_to_install[! packages_to_install %in% installed.packages()[,\"Package\"]]\nif (length(packages) &gt; 0) {\n        install.packages(\n      packages, repos = c(\"https://aqlt.r-universe.dev\", \"https://cloud.r-project.org\")\n      )\n}\n\nDans ce TP nous allons voir différentes façon de vérifier la qualité de la décomposition. Tout d’abord, on peut commencer par regarder les statistiques m dont les définitions sont rappelées ci-dessous\n\n\n\n\n\n\n\n\n\n\n\n\nPoids\nDescription\nSi problème\n\n\n\n\nM1\n10\nContribution de l’irrégulier à la variance totale (stationnarisation par différence d’ordre 3). Si trop élevé, difficile d’extraire la saisonnalité.\nPoints atypiques ou taille des filtres\n\n\nM2\n11\nContribution de l’irrégulier à la variance totale (stationnarisation par une droite).\nPoints atypiques ou taille des filtres\n\n\nM3\n10\nMesuré à partir du ratio I/C. Si trop grand on aura du mal à séparer les deux composantes.\nPoints atypiques ou taille des filtres\n\n\nM4\n8\nTest autocorrélation sur l’irrégulier (réduire le filtre saisonnier).\nFiltre saisonnier plus court\n\n\nM5\n11\nMesuré à partir du MCD (nombre de mois nécessaires pour que les variations absolues de la TC l’emporte sur I).\nPoints atypiques\n\n\nM6\n10\nVérifie si la moyenne mobile M3x5 est appropriée (\\(1.5 &lt; I/S &lt; 6.5\\)).\nPrendre filtre plus long\n\n\nM7\n18\nPermet de voir si la saisonnalité est identifiable (compare part relative de la saisonnalité stable et mobile).\nSchéma multiplicatif ?\n\n\nM8\n7\nMesure l’évolution de la S de court terme.\nChanger filtre saisonnier\n\n\nM9\n7\nMesure l’évolution de la S de long terme.\nChanger filtre saisonnier\n\n\nM10\n4\nM8 sur dernières années (\\(N-2\\) à \\(N-5\\)).\nChanger filtre saisonnier\n\n\nM11\n4\nM9 sur dernières années (\\(N-2\\) à \\(N-5\\)).\nChanger filtre saisonnier\n\n\n\n\n\nPrenons une spécification par défaut :\nLes statistiques m disponibles dans la sous-liste .$result$mstats :\n\nsa_jd3$result$mstats\n\n$m1\n[1] 0.1267867\n\n$m2\n[1] 0.07923419\n\n$m3\n[1] 1.094359\n\n$m4\n[1] 0.5580624\n\n$m5\n[1] 1.093318\n\n$m6\n[1] 0.02176203\n\n$m7\n[1] 0.08520675\n\n$m8\n[1] 0.2423733\n\n$m9\n[1] 0.06360174\n\n$m10\n[1] 0.2606264\n\n$m11\n[1] 0.247436\n\n$q\n[1] 0.3549944\n\n$qm2\n[1] 0.3890771\n\n\n\n\n\n\n\n\nExercice\n\n\n\nQue signifie ces valeurs des statistiques m plus grandes que 1 ? Est-ce important ? Si oui comment les corriger ?\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nQue pensez-vous de la tendance (plot(sa_jd3)) ? Quelle est la contribution du cycle à la variance totale (sa_jd3$result$diagnostics$vardecomposition ou rjd3toolkit::diagnostics(sa_jd3)[[1]]) ?\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nLa tendance est plutôt plate et la contribution du cycle à la variance totale est petite, on peut donc ignorer la statistique m3. La statistique M5 suggère de prendre un filtre saisonnier plus long, par exemple en utilisant le code suivant :\n\nsa2_jd3 &lt;- rjd3x13::x13(\n    sa_jd3$result$preadjust$a1,\n    sa_jd3$estimation_spec |&gt; \n        rjd3x13::set_x11(seasonal.filter = \"S3X9\"))\nsa2_jd3$result$mstats\n\n$m1\n[1] 0.2865214\n\n$m2\n[1] 0.1511407\n\n$m3\n[1] 1.490081\n\n$m4\n[1] 1.227737\n\n$m5\n[1] 1.38513\n\n$m6\n[1] 0.3221387\n\n$m7\n[1] 0.08654842\n\n$m8\n[1] 0.1630884\n\n$m9\n[1] 0.06162402\n\n$m10\n[1] 0.1329491\n\n$m11\n[1] 0.1266407\n\n$q\n[1] 0.5406235\n\n$qm2\n[1] 0.5948553\n\nrjd3toolkit::diagnostics(sa2_jd3)[[\"residual_tests\"]]\n\n               Statistic    P.value\nseas.ftest.i   0.8077490 0.63220976\nseas.ftest.sa  0.8422258 0.59838205\nseas.qstest.i  2.5023511 0.28616819\nseas.qstest.sa 5.4440143 0.06574267\ntd.ftest.i     1.1950842 0.30812329\ntd.ftest.sa    1.0416788 0.39782156\n                                                                                                   Description\nseas.ftest.i   F with 11.0 degrees of freedom in the nominator and 131.0 degrees of freedom in the denominator\nseas.ftest.sa  F with 11.0 degrees of freedom in the nominator and 131.0 degrees of freedom in the denominator\nseas.qstest.i                                                                Chi2 with 2.0 degrees of freedom \nseas.qstest.sa                                                               Chi2 with 2.0 degrees of freedom \ntd.ftest.i      F with 6.0 degrees of freedom in the nominator and 364.0 degrees of freedom in the denominator\ntd.ftest.sa     F with 6.0 degrees of freedom in the nominator and 364.0 degrees of freedom in the denominator\n\n\nMais en faisant cela on crée de la saisonnalité résiduelle ! C’est donc mieux de rester sur les paramètres par défaut.\n\n\n\nPar rapport à RJDemetra, plus d’éléments associés aux MSR sont exportables :\n\nsa_jd3 &lt;- rjd3x13::x13(\n    ipi_fr, \"rsa4\", \n    userdefined = c(\"decomposition.d9-global-msr\", \n                    \"decomposition.d9-msr\", \n                    \"decomposition.d9-msr-table\")\n)\nc(sa_jd3$user_defined)\n\n$`decomposition.d9-global-msr`\n[1] 4.054405\n\n$`decomposition.d9-msr`\n [1] 6.432093 4.778968 5.061714 4.681529 4.177106 3.200465 4.651325 2.617721\n [9] 3.885137 4.256683 6.629040 2.577652\n\n$`decomposition.d9-msr-table`\n          [,1]      [,2]      [,3]      [,4]      [,5]      [,6]      [,7]\n[1,] 0.9410370 0.8787867 1.0086908 0.7913817 1.0132386 0.8664120 0.8931384\n[2,] 0.1463034 0.1838863 0.1992785 0.1690434 0.2425695 0.2707145 0.1920181\n[3,] 6.4320925 4.7789676 5.0617144 4.6815287 4.1771061 3.2004645 4.6513245\n          [,8]      [,9]     [,10]     [,11]     [,12]\n[1,] 0.9665417 0.8704061 1.0876705 0.8972216 0.9300347\n[2,] 0.3692303 0.2240348 0.2555207 0.1353471 0.3608069\n[3,] 2.6177208 3.8851372 4.2566834 6.6290403 2.5776524"
  },
  {
    "objectID": "TP/R_3_Preadjustment_v3.html",
    "href": "TP/R_3_Preadjustment_v3.html",
    "title": "3 - Qualité du préajustement sous R",
    "section": "",
    "text": "L’objectif de ce TP est d’apprendre à vérifier la qualité du pré-ajustement.\n\nPour installer tous les packages utiles de ce TP, lancer le programme :\n\npackages_to_install &lt;- c(\"rjd3toolkit\", \"rjd3x13\", \"rjd3tramoseats\", \"rjd3providers\", \"rjd3workspace\")\n\npackages &lt;- packages_to_install[! packages_to_install %in% installed.packages()[,\"Package\"]]\nif (length(packages) &gt; 0) {\n        install.packages(\n      packages, repos = c(\"https://aqlt.r-universe.dev\", \"https://cloud.r-project.org\")\n      )\n}\n\nPrenons une spécification par défaut :\n\nlibrary(rjd3toolkit)\nlibrary(rjd3x13)\nipi_fr &lt;- RJDemetra::ipi_c_eu[, \"FR\"]\nmysa &lt;- rjd3x13::x13(ipi_fr,spec = \"RSA5c\")\n\nComme on l’a vu dans le TP2, les tests de Student peuvent être utilisés pour tester la significativité des coefficients, et on peut également faire des tests de Fisher avec le package car pour voir si l’on peut simplifier les régresseurs jours ouvrables. Voir également le TP2 pour les tests sur la présence de jours ouvrables résiduelle.\n\nsummary(mysa$result$preprocessing)\n\nLog-transformation: no \nSARIMA model: (2,1,1) (0,1,1)\n\nCoefficients\n            Estimate Std. Error  T-stat Pr(&gt;|t|)    \nphi(1)     0.0003291  0.1050495   0.003    0.998    \nphi(2)     0.1688151  0.0728072   2.319    0.021 *  \ntheta(1)  -0.5485603  0.0980879  -5.593 4.58e-08 ***\nbtheta(1) -0.6660914  0.0513396 -12.974  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nRegression model:\n                 Estimate Std. Error  T-stat Pr(&gt;|t|)    \nmonday            0.55932    0.22801   2.453 0.014662 *  \ntuesday           0.88221    0.22832   3.864 0.000133 ***\nwednesday         1.03996    0.22930   4.535 7.97e-06 ***\nthursday          0.04943    0.22944   0.215 0.829552    \nfriday            0.91132    0.22988   3.964 8.96e-05 ***\nsaturday         -1.57769    0.22775  -6.927 2.14e-11 ***\nlp                2.15402    0.70527   3.054 0.002434 ** \neaster           -2.37950    0.45392  -5.242 2.78e-07 ***\nLS (2008-11-01) -12.54899    1.63555  -7.673 1.77e-13 ***\nAO (2011-05-01)  13.49848    1.85695   7.269 2.48e-12 ***\nAO (2020-03-01) -20.89026    2.18013  -9.582  &lt; 2e-16 ***\nTC (2020-04-01) -35.59247    2.17330 -16.377  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\nNumber of observations: 372, Number of effective observations: 359, Number of parameters: 17\nLoglikelihood: -799.0845\nStandard error of the regression (ML estimate): 2.217552 \nAIC: 1632.169, AICc: 1633.964, BIC: 1698.185\n\nlibrary(car)\n# On rejette l'hypothèse de nullité globale des coefficients\nlinearHypothesis(mysa,\n                 c(\"monday\",\"tuesday\",\"wednesday\",\"thursday\",\"friday\",\"saturday\"),\n                 c(0, 0, 0, 0, 0, 0), test = \"F\")\n\n\nLinear hypothesis test:\nmonday = 0\ntuesday = 0\nwednesday = 0\nthursday = 0\nfriday = 0\nsaturday = 0\n\nModel 1: restricted model\nModel 2: mysa\n\n  Res.Df Df      F    Pr(&gt;F)    \n1    348                        \n2    342  6 83.415 &lt; 2.2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n# On pourrait rassembler les jours de la semaine :\nlinearHypothesis(mysa,\n                 c(\"monday = tuesday\",\"tuesday = wednesday\",\"\n                   wednesday = thursday\", \"thursday = friday\"), test = \"F\")\n\n\nLinear hypothesis test:\nmonday - tuesday = 0\ntuesday - wednesday = 0\nwednesday - thursday = 0\nthursday - friday = 0\n\nModel 1: restricted model\nModel 2: mysa\n\n  Res.Df Df      F  Pr(&gt;F)  \n1    346                    \n2    342  4 2.1504 0.07429 .\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nConcernant la qualité du modèle RegARIMA, on peut citer trois tests :\n\nLe test d’indépendance des résidus\nLe test d’homoscédasticité des résidus\nLe test de normalité des résidus\n\nCes trois tests, également disponibles par des fonctions spécifiques sous R (la commande residuals(mysa) permet de récupérer les résidus du modèle), sont également disponibles dans le sous objet .$result$preprocessing$diagnostics :\n\nmysa$result$preprocessing$diagnostics\n\n$mean\nValue: 0.1264845 \nP-Value: 0.8994 \n\n$skewness\nValue: -0.01953818 \nP-Value: 0.8799 \n\n$kurtosis\nValue: 3.548441 \nP-Value: 0.0339 \n\n$doornikhansen\nValue: 5.453171 \nP-Value: 0.0654 \n\n$lb\nValue: 55.08611 \nP-Value: 0.0000 \n\n$bp\nValue: 52.42581 \nP-Value: 0.0001 \n\n$seaslb\nValue: 3.099964 \nP-Value: 0.2123 \n\n$seasbp\nValue: 2.979744 \nP-Value: 0.2254 \n\n$lb2\nValue: 34.36227 \nP-Value: 0.0238 \n\n$bp2\nValue: 33.25964 \nP-Value: 0.0316 \n\n$nruns\nValue: 0.2895201 \nP-Value: 0.7722 \n\n$lruns\nValue: 14.58226 \nP-Value: 1.0000 \n\n$nudruns\nValue: -0.8784381 \nP-Value: 0.3797 \n\n$ludruns\nValue: 6.191513 \nP-Value: 1.0000 \n\n\nL’hétéroscédasticité et la non-normalité proviennent souvent de la présence de points atypiques non corrigés (pour jouer sur le seuil de détection, prendre une valeur de critical.value inférieur à 4, qui est la valeur par défaut, dans la fonction set_outliers). Changer le schéma de décomposition peut aussi aider (transform.function = \"None\" pour un modèle additif ou transform.function = \"Log\" pour un modèle multiplicatif) :\n\nmysa2 &lt;- rjd3x13::x13(\n  ipi_fr, \n  rjd3x13::spec_x13(\"RSA5c\") |&gt; \n    set_outlier(critical.value = 3)\n  )\n# Bien plus d'outliers sont détectés !\nsummary(mysa2$result$preprocessing)\n\nLog-transformation: no \nSARIMA model: (3,1,1) (0,1,1)\n\nCoefficients\n          Estimate Std. Error T-stat Pr(&gt;|t|)    \nphi(1)     0.27046    0.10353  2.612  0.00941 ** \nphi(2)     0.36526    0.08059  4.532 8.26e-06 ***\nphi(3)     0.11235    0.07978  1.408  0.16003    \ntheta(1)  -0.58596    0.09184 -6.380 6.21e-10 ***\nbtheta(1) -0.40749    0.07589 -5.370 1.52e-07 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nRegression model:\n                Estimate Std. Error  T-stat Pr(&gt;|t|)    \nmonday            0.3888     0.1853   2.098 0.036688 *  \ntuesday           0.9865     0.1858   5.309 2.08e-07 ***\nwednesday         0.9400     0.1872   5.021 8.59e-07 ***\nthursday          0.1620     0.1868   0.867 0.386634    \nfriday            0.9605     0.1891   5.080 6.45e-07 ***\nsaturday         -1.6873     0.1865  -9.045  &lt; 2e-16 ***\nlp                1.9863     0.5177   3.837 0.000150 ***\neaster           -2.3026     0.3610  -6.378 6.31e-10 ***\nAO (1991-05-01)  -4.4831     1.4122  -3.174 0.001648 ** \nLS (1993-01-01)  -3.3976     0.8510  -3.993 8.12e-05 ***\nLS (1994-05-01)   3.1013     0.8612   3.601 0.000367 ***\nTC (1994-12-01)   4.4390     1.0772   4.121 4.82e-05 ***\nLS (1997-03-01)   3.4330     0.8465   4.056 6.29e-05 ***\nLS (1997-10-01)   2.6811     0.8469   3.166 0.001696 ** \nTC (1999-12-01)   4.2817     1.1080   3.864 0.000135 ***\nAO (2000-05-01)   5.4149     1.3765   3.934 0.000103 ***\nTC (2000-11-01)   5.6357     1.0978   5.133 4.96e-07 ***\nAO (2003-06-01)  -5.4691     1.3722  -3.986 8.35e-05 ***\nLS (2008-05-01)  -4.6136     0.8664  -5.325 1.91e-07 ***\nLS (2008-11-01)  -9.6863     1.1118  -8.712  &lt; 2e-16 ***\nLS (2009-01-01)  -7.5793     1.0958  -6.917 2.55e-11 ***\nLS (2009-08-01)   5.5337     0.8948   6.184 1.91e-09 ***\nTC (2009-12-01)  -4.7614     1.1491  -4.144 4.39e-05 ***\nTC (2011-01-01)   4.7682     1.0969   4.347 1.86e-05 ***\nAO (2011-05-01)  11.6597     1.3738   8.487 8.17e-16 ***\nAO (2011-06-01)  -5.2043     1.3823  -3.765 0.000198 ***\nTC (2012-10-01)  -3.0496     1.0626  -2.870 0.004381 ** \nTC (2015-08-01)   3.5699     1.0582   3.374 0.000833 ***\nTC (2017-10-01)   4.0720     1.0691   3.809 0.000167 ***\nAO (2018-05-01)  -4.3495     1.3934  -3.121 0.001965 ** \nAO (2019-06-01)  -5.7232     1.4681  -3.898 0.000118 ***\nLS (2019-11-01)  -3.0612     0.9948  -3.077 0.002271 ** \nAO (2020-03-01) -20.6326     1.6975 -12.155  &lt; 2e-16 ***\nTC (2020-04-01) -34.9562     1.3959 -25.042  &lt; 2e-16 ***\nAO (2020-08-01)   6.0365     1.7042   3.542 0.000456 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\nNumber of observations: 372, Number of effective observations: 359, Number of parameters: 41\nLoglikelihood: -692.0561\nStandard error of the regression (ML estimate): 1.655325 \nAIC: 1466.112, AICc: 1476.977, BIC: 1625.328\n\n\nLa qualité des prévisions peut également être vérifiée à travers plusieurs tests :\n\nEst-ce que la moyenne des erreurs prévisions in sample (i.e. : modèle estimé sur toute la période) et la moyenne des prévisions out of sample (i.e. : modèle estimé de manière dynamique en ajoutant une a à une les nouvelles données) sont nulles ? Ces tests sont sensibles à la non-normalité des résidus\nEst-ce que les variances des erreurs de prévision in sample et out of sample sont les mêmes ? Ce test est sensible à la non-normalité des résidus\nEst-ce qu’il y a “trop” d’outliers ? Dans JDemetra+, on considère par défaut qu’il y a trop d’outliers si la proportion d’outliers par rapport aux nombres d’observations est supérieure à 5 %.\n\nLes trois premiers tests ne sont pas par défaut exportés : il faut les rajouter à la main avec le paramètre userdefined. Ils seront alors disponibles dans la sous-liste .$user_defined. Concernant la proportion d’outliers, elle peut être calculée à la main à partir du nombre d’outliers (par exemple disponible dans .$result_spec$regarima$regression$outliers) :\n\nmysa &lt;- x13(\n  ipi_fr, \n  mysa$estimation_spec,\n  userdefined = c(\"diagnostics.fcast-insample-mean\",\n                  \"diagnostics.fcast-outsample-mean\",\n                  \"diagnostics.fcast-outsample-variance\")\n)\n\n# Pour éviter outputs trop longs, l'affichage est réduit :\nmysa$user_defined\n\nNames of additional variables (3):\ndiagnostics.fcast-insample-mean, diagnostics.fcast-outsample-mean, diagnostics.fcast-outsample-variance\n\n# Pour supprimer cela, vous pouvez par exemple utiliser le code suivant :\nc(mysa$user_defined)\n\n$`diagnostics.fcast-insample-mean`\nValue: 0.3057319 \nP-Value: 0.7600 \n\n$`diagnostics.fcast-outsample-mean`\nValue: -0.7781645 \nP-Value: 0.4370 \n\n$`diagnostics.fcast-outsample-variance`\nValue: 1.138358 \nP-Value: 0.3129 \n\n\nVous pouvez bien sûr utiliser votre tests préféré à partir de ceux disponibles sous R (autre test de normalité…).\nPour comparer différents modèles, vous pouvez également utiliser les critères d’information (mais il faut que les modèles ARIMA aient les mêmes ordres de différenciation !). Vous pouvez pour cela utiliser les fonctions de bases de R (AIC(), BIC()…) ou prendre ceux de JDemetra+ (affichés lors du summary(), qu’on peut également retrouver par la commande .$result$preprocessing$estimation$likelihood) :\n\nAIC(mysa)\n\n[1] 1632.169\n\nBIC(mysa)\n\n[1] 1698.185\n\n# Il y a un peu plus de critères que dans base R :\nmysa$result$preprocessing$estimation$likelihood\n\nNumber of observations: 372 \nNumber of effective observations: 359 \nNumber of parameters: 17 \n\nLoglikelihood: -799.0845 \nStandard error of the regression (ML estimate): 2.217552 \nAIC: 1632.169 \nAICC: 1633.964 \nBIC: 1698.185 \n\n\n\n\n\n\n\n\nExercice\n\n\n\nPrenez une série et étudier la qualité du modèle RegARIMA. Essayer de changer quelques paramètres : est-ce que le nouveau modèle vous parait meilleur ou moins bien que l’ancien ?"
  },
  {
    "objectID": "TP/R_2_CJO_v3.html",
    "href": "TP/R_2_CJO_v3.html",
    "title": "2 - Correction des jours ouvrables",
    "section": "",
    "text": "L’objectif de ce TP est d’apprendre à créer des régresseurs jours ouvrables personnalisés, à les utiliser dans RJDemetra/JDemetra+ et à vérifier la qualité de la correction.\nPour installer tous les packages utiles de ce TP, lancer le programme :\npackages_to_install &lt;- c(\"RJDemetra\", \"rjd3toolkit\", \"rjd3x13\", \"rjd3tramoseats\", \"rjd3providers\", \"rjd3workspace\")\n\npackages &lt;- packages_to_install[! packages_to_install %in% installed.packages()[,\"Package\"]]\nif (length(packages) &gt; 0) {\n    install.packages(\n      packages, \n      repos = c(\"https://aqlt.r-universe.dev\", \"https://cloud.r-project.org\")\n      )\n}\nPour créer des régresseurs jours ouvrables personnalisés, deux solutions :\nDans ce TP, nous nous intéresserons uniquement à la seconde option. En effet, le package R est plus flexible et permet de créer des régresseurs moins classiques que les working days et trading days."
  },
  {
    "objectID": "TP/R_2_CJO_v3.html#création-dun-calendrier",
    "href": "TP/R_2_CJO_v3.html#création-dun-calendrier",
    "title": "2 - Correction des jours ouvrables",
    "section": "1.1 Création d’un calendrier",
    "text": "1.1 Création d’un calendrier\nPar défaut, les régresseurs jours ouvrables de JDemetra+ ne prennent pas en compte les spécificité calendaires des pays : on ne prend pas en compte les jours fériés. Pour les prendre en compte, il faut créer son propre calendrier où l’on supposera qu’un jour férié de plus dans le mois a le même effet qu’un dimanche.\n\nlibrary(rjd3toolkit)\n\nTrois fonctions peuvent être utilisées pour ajouter des jours fériés :\n\nfixed_day() pour ajouter un jour férié qui tombe à date fixe. Par exemple, pour ajouter le 8 mai :\n\n\nfixed_day(month =  5, day = 8)\n\n\neaster_day() pour ajouter un jour férié dont le jour dépend de Pâques : le paramètre offset permet de spécifier le nombre de jours avant (si négatif) ou après Pâques (si positif). Par exemple, pour ajouter la Pentecôte qui a lieu 60 jours après Pâques :\n\n\neaster_day(offset = 60)\n\n\nsingle_day() pour ajouter un jour ferié qui n’a eu lieu qu’une seule fois.\n\n\nsingle_day(\"1993-01-15\")\n\n\nfixed_week_day() qui permet d’ajouter des jours fériés qui apparaissent certaines semaines de certains mois (par exemple le premier lundi du mois de septembre aux USA)\n\n\nfixed_week_day(9, 1, 1) # first Monday(1) of September.\n\n\nspecial_day() qui permet d’ajouter des jours fériés par rapport à des dates déjà connues dans JDemetra+ (voir tableau ci-dessous). Comme pour la fonction easter_day(), le paramètre offset permet de spécifier la position du jour voulu par rapport rapport à la fête pré-spécifié (par défaut offset = 0, le jour férié coïncide avec le jour pré-spécifié). Par exemple, pour ajouter le nouvel an :\n\n\nspecial_day(\"NEWYEAR\")\n\n\n\n\n\nJours pré-spécifiés\n\n\nEvent\nDéfinition\n\n\n\n\nNEWYEAR\nFête fixe, 1er janvier.\n\n\nSHROVEMONDAY\nFête mobile, lundi avant le mecredi des cendres (48 jours avant pâques).\n\n\nSHROVETUESDAY\nFête mobile, mardi avant le mecredi des cendres (47 jours avant pâques).\n\n\nASHWEDNESDAY\nFête mobile, 46 jours avant Pâques.\n\n\nEASTER\nFête mobile, Pâques, varie entre le 22 mars et le 25 avril.\n\n\nMAUNDYTHURSDAY\nFête mobile, le jeudi avant Pâques.\n\n\nGOODFRIDAY\nFête mobile, le vendredi avant Pâques.\n\n\nEASTERMONDAY\nFête mobile, le lendemain de Pâques.\n\n\nASCENSION\nFête mobile, célébrée un jeudi, 40 jours après Pâques.\n\n\nPENTECOST\nFête mobile, 50 jours après Pâques.\n\n\nCORPUSCHRISTI\nFête mobile, 60 jours après Pâques.\n\n\nWHITMONDAY\nFête mobile, le jour après la Pentecôte.\n\n\nMAYDAY\nFête fixe, 1er mai.\n\n\nASSUMPTION\nFête fixe, 15 août.\n\n\nHALLOWEEN\nFête fixe, 31 octobre.\n\n\nALLSAINTSDAY\nFête fixe, 1er novembre.\n\n\nARMISTICE\nFête fixe, 11 novembre.\n\n\nCHRISTMAS\nFête fixe, 25 décembre.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nCréer un calendrier qui contient tous les jours fériés de votre pays.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nDeux exemples :\n\nCalendrier associé à la France :\n\n\nFR &lt;- list(\n    special_day(\"NEWYEAR\"),\n    special_day(\"EASTERMONDAY\"), # Lundi de Pâques\n    special_day(\"MAYDAY\"), # 1er mai\n    special_day(\"ASCENSION\"), # Jour de l'Ascension\n    fixed_day(5, 8),\n    special_day(\"WHITMONDAY\"), # Lundi de Pentecôte\n    fixed_day(7, 14),\n    special_day(\"ASSUMPTION\"), # Assomption\n    special_day(\"ALLSAINTSDAY\"), # Toussaint\n    special_day(\"ARMISTICE\")\n)\nCAL &lt;- CAL_FR &lt;- national_calendar(FR)\n\n\nCalendrier associé à la Macronia, la difficulté étant qu’il faut ajouter à la main des jours associés aux fêtes musulmanes\n\n\njours_macronia &lt;- list(\n  special_day(\"NEWYEAR\"),\n    special_day(\"EASTERMONDAY\"), # Lundi de Pâques\n  fixed_day(4, 4), # Jour de l'indépendance de la Macronia\n  special_day(\"MAYDAY\"), # 1er mai\n  special_day(\"ASCENSION\"), # Jour de l'Ascension\n    special_day(\"WHITMONDAY\"), # Lundi de Pentecôte\n  special_day(\"ASSUMPTION\"), # Assomption de Marie\n    special_day(\"ALLSAINTSDAY\"), # Toussaint\n  special_day(\"CHRISTMAS\") # Noël\n)\n# # Manque Début ramadan et jours décrétés\n# # On récupère ces jours construisant un fichier Excel\n# jours_mobiles &lt;- readxl::read_excel(\"../data/DateFetesMusulmanes_Macronia.xlsx\") |&gt;\n#   as.data.frame()\n# jours_mobiles &lt;- jours_mobiles[,-1, drop = FALSE] # on enlève l'année\n# jours_mobiles &lt;- lapply(jours_mobiles, function(x){\n#   na.omit(as.character(format(x, \"%Y-%m-%d\")))\n#   })\n# cat(unlist(lapply(names(jours_mobiles), function(day){\n#   c(\n#     sprintf(\"# %s\", day),\n#     sprintf('single_day(\"%s\")', jours_mobiles[[day]])\n#   )\n# })),\n#   sep= \",\\n\")\n\njours_macronia &lt;- c(\n  jours_macronia,\n  list(\n    # DEBUT_RAMADAN,\nsingle_day(\"2000-11-28\"),\nsingle_day(\"2001-11-17\"),\nsingle_day(\"2002-11-07\"),\nsingle_day(\"2003-10-27\"),\nsingle_day(\"2004-10-15\"),\nsingle_day(\"2005-10-05\"),\nsingle_day(\"2006-09-24\"),\nsingle_day(\"2007-09-14\"),\nsingle_day(\"2008-09-02\"),\nsingle_day(\"2009-08-22\"),\nsingle_day(\"2010-08-12\"),\nsingle_day(\"2011-08-01\"),\nsingle_day(\"2012-07-20\"),\nsingle_day(\"2013-07-10\"),\nsingle_day(\"2014-06-29\"),\nsingle_day(\"2015-07-18\"),\nsingle_day(\"2016-06-07\"),\nsingle_day(\"2017-05-27\"),\nsingle_day(\"2018-05-17\"),\nsingle_day(\"2019-05-06\"),\nsingle_day(\"2020-04-24\"),\nsingle_day(\"2021-04-14\"),\nsingle_day(\"2022-04-03\"),\nsingle_day(\"2023-03-23\"),\nsingle_day(\"2024-03-12\")\n  ))\n\nCAL &lt;- national_calendar(jours_macronia)"
  },
  {
    "objectID": "TP/R_2_CJO_v3.html#création-de-régresseurs-jo",
    "href": "TP/R_2_CJO_v3.html#création-de-régresseurs-jo",
    "title": "2 - Correction des jours ouvrables",
    "section": "1.2 Création de régresseurs JO",
    "text": "1.2 Création de régresseurs JO\nLe modèle général de correction de jours ouvrables peut s’écrire de la façon suivante : \\[\nX_t = \\sum_{i=1}^{7} \\alpha_i N_{it} + \\varepsilon_t\n\\] Avec :\n\n\\(N_{it}\\) le nombre de jours de lundis (\\(i=1\\)), …, dimanches et jours fériés (\\(i=7\\))\n\\(\\alpha_i\\) l’effet d’un jour de type \\(i\\)\n\nPour éviter les problèmes de multi-colinéarité, on réécrit le modèle en utilisant une modalité de référence (ici dimanche). On désaisonnalise également les régresseurs en enlevant la moyenne de long-terme : \\[X_t =  \\sum_{i=1}^{6} \\beta_i (N_{it} - N_{7t}) +\n\\bar{\\alpha} \\underbrace{(N_t - \\bar{N}_t)}_{LY_t} +  \\varepsilon_t\\] Ce modèle peut être simplifié si en faisant des hypothèses sur les effets des jours ouvrés :\n\nL’hypothèse working days correspond au cas où l’on suppose que tous les jours de la semaine (lundi à vendredi) ont le même effet (\\(\\alpha_1=\\dots=\\alpha_5\\)), les samedis et les dimanches (et jours fériés) ont le même effet (\\(\\alpha_6=\\alpha_7\\)) et sont utilisés en tant que variable de contraste.\nL’hypothèse trading days correspond au cas où l’on suppose que tous les jours ont un effet différent et les dimanches (et jours fériés) sont utilisés en tant que variable de constrate.\n\nSous JDemetra+ on ne peut utiliser que ces deux hypothèses mais rjd3toolkit permet de construire d’autres types de JO.\nDe manière plus générale, lorsque l’on utilise une variable de contraste, les régresseurs \\(CJO_{t,i}\\) associé au groupe \\(i\\) est calculé de la façon suivante : \\[\nCJO_{t,i} = \\underbrace{\\sum_{j\\in\\text{groupe }i}N_{jt}}_{\n\\text{nb de jours du groupe }i\n} -\n\\frac{\\sum_{j\\in\\text{groupe }i}1}{\\sum_{j\\in\\text{groupe }0}1}\n\\times\n\\underbrace{\\sum_{j\\in\\text{groupe }0}N_{jt}}_{\n\\text{nb de jours du groupe contraste}\n}\n\\] Dans le cas working days, il y a 2 jours dans le groupe contraste (samedi et dimanche, \\(\\sum_{j\\in\\text{groupe }0}1=2\\)) et 5 jours dans le groupe 1 (lundi à vendredi, \\(\\sum_{j\\in\\text{groupe }1}1=5\\)). Au mois \\(t\\), le régresseurs JO type de jours est donc égal au nombre de jours de la semaine dans le mois, mois \\(5/2\\times\\) nombre de jours de week-end.\nLes régresseurs JO peuvent être créés à partir de 2 fonctions : htd() qui permet de les créer à partir d’un calendrier spécifique et td(). Dans ces fonctions, le paramètre le plus important est groups pour permet de faire des hypothèses sur les jours. C’est un vecteur de longueur 7 (le nombre de jours de la semaine) dont chaque élément indique à quel groupe le jour de la semaine associé correspond. La variable de contraste est associé au groupe 0.\nPar exemple, groups = c(1,2,3,4,5,6,0) correspond au trading days et groups = c(1,1,1,1,1,0,0) correspond au working days.\nPar exemple :\n\ngroups &lt;- c(1, 2, 3, 4, 5, 6, 0)\nfrequency &lt;- 12\nstart &lt;- c(2000,1)\nwkd &lt;- calendar_td(CAL, frequency = frequency, start = start, length = 12*35,\n                   groups = groups)\nwkd &lt;- ts(wkd, start = start, frequency = frequency)\n\n\n\n\n\n\n\nExercice\n\n\n\nComparer le régresseurs JO working days créé avec personnalisé et celui sans hypothèse sur les jours fériés (fonction td()).\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nLes régresseurs sont bien différents :\n\ngroups &lt;- c(1, 1, 1, 1, 1, 0, 0)\nfrequency &lt;- 12\nstart &lt;- c(2000,1)\nwkd &lt;- calendar_td(CAL, frequency = frequency, start = start, length = 12*35,\n                   groups = groups)\nwkd_def &lt;- td(frequency = frequency, start = start, length = 12*35,\n              groups = groups)\nround(wkd - wkd_def,1)\n\n      Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec\n2000  2.5  0.0  0.7 -1.7  4.5 -5.5  0.0 -1.0  0.0  0.0 -4.5 -1.0\n2001 -1.0  0.0  0.7 -1.7  1.0 -2.0  0.0 -1.0  0.0  0.0 -1.0 -1.0\n2002 -1.0  0.0  0.7 -1.7 -2.5  1.5  0.0 -1.0  0.0  0.0 -4.5 -1.0\n2003 -1.0  0.0  0.7 -1.7  1.0 -2.0  0.0 -1.0  0.0 -3.5  2.5 -1.0\n2004 -1.0  0.0  0.7  1.8  1.0  1.5  0.0  2.5  0.0 -3.5 -1.0  2.5\n2005  2.5  0.0 -2.8  1.8  1.0  1.5  0.0 -1.0  0.0 -3.5 -1.0  2.5\n2006  2.5  0.0  0.7 -1.7  1.0 -2.0  0.0 -1.0  0.0  0.0 -1.0 -1.0\n2007 -1.0  0.0  0.7 -1.7 -2.5  1.5  0.0 -1.0 -3.5  0.0 -1.0 -1.0\n2008 -1.0  0.0 -2.8  1.8  1.0  1.5  0.0 -1.0 -3.5  0.0  2.5 -1.0\n2009 -1.0  0.0  0.7  1.8  1.0 -2.0  0.0  2.5  0.0  0.0  2.5 -1.0\n2010 -1.0  0.0  0.7  1.8  1.0  1.5  0.0 -1.0  0.0  0.0 -1.0  2.5\n2011  2.5  0.0  0.7 -1.7  8.0 -5.5  0.0 -4.5  0.0  0.0 -1.0  2.5\n2012  2.5  0.0  0.7 -1.7 -2.5  1.5 -3.5 -1.0  0.0  0.0 -1.0 -1.0\n2013 -1.0  0.0  0.7 -1.7 -2.5  1.5 -3.5 -1.0  0.0  0.0 -1.0 -1.0\n2014 -1.0  0.0  0.7 -1.7  1.0 -2.0  0.0 -1.0  0.0  0.0  2.5 -1.0\n2015 -1.0  0.0  0.7  1.8 -2.5  1.5  0.0  2.5  0.0  0.0  2.5 -1.0\n2016 -1.0  0.0 -2.8  1.8  1.0 -2.0  0.0 -1.0  0.0  0.0 -1.0  2.5\n2017  2.5  0.0  0.7 -1.7  1.0 -2.0  0.0 -1.0  0.0  0.0 -1.0 -1.0\n2018 -1.0  0.0  0.7 -1.7 -6.0  1.5  0.0 -1.0  0.0  0.0 -1.0 -1.0\n2019 -1.0  0.0  0.7 -1.7 -2.5 -2.0  0.0 -1.0  0.0  0.0 -1.0 -1.0\n2020 -1.0  0.0  0.7 -1.7  1.0 -2.0  0.0  2.5  0.0  0.0  2.5 -1.0\n2021 -1.0  0.0  0.7 -1.7  1.0  1.5  0.0  2.5  0.0  0.0 -1.0  2.5\n2022  2.5  0.0  0.7 -1.7  4.5 -2.0  0.0 -1.0  0.0  0.0 -1.0  2.5\n2023  2.5  0.0 -2.8 -1.7 -2.5  1.5  0.0 -1.0  0.0  0.0 -1.0 -1.0\n2024 -1.0  0.0 -2.8 -1.7 -2.5  1.5  0.0 -1.0  0.0  0.0 -1.0 -1.0\n2025 -1.0  0.0  0.7 -1.7  1.0 -2.0  0.0 -1.0  0.0  0.0  2.5 -1.0\n2026 -1.0  0.0  0.7  1.8 -2.5  1.5  0.0  2.5  0.0  0.0  2.5 -1.0\n2027 -1.0  0.0 -2.8  5.3  1.0  1.5  0.0  2.5  0.0  0.0 -1.0  2.5\n2028  2.5  0.0  0.7 -1.7  1.0 -2.0  0.0 -1.0  0.0  0.0 -1.0 -1.0\n2029 -1.0  0.0  0.7 -1.7 -2.5  1.5  0.0 -1.0  0.0  0.0 -1.0 -1.0\n2030 -1.0  0.0  0.7 -1.7  1.0 -2.0  0.0 -1.0  0.0  0.0 -1.0 -1.0\n2031 -1.0  0.0  0.7 -1.7  1.0 -2.0  0.0 -1.0  0.0  0.0  2.5 -1.0\n2032 -1.0  0.0 -2.8  5.3  1.0  1.5  0.0  2.5  0.0  0.0 -1.0  2.5\n2033  2.5  0.0  0.7 -1.7  4.5 -2.0  0.0 -1.0  0.0  0.0 -1.0  2.5\n2034  2.5  0.0  0.7 -1.7 -2.5  1.5  0.0 -1.0  0.0  0.0 -1.0 -1.0"
  },
  {
    "objectID": "TP/R_2_CJO_v3.html#régresseur-leap-year",
    "href": "TP/R_2_CJO_v3.html#régresseur-leap-year",
    "title": "2 - Correction des jours ouvrables",
    "section": "1.3 Régresseur leap year",
    "text": "1.3 Régresseur leap year\nLe régresseur année bissextile (leap year), \\(LY_t\\) doit être créé à la main. Il est égal à la différence entre le nombre de jours dans le mois \\(t\\) et le nombre de jours moyens dans le mois \\(t\\), \\(\\bar N_t\\). Tous les mois ont le même nombre de jours, sauf le mois de février qui est de 29 jours tous les 4 ans. \\(\\bar N_t\\) est donc égal à 30 ou 31 si le mois considéré n’est pas un mois de février (et donc \\(N_t - \\bar N_t=0\\)) à 28,25 en février1. \\[\nLY_{t} =\n\\begin{cases}\n0,75 & \\mbox{si } t \\mbox{ est un mois de février bissextil } \\\\\n-0,25 & \\mbox{si } t \\mbox{ est un mois de février non bissextil } \\\\\n0 & \\mbox{sinon}\n\\end{cases}\n\\]\n\n\n\n\n\n\nExercice\n\n\n\nCréer une fonction leap_year qui permet de générer le régresseur leap year.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nleap_year &lt;- function(start = 1990, end = 2030, frequency = 12){\n    ly &lt;- ts(0, start = start, end = end, frequency = 12)\n    mois_feb &lt;- cycle(ly) == 2\n    annees &lt;- trunc(round(time(ly), 3)) # arrondi car parfois des pbs avec fonction time\n    # On utilise la définition exacte\n    is_ly &lt;- (annees %% 400 == 0) |\n        ((annees %% 4 == 0) & (annees %% 100 != 0))\n    ly[mois_feb] &lt;- 28 - 28.2425\n    ly[mois_feb & is_ly] &lt;- 29 - 28.2425\n    # on change si besoin la fréquence\n    stats::aggregate(ly, nfrequency = frequency) \n}\nleap_year(frequency = 12)\n\n         Jan     Feb     Mar     Apr     May     Jun     Jul     Aug     Sep\n1990  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1991  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1992  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1993  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1994  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1995  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1996  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1997  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1998  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1999  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2000  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2001  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2002  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2003  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2004  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2005  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2006  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2007  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2008  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2009  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2010  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2011  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2012  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2013  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2014  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2015  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2016  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2017  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2018  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2019  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2020  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2021  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2022  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2023  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2024  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2025  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2026  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2027  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2028  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2029  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2030  0.0000                                                                \n         Oct     Nov     Dec\n1990  0.0000  0.0000  0.0000\n1991  0.0000  0.0000  0.0000\n1992  0.0000  0.0000  0.0000\n1993  0.0000  0.0000  0.0000\n1994  0.0000  0.0000  0.0000\n1995  0.0000  0.0000  0.0000\n1996  0.0000  0.0000  0.0000\n1997  0.0000  0.0000  0.0000\n1998  0.0000  0.0000  0.0000\n1999  0.0000  0.0000  0.0000\n2000  0.0000  0.0000  0.0000\n2001  0.0000  0.0000  0.0000\n2002  0.0000  0.0000  0.0000\n2003  0.0000  0.0000  0.0000\n2004  0.0000  0.0000  0.0000\n2005  0.0000  0.0000  0.0000\n2006  0.0000  0.0000  0.0000\n2007  0.0000  0.0000  0.0000\n2008  0.0000  0.0000  0.0000\n2009  0.0000  0.0000  0.0000\n2010  0.0000  0.0000  0.0000\n2011  0.0000  0.0000  0.0000\n2012  0.0000  0.0000  0.0000\n2013  0.0000  0.0000  0.0000\n2014  0.0000  0.0000  0.0000\n2015  0.0000  0.0000  0.0000\n2016  0.0000  0.0000  0.0000\n2017  0.0000  0.0000  0.0000\n2018  0.0000  0.0000  0.0000\n2019  0.0000  0.0000  0.0000\n2020  0.0000  0.0000  0.0000\n2021  0.0000  0.0000  0.0000\n2022  0.0000  0.0000  0.0000\n2023  0.0000  0.0000  0.0000\n2024  0.0000  0.0000  0.0000\n2025  0.0000  0.0000  0.0000\n2026  0.0000  0.0000  0.0000\n2027  0.0000  0.0000  0.0000\n2028  0.0000  0.0000  0.0000\n2029  0.0000  0.0000  0.0000\n2030                        \n\n# ou rjd3toolkit::lp_variable()\n\nOn peut également uiliser la fonction rjd3toolkit::ts_adjust() pour préajuster de l’effet année bissextile."
  },
  {
    "objectID": "TP/R_2_CJO_v3.html#exercice-bilan",
    "href": "TP/R_2_CJO_v3.html#exercice-bilan",
    "title": "2 - Correction des jours ouvrables",
    "section": "1.4 Exercice bilan",
    "text": "1.4 Exercice bilan\n\n\n\n\n\n\nExercice\n\n\n\nCréer un objet regresseurs_JO qui contiendra tous les jeux de régresseurs plausibles. Par exemple :\n\nle régresseur leap year\nle jeu de régresseur trading days (TD7, lundi à samedi, dimanche = contraste)\nle jeu de régresseur working days (TD2, lundi =… = vendredi, samedi=dimanche=contraste)\nle jeu TD3 : lundi = … = vendredi, samedi et dimanche = contraste\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nfrequency &lt;- 12\n\ngen_calendrier &lt;- function(cal, frequency, start = c(1990, 1), end = c(2030, 1)) {\n    length = (end[1] - start[1]) * frequency + end[2] - start[2]\n    ly &lt;- rjd3toolkit::lp_variable(frequency = frequency, start = start,\n                                   length = length)\n    # N'hésitez pas à ajouter les votres !\n    TD7 &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                       groups = c(1, 2, 3, 4, 5, 6, 0))\n    TD4 &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                       groups = c(1, 1, 1, 1, 2, 3, 0))\n    TD3 &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                       groups = c(1, 1, 1, 1, 1, 2, 0))\n    TD3c &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                        groups = c(1, 1, 1, 1, 2, 2, 0))\n    TD2 &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                       groups = c(1, 1, 1, 1, 1, 0, 0))\n    TD2c &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                        groups = c(1, 1, 1, 1, 1, 1, 0))\n    \n    reg_jo &lt;- ts(cbind(TD2, TD2c, TD3, TD3c, TD4, TD7),\n                 start = start, frequency = frequency)\n    reg_jo &lt;- ts.intersect(reg_jo,\n                           ly)\n    colnames(reg_jo) &lt;- c(\n        \"TD2_semaine\",\n        \"TD2c_lundi_samedi\",\n        sprintf(\"TD3_%s\", c(\"semaine\", \"samedi\")),\n        sprintf(\"TD3c_%s\", c(\"lundi_jeudi\", \"vendredi_samedi\")),\n        sprintf(\"TD4_%s\", c(\"lundi_jeudi\", \"vendredi\", \"samedi\")),\n        sprintf(\"TD7_%s\", c(\"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\")),\n        \"leap_year\")\n    reg_jo\n}\nregresseurs_JO_mens &lt;- gen_calendrier(CAL, frequency = 12)\nregresseurs_JO_trim &lt;- gen_calendrier(CAL, frequency = 4)\n# Si l'on utilise des séries mensuelles :\nregresseurs_JO &lt;- regresseurs_JO_mens\n\nSi l’on veut jongler entre R et JDemetra+, il faut ajouter les nouvelles variables dans le dictionnaire de variables de JDemetra+, voir le TP associé, ou créer le calendrier depuis JDemetra+. Une solution est de créer un workspace vide depuis R et de l’utiliser pour charger vos données. Ci-dessous un code qui vous permet d’exporter ce workspace :\n\n# On va créer deux groupes de variables en fonction de la fréquence\nctxt &lt;- rjd3toolkit::modelling_context(\n    # on appelle \"CAL\" le calendrier\n    calendars = list(CAL = CAL), \n    # on crée un groupe de variables \"cjo_mens\" contenant les régresseurs mensuels\n    # et un groupe de variables \"cjo_trim\" contenant les régresseurs trimestriels\n    variables = list(cjo_mens = regresseurs_JO_mens,\n                     cjo_trim = regresseurs_JO_trim)\n) \n\njws &lt;- rjd3workspace::jws_new(ctxt)\n# On peut également ajouter les calendriers et les variables avec les fonctions :\n# rjd3workspace:::add_variables()\n# rjd3workspace:::add_calendar()\n# Pour modifier un workspace existant :\n# rjd3workspace::set_context()\nrjd3workspace::save_workspace(jws, \"wk_CJO_v3.xml\")"
  },
  {
    "objectID": "TP/R_2_CJO_v3.html#effet-graduel-de-pâques",
    "href": "TP/R_2_CJO_v3.html#effet-graduel-de-pâques",
    "title": "2 - Correction des jours ouvrables",
    "section": "1.5 Effet graduel de Pâques",
    "text": "1.5 Effet graduel de Pâques\nPrenons l’exemple de la vente de chocolats. Il est assez commun d’offrir des chocolats à Pâques : il y a donc une hausse des ventes autour du lundi de Pâques. Toutefois, ces ventes ne se font pas le jour de Pâques mais plusieurs jours avant, et plus on se rapproche du jour J, plus ces ventes sont importantes. C’est ce que l’on appel l’effet graduel de Pâques. Sous JDemetra+ on peut définir le nombre de jours avant Pâques pour lequel on considère qu’il y a un effet (easter_day.duration, entre 1 et 20) ou laisser ce choix à JDemetra+.\n\n\n\n\n\n\nExercice\n\n\n\nSerait-il pertinent de considérer un effet graduel de Noël dans le modèle Reg-ARIMA ?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nNon car l’effet graduel de Noël est en fait saisonnier car c’est un jour fixe ! Pour Pâques, comme c’est une fête mobile, les jours précédents peuvent être dans des mois différents en fonction de l’année considérée. Je ne suis pas entré dans les détails mais le régresseur utilisé pour la correction de l’effet graduel de Pâques est désaisonnalisé pour ne prendre en compte que l’effet voulu\n\n\n\nLe régresseur associé à l’effet graduel de Pâques peut être généré en utilisant la fonction rjd3toolkit::easter_variable()."
  },
  {
    "objectID": "TP/R_2_CJO_v3.html#footnotes",
    "href": "TP/R_2_CJO_v3.html#footnotes",
    "title": "2 - Correction des jours ouvrables",
    "section": "Notes de bas de page",
    "text": "Notes de bas de page\n\n\n En réalité, la vraie valeur est 28,2425. En effet, une année bissextile est une année divisible par 4 mais pas par 100, sauf si elle est divisible par 400 : 1900 n’était pas une année bissextile mais 2000 l’était !↩︎\n Vous pouvez également utiliser le code vu dans la section 2 pour estimer un modèle automatique.↩︎"
  },
  {
    "objectID": "TP/R_1_R_et_JD_v3.html",
    "href": "TP/R_1_R_et_JD_v3.html",
    "title": "1 - R et JDemetra+",
    "section": "",
    "text": "L’objectif de ce TP est d’apprendre à manipuler JDemetra+ sous R à travers le package RJDemetra V3.\n\nPour manipuler JDemetra+ sous R il y a actuellement deux façons :\n\nUtiliser le JWSACruncher qui permet, à partir de la console, de mettre à jour un workspace JDemetra+ et d’exporter les résultats sans devoir ouvrir le logiciel. Pour faciliter son utilisation depuis R, le package rjwsacruncher peut être utilisé (voir TP5 - JDemetra+ en production).\nUtiliser les packages R associés à JDemetra+ qui permettent d’effectuer des désaisonnalisations avec les mêmes algorithmes et paramètres que JDemetra+ et de manipuler des workspaces.\n\nDans ce TP on utilisera les données du package RJDemetra mais n’hésitez pas à utiliser vos propres séries !\nPour faire de la désaisonnalisation sous R il existe plusieurs packages :\n\nseasonal et x12 qui permettent de faire du X-13ARIMA-SEATS en utilisant les programmes du US Census Bureau\nRJDemetra qui est une interface R à JDemetra+ 2.x.y.\nUn ensemble de packages associés à JDemetra+ 3.x.y disponibles à l’addresse https://github.com/rjdverse. C’est ce que l’on utilisera dans ce TP. Ces packages nécessite d’avoir avoir Java 17 ou plus. En cas de problème d’installation voir le manuel d’installation .\n\nDans cette formation, nous utiliserons les packages suivants RJDemetra, rjd3toolkit, rjd3tramoseats, rjd3providers, rjd3workspace :\n\npackages_to_install &lt;- c(\"RJDemetra\", \"rjd3toolkit\", \"rjd3x13\", \"rjd3tramoseats\", \"rjd3providers\", \"rjd3workspace\")\n\npackages &lt;- packages_to_install[! packages_to_install %in% installed.packages()[,\"Package\"]]\nif (length(packages) &gt; 0) {\n  install.packages(\n    packages, \n    repos = c(\"https://aqlt.r-universe.dev\", \"https://cloud.r-project.org\")\n  )\n}\n\n\n1 Créer une specification\nLes modèles autour de la méthode X-13ARIMA peuvent être estimés avec rjd3x13::x13(), rjd3x13::regarima()) et rjd3x13::x11().\nLes spécifications peuvent être crées avec les fonctions rjd3x13::spec_regarima, rjd3x13::spec_x11() ou rjd3x13::spec_x13() et peuvent être modifiées par :\n\nPour le préajustement : rjd3toolkit::set_arima(), rjd3toolkit::set_automodel(), rjd3toolkit::set_basic(), rjd3toolkit::set_easter(), rjd3toolkit::set_estimate(), rjd3toolkit::set_outlier(), rjd3toolkit::set_tradingdays(), rjd3toolkit::set_transform(), rjd3toolkit::add_outlier(), rjd3toolkit::remove_outlier(), rjd3toolkit::add_ramp(), rjd3toolkit::remove_ramp(), rjd3toolkit::add_usrdefvar() ;\nPour la décomposition : rjd3x13::set_x11() ;\nPour le benchmarking : rjd3toolkit::set_benchmarking().\n\n\n\n\n\n\n\nExercice\n\n\n\nFaire la désaisonnalisation d’une série avec X-13 avec la spécification suivante :\n\ndétection automatique du schéma de décomposition, des outliers et du modèle ARIMA ;\nune correction des jours ouvrables “working days” et un effet graduel de Pâques.\n\nFaire ensuite un graphique avec la série brute et la série désaisonnalisée.\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nUtiliser la spécification RSA4 pour la désaisonnalisation.\nSi le modèle créé s’appelle sa_jd3, regarder les valeurs de sa_jd3$result$final et rjd3toolkit::sa_decomposition(sa_jd3).\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nsa_jd3 &lt;- rjd3x13::x13(RJDemetra::ipi_c_eu[, \"FR\"], \"rsa4\")\nsa_jd3\n\nModel: X-13\nLog-transformation: no \nSARIMA model: (2,1,1) (0,1,1)\n\nSARIMA coefficients:\n   phi(1)    phi(2)  theta(1) btheta(1) \n  0.05291   0.18672  -0.52138  -0.66132 \n\nRegression model:\n             td              lp          easter LS (2008-11-01) LS (2009-01-01) \n         0.6927          2.0903         -2.5476         -9.2744         -7.2838 \nAO (2011-05-01) AO (2020-03-01) TC (2020-04-01) \n        13.1870        -21.1492        -35.6481 \n\n Seasonal filter: S3X3;  Trend filter: H-13 terms\n M-Statistics: q Good (0.355); q-m2 Good (0.389)\n QS test on SA: Good (0.924);  F-test on SA: Good (0.632)\n\nFor a more detailed output, use the 'summary()' function.\n\ny &lt;- sa_jd3$result$preadjust$a1\nsa &lt;- sa_jd3$result$final$d11final\n# ou :\ndecomp &lt;- rjd3toolkit::sa_decomposition(sa_jd3)\ny &lt;- decomp$series\nsa &lt;- decomp$sa\n# ou on peut directement utiliser les fonctions de rjd3x13 :\nplot(sa_jd3, first_date = 2000 #Pour n'afficher le graphique qu'à partir de 200\n)\n\n\n\n\n\n\n\n\nPour des graphiques ggplot2, on peut également utiliser le package ggdemetra3.\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nModifier le modèle précédent pour enlever l’effet graduel de Pâques.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nspec_sans_easter_v3 &lt;- \n    sa_jd3$estimation_spec |&gt; \n    rjd3toolkit::set_easter(enabled = FALSE)\nsa2_jd3 &lt;- rjd3x13::x13(RJDemetra::ipi_c_eu[, \"FR\"], spec_sans_easter_v3)\nsa2_jd3$result$preprocessing\n\nLog-transformation: no \nSARIMA model: (2,1,1) (0,1,1)\n\nSARIMA coefficients:\n   phi(1)    phi(2)  theta(1) btheta(1) \n  0.02527   0.10075  -0.59512  -0.71292 \n\nRegression model:\n             td              lp LS (2008-11-01) AO (2011-05-01) AO (2020-03-01) \n         0.7032          2.1641        -12.7560         13.1047        -20.3006 \nTC (2020-04-01) \n       -36.4048 \n\nFor a more detailed output, use the 'summary()' function.\n\n\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nCalculer les p-valeurs associées au modèle Reg-ARIMA de la précédente spécification.\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nRécupérer le modèle Reg-ARIMA et utiliser la fonction summary().\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nsummary(sa2_jd3$result$preprocessing)\n\nLog-transformation: no \nSARIMA model: (2,1,1) (0,1,1)\n\nCoefficients\n          Estimate Std. Error  T-stat Pr(&gt;|t|)    \nphi(1)     0.02527    0.09998   0.253    0.801    \nphi(2)     0.10075    0.07425   1.357    0.176    \ntheta(1)  -0.59512    0.08863  -6.715 7.65e-11 ***\nbtheta(1) -0.71292    0.04618 -15.439  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nRegression model:\n                 Estimate Std. Error  T-stat Pr(&gt;|t|)    \ntd                0.70321    0.03417  20.582  &lt; 2e-16 ***\nlp                2.16412    0.76568   2.826  0.00498 ** \nLS (2008-11-01) -12.75601    1.66740  -7.650 1.99e-13 ***\nAO (2011-05-01)  13.10471    1.97806   6.625 1.32e-10 ***\nAO (2020-03-01) -20.30056    2.25944  -8.985  &lt; 2e-16 ***\nTC (2020-04-01) -36.40477    2.19426 -16.591  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\nNumber of observations: 372, Number of effective observations: 359, Number of parameters: 11\nLoglikelihood: -817.6149\nStandard error of the regression (ML estimate): 2.330069 \nAIC: 1657.23, AICc: 1657.991, BIC: 1699.946\n\n\n\n\n\n\n\n2 Créer un workspace\nDans cette partie nous allons créer un workspace depuis R. Pour cela les fonctions qui peuvent être utilisées sont rjd3workspace::jws_new(), rjd3workspace::read_workspace(), rjd3workspace::jws_sap_new(), rjd3workspace::add_sa_item(), rjd3workspace::save_workspace().\n\n\n\n\n\n\nExercice\n\n\n\nCréer un workspace qui va contenir une série désaisonnalisée selon 3 spécifications différentes.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\njws &lt;- rjd3workspace::jws_new()\njsap &lt;- rjd3workspace::jws_sap_new(jws, \"MP-1\")\nrjd3workspace::add_sa_item(jsap, \"X13 avec Pâques\", sa_jd3)\nrjd3workspace::add_sa_item(jsap, \"X13 sans Pâques\", sa2_jd3)\nrjd3workspace::add_sa_item(jsap, \"TRAMO-SEATS\", y, rjd3tramoseats::spec_tramoseats())\nrjd3workspace::save_workspace(jws, \"ws_v3.xml\")\n\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nImporter le workspace précédent et récupérer :\n\nLe nom du premier multi-processing\nLe nombre de modèles dans ce premier multi-processing\nL’ensemble des séries brutes\nLe 2ème modèle\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# charge tous les modèles du workspace :\njws &lt;- rjd3workspace::.jws_open(\"ws_v3.xml\")\nws &lt;- rjd3workspace::read_workspace(jws)\nnames(ws$processing)[1]\n\n[1] \"MP-1\"\n\nlength(ws$processing[[1]]) # Nombre de multiprocessing\n\n[1] 3\n\n\nAutre façon de faire similaire à RJDemetra :\n\n# charge tous les modèles du workspace :\njws &lt;- rjd3workspace::.jws_open(\"ws_v3.xml\")\nrjd3workspace::jws_compute(jws)\nrjd3workspace::ws_sap_count(jws) # Nombre de multiprocessing\n\n[1] 1\n\njsap1 &lt;- rjd3workspace::jws_sap(jws, 1) # Le premier multiprocessing\nrjd3workspace::sap_name(jsap1)\n\n[1] \"MP-1\"\n\nrjd3workspace::sap_sai_count(jsap1)\n\n[1] 3\n\nmodel2 &lt;- rjd3workspace::jsap_sai(jsap1, 2) # On récupère l'objet associé au 2ème modèle\nrjd3workspace::read_sai(model2)\n\n$ts\n$name\n[1] \"X13 sans Pâques\"\n\n$moniker\n$source\n[1] \"\"\n\n$id\n[1] \"54564427-00d3-498b-bbd1-2c745e88e096\"\n\nattr(,\"class\")\n[1] \"JD3_TSMONIKER\"\n\n$metadata\nNULL\n\n$data\n       Jan   Feb   Mar   Apr   May   Jun   Jul   Aug   Sep   Oct   Nov   Dec\n1990  92.1  92.3 102.1  93.0  93.3 100.8  92.9  66.7  95.8 105.0  96.7  89.2\n1991  92.5  89.2  97.4  93.8  87.5 100.3  93.4  64.3  96.9 103.5  94.0  92.1\n1992  90.7  89.0  99.4  93.7  86.1 101.3  90.4  62.9  96.6  98.4  91.9  92.6\n1993  82.3  84.0  95.6  88.3  82.2  97.9  85.5  61.3  93.7  93.0  88.3  92.1\n1994  83.6  83.7  97.0  88.3  88.3 102.9  87.3  65.9  98.2  98.0  96.8  98.0\n1995  91.8  90.1 102.9  90.4  91.6 103.7  90.6  66.8  98.7 101.4  97.2  94.8\n1996  92.0  91.1  98.1  94.3  90.5 101.8  96.1  66.3  98.9 105.0  95.0  96.0\n1997  91.9  91.3  99.1 102.8  93.2 108.2 100.4  70.5 107.3 114.1  99.6 106.7\n1998  98.2  98.7 109.3 103.7  97.6 114.7 106.1  72.1 111.5 112.6 105.6 107.4\n1999  97.2  98.3 114.5 104.8  99.9 120.2 105.7  76.1 115.2 115.1 111.1 114.0\n2000 103.4 107.5 121.7 105.7 113.1 119.4 108.1  82.0 116.4 121.3 117.2 111.9\n2001 110.7 108.9 124.0 109.3 109.8 121.9 112.4  85.5 114.1 123.4 114.2 104.9\n2002 108.4 106.7 118.5 113.4 105.6 119.2 113.9  81.4 115.6 121.7 111.0 105.2\n2003 106.9 105.4 117.1 112.0 101.5 115.2 111.2  75.7 117.5 122.4 107.8 109.3\n2004 104.7 106.7 122.8 112.7 104.5 126.5 111.1  79.7 121.9 118.8 112.2 112.6\n2005 107.6 106.3 118.8 113.7 109.7 125.0 106.4  81.7 123.0 115.1 115.5 111.6\n2006 108.8 105.9 124.8 108.0 113.1 126.7 108.7  84.1 121.0 121.5 116.6 108.2\n2007 111.5 109.6 124.0 111.7 111.7 126.6 116.6  87.1 117.3 127.2 118.0 106.5\n2008 113.2 114.4 117.5 120.2 107.6 121.4 115.1  78.8 118.9 118.8  99.5  99.2\n2009  90.7  90.1 100.0  93.9  88.3 105.5  97.9  70.3 106.5 104.7  99.0  95.2\n2010  90.3  93.1 109.5 100.4  95.5 111.8 100.8  74.5 109.0 105.0 102.7 101.9\n2011  99.0 101.6 115.3 101.6 110.1 108.5 101.0  78.3 110.0 106.4 106.3 100.2\n2012  99.3  99.9 110.3  99.8  96.1 108.5 103.8  78.8 102.9 107.6 101.9  91.5\n2013  96.3  95.7 103.9 103.4  96.2 105.5 105.2  73.4 103.3 109.3  99.0  94.6\n2014  96.8  97.1 104.9 102.9  92.4 104.8 103.3  71.5 107.2 107.7  95.5  98.4\n2015  94.6  96.1 108.4 102.4  91.0 111.8 101.1  76.1 109.1 107.7 101.8  99.9\n2016  95.1  99.6 108.3 103.3  98.6 110.3  95.8  79.7 107.9 103.4 104.7  99.7\n2017  98.9  97.1 114.5  98.0 102.7 111.4  99.5  81.4 108.2 113.2 111.0  99.5\n2018 101.8  98.6 112.9 103.0  98.7 112.8 106.6  82.6 104.7 116.0 109.6  97.6\n2019 103.8 102.0 111.6 107.2 105.2 106.0 109.8  78.8 109.0 116.5 104.0  97.8\n2020 101.0 100.1  91.8  66.7  73.7  98.2  97.4  71.7 104.7 106.7 101.6  96.6\n\nattr(,\"class\")\n[1] \"JD3_TS\"\n\n$domainSpec\nSpecification\n\nSeries\nSerie span: All \nPreliminary Check: Yes\n\nEstimate\nModel span: All \n\nTolerance: 1e-07\n\nTransformation\nFunction: AUTO\nAIC difference: -2\nAdjust: NONE\n\nRegression\nCalendar regressor: WorkingDays\nwith Leap Year: Yes\nAutoAdjust: TRUE\nTest: REMOVE\n\nEaster: No\n\nPre-specified outliers: 0\nRamps: No\n\nOutliers\nDetection span: All \nOutliers type: \n    - AO, critical value : 0 (Auto)\n    - LS, critical value : 0 (Auto)\n    - TC, critical value : 0 (Auto)\nTC rate: 0.7 (Auto)\nMethod: ADDONE (Auto)\n\nARIMA\nSARIMA model: (0,1,1) (0,1,1)\n\nSARIMA coefficients:\n theta(1) btheta(1) \n        0         0 \n\nSpecification X11\nSeasonal component: Yes\nLength of the Henderson filter: 0\nSeasonal filter: FILTER_MSR\nBoundaries used for extreme values correction : \n     lower_sigma:  1.5 \n     upper_sigma:  2.5\nNb of forecasts: -1\nNb of backcasts: 0\nCalendar sigma: NONE\n\nBenchmarking\nIs enabled: No\n\n$estimationSpec\nSpecification\n\nSeries\nSerie span: All \nPreliminary Check: Yes\n\nEstimate\nModel span: All \n\nTolerance: 1e-07\n\nTransformation\nFunction: AUTO\nAIC difference: -2\nAdjust: NONE\n\nRegression\nCalendar regressor: WorkingDays\nwith Leap Year: Yes\nAutoAdjust: TRUE\nTest: REMOVE\n\nEaster: No\n\nPre-specified outliers: 0\nRamps: No\n\nOutliers\nDetection span: All \nOutliers type: \n    - AO, critical value : 0 (Auto)\n    - LS, critical value : 0 (Auto)\n    - TC, critical value : 0 (Auto)\nTC rate: 0.7 (Auto)\nMethod: ADDONE (Auto)\n\nARIMA\nSARIMA model: (0,1,1) (0,1,1)\n\nSARIMA coefficients:\n theta(1) btheta(1) \n        0         0 \n\nSpecification X11\nSeasonal component: Yes\nLength of the Henderson filter: 0\nSeasonal filter: FILTER_MSR\nBoundaries used for extreme values correction : \n     lower_sigma:  1.5 \n     upper_sigma:  2.5\nNb of forecasts: -1\nNb of backcasts: 0\nCalendar sigma: NONE\n\nBenchmarking\nIs enabled: No\n\n$pointSpec\nSpecification\n\nSeries\nSerie span: All \nPreliminary Check: Yes\n\nEstimate\nModel span: All \n\nTolerance: 1e-07\n\nTransformation\nFunction: LEVEL\nAIC difference: -2\nAdjust: NONE\n\nRegression\nCalendar regressor: WorkingDays\nwith Leap Year: Yes\nAutoAdjust: FALSE\nTest: NO\n\nEaster: No\n\nPre-specified outliers: 4\n    - LS (2008-11-01), coefficient: -12.7560067943903 (ESTIMATED)\n    - AO (2011-05-01), coefficient: 13.1047116166881 (ESTIMATED)\n    - AO (2020-03-01), coefficient: -20.3005616124476 (ESTIMATED)\n    - TC (2020-04-01), coefficient: -36.4047650490134 (ESTIMATED)\nRamps: No\n\nOutliers\nIs enabled: No\n\nARIMA\nSARIMA model: (2,1,1) (0,1,1)\n\nSARIMA coefficients:\n   phi(1)    phi(2)  theta(1) btheta(1) \n  0.02527   0.10075  -0.59512  -0.71292 \n\nSpecification X11\nSeasonal component: Yes\nLength of the Henderson filter: 0\nSeasonal filter: FILTER_MSR\nBoundaries used for extreme values correction : \n     lower_sigma:  1.5 \n     upper_sigma:  2.5\nNb of forecasts: -1\nNb of backcasts: 0\nCalendar sigma: NONE\n\nBenchmarking\nIs enabled: No\n\n$results\nModel: X-13\nLog-transformation: no \nSARIMA model: (2,1,1) (0,1,1)\n\nSARIMA coefficients:\n   phi(1)    phi(2)  theta(1) btheta(1) \n  0.02527   0.10075  -0.59512  -0.71292 \n\nRegression model:\n             td              lp LS (2008-11-01) AO (2011-05-01) AO (2020-03-01) \n         0.7032          2.1641        -12.7560         13.1047        -20.3006 \nTC (2020-04-01) \n       -36.4048 \n\n Seasonal filter: S3X3;  Trend filter: H-13 terms\n M-Statistics: q Good (0.316); q-m2 Good (0.346)\n QS test on SA: Good (1.000);  F-test on SA: Good (0.646)\n\nFor a more detailed output, use the 'summary()' function.\n\n# Pour extraire toutes les séries brutes il faut faire une boucle :\nall_y &lt;- lapply(\n    lapply(\n        seq_len(rjd3workspace::sap_sai_count(jsap1)),\n        rjd3workspace::.jsap_sai, jsap = jsap1\n    ),\n    rjd3workspace::get_raw_data\n)\n\n\n\n\n\n\n3 Manipuler les objets Java\nLa manipulation des objets Java se fait de la même façon qu’avec RJDemetra : .jx13() pour estimer les modèles (nom de la fonction légèrement différente), rjd3toolkit::dictionary() pour connaitre l’ensemble des objets exportables et rjd3toolkit::result() et rjd3toolkit::user_defined() pour exporter des objets.\n\n\n\n\n\n\nExercice\n\n\n\nCréer un modèle à partir de la fonction .jx13() et la spécification sans effet graduel de pâques calculée dans la section 1.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nmyjsa &lt;- rjd3x13::.jx13(RJDemetra::ipi_c_eu[, \"FR\"], spec_sans_easter_v3)\nrjd3toolkit::result(myjsa, \"sa\")\n\n           Jan       Feb       Mar       Apr       May       Jun       Jul\n1990  93.24955  95.30940  94.71796  93.81684  93.54929  92.92520  94.21426\n1991  93.59169  92.31215  92.64331  92.17822  87.64814  94.71770  92.26714\n1992  91.58585  91.95491  92.44861  92.08835  91.15320  90.56855  89.24060\n1993  87.99561  87.69727  86.39964  86.75333  87.31361  86.83199  86.72062\n1994  89.29811  87.67745  87.97237  89.30396  91.16780  91.47286  90.78785\n1995  95.25155  94.23926  93.90860  94.00837  92.19870  91.94726  93.82107\n1996  93.17973  92.48812  93.89705  93.13793  91.31516  94.72025  94.11951\n1997  93.26078  95.70964  94.51600 101.81259  96.59510  98.42946  98.22737\n1998 102.21091 103.17118 101.63558 102.93616 103.62068 102.28550 103.77953\n1999 103.79658 102.78743 103.69074 104.14106 106.09004 107.66846 105.67101\n2000 110.10497 109.06807 110.12489 109.82704 114.79035 106.77270 110.36351\n2001 112.60460 113.23756 114.26231 110.62978 111.90510 111.50689 112.11052\n2002 110.38323 110.96526 110.79945 111.78627 107.92165 110.99153 111.32654\n2003 108.79624 109.74015 109.32134 109.98806 106.03352 104.23265 108.95547\n2004 108.85117 110.81356 110.13728 110.54560 111.16466 112.78890 111.54538\n2005 113.93316 110.84172 106.41816 114.18867 113.55450 111.11371 109.26845\n2006 112.42833 110.33885 112.86559 111.31529 114.27002 113.01129 111.32242\n2007 112.55694 113.84939 115.05181 112.93951 112.66924 115.79095 116.41635\n2008 114.19262 115.43079 111.37148 119.20887 111.21601 111.20490 111.96753\n2009  94.06595  93.66765  91.59029  92.93345  94.74414  93.45541  94.24009\n2010  96.01716  96.45680  98.71937  99.12528 102.35680 100.33373  99.14123\n2011 104.73308 104.88254 104.41611 102.25226 114.86761  97.50904 101.41146\n2012 102.69646 100.10116 101.67631  99.91395  98.94360 100.23048 101.39058\n2013  97.38049  98.67284  97.59268 100.48330  99.43876  99.96091 100.12816\n2014  98.00446 100.13410  98.51684  99.69373  98.14253  97.00824  98.38996\n2015  98.43075  99.49303  99.43229  99.18875  98.89465 101.71133  96.50599\n2016 101.43553 100.46907  96.73895 102.94029 103.57872 100.21169  96.40288\n2017 102.83484 101.21980 102.93078 100.60288 104.65915 101.21299 100.09477\n2018 103.34498 102.86547 103.87513 103.61900 100.09104 104.87134 104.57061\n2019 105.55319 106.23769 105.20469 105.62380 106.14533 100.29916 105.00063\n2020 102.89360 103.74645  83.07039  65.24951  79.29577  87.38128  92.35517\n           Aug       Sep       Oct       Nov       Dec\n1990  92.38173  93.51234  93.42343  92.18042  90.41279\n1991  92.42873  92.22349  92.01173  92.00186  90.59538\n1992  93.45078  89.51221  89.56165  89.95835  88.19546\n1993  89.35917  86.63394  86.80871  84.00049  87.21539\n1994  91.47220  91.08205  91.83094  92.70377  95.22430\n1995  92.43935  93.94802  92.67708  93.29762  94.39315\n1996  94.63683  93.94307  93.57709  93.75204  93.25425\n1997 101.68755  99.71695 102.44668 100.79734 101.82217\n1998 103.67043 103.81100 103.12842 104.36147 102.98643\n1999 105.51412 107.47894 108.01349 107.32689 110.17856\n2000 109.19601 111.03577 111.63442 113.48334 113.71019\n2001 112.97886 110.95332 111.23200 110.59473 107.49517\n2002 111.59373 109.55119 109.54524 110.06801 106.01718\n2003 108.67882 108.40221 110.46920 109.44340 108.13524\n2004 110.49903 112.36423 111.93619 108.93019 111.82427\n2005 110.17307 113.24026 108.51104 112.00879 113.43584\n2006 112.19306 113.67537 112.74018 112.68488 112.70890\n2007 114.35913 112.60498 116.41114 113.72338 111.21506\n2008 109.87755 109.64124 108.31326  99.94885  99.31443\n2009 100.20028  97.57161  97.15487  97.05587  95.50465\n2010 100.91566 100.33425 100.28702  98.54035 102.42445\n2011 101.41452 101.52787 102.02302 102.59491 103.34800\n2012 101.29425  99.61270  98.34668  98.61297  97.28502\n2013  97.82035  97.74060 100.19255  98.38971  97.85776\n2014  98.04534  99.36208  98.45915  97.19073  99.09353\n2015 102.42001 101.51956 100.68665 100.72423 100.52605\n2016 101.09905 100.59846  98.34729 100.76466 102.91719\n2017 102.74040 103.61311 105.30626 106.79695 105.62276\n2018 103.94813 102.71388 105.22599 105.29463 104.37228\n2019 102.51548 104.62023 105.52898 102.28202 102.79014\n2020  97.79844  97.77412  98.09488 100.12642  99.63962\n\n\n\n\n\nPour les révisions, la fonction rjd3x13::x13_revisions() facilite grandement la tâche. L’historique des révisions peut s’exporter à partir de trois paramètres :\n\ndata_ids qui permet d’exporter des statistiques ;\nts_ids qui permet d’exporter des estimations d’une composante à une certaine date ;\ncmp_ids qui permet l’ensemble des estimations d’une composante à une ensemble de dates.\n\n\ndata_ids &lt;- list(\n    # Export du coefficient du premier régresseur jours ouvrables\n    list(start = \"2005-01-01\", id = \"regression.td(1)\"))\nts_ids &lt;- list(\n    # Export de l'historique des estimations de la séries SA de janv 2010 à partir de janvier 2010\n    list(period = \"2010-01-01\", start = \"2010-01-01\", id = \"sa\"))\ncmp_ids &lt;- list(\n    # Export de l'ensemble des tendances estimées entre janv 2010 et dec 2014\n    list(start = \"2010-01-01\", end = \"2014-12-01\", id = \"t\"))\nrh &lt;- rjd3x13::x13_revisions(\n    sa2_jd3$result$preadjust$a1,\n    spec = sa2_jd3$result_spec, \n    data_ids, ts_ids, cmp_ids)\nplot(rh$data$`regression.td(1)`,\n     ylab = \"Coef\", main = \"Coef td\")\n\n\n\n\n\n\n\nplot(rh$series$sa,\n     ylab = NULL, main = \"SA de janv 2010\")\n\n\n\n\n\n\n\nncol(rh$components$t) # nombre de séries exportées\n\n[1] 60"
  },
  {
    "objectID": "TP/R_0_Manipulation_series_temporelles.html",
    "href": "TP/R_0_Manipulation_series_temporelles.html",
    "title": "0 - Traitement des séries temporelles sous ",
    "section": "",
    "text": "L’objectif de ce TP est d’apprendre à manipuler les séries temporelles sous R en utilisant les packages de bases.\nDans R il existe de nombreux packages qui permettent de manipuler les séries temporelles. Pour n’en citer que quelques-uns :\n- Les objets ts peuvent être créés à partir du package stats ;\n- Les objets zoo peuvent être créés à partir du package zoo ;\n- Les objets xts peuvent être créés à partir du package xts ;\n- Les objets tis peuvent être créés à partir du package tseries ;\n- Les objets tsibble peuvent être créés à partir du package tsibble.\ntsbox permet quand à lui de facilement passer d’une classe à l’autre.\nIci nous nous concentrerons essentiellement sur les trois premiers : ts stocker les séries temporelles, zoo et xts pour effectuer certaines manipulations supplémentaires.\nLes packages suivants seront utilisés :\npackages_to_install &lt;- c(\"zoo\", \"xts\", \"dplyr\", \"XLConnect\", \"rjd3toolkit\")\n\npackages &lt;- packages_to_install[! packages_to_install %in% installed.packages()[,\"Package\"]]\nif (length(packages) &gt; 0) {\n    install.packages(\n      packages, repos = c(\"https://aqlt.r-universe.dev\", \"https://cloud.r-project.org\")\n      )\n}"
  },
  {
    "objectID": "TP/R_0_Manipulation_series_temporelles.html#création-dune-série-temporelle",
    "href": "TP/R_0_Manipulation_series_temporelles.html#création-dune-série-temporelle",
    "title": "0 - Traitement des séries temporelles sous ",
    "section": "1.1 Création d’une série temporelle",
    "text": "1.1 Création d’une série temporelle\nLa fonction ts() permet de créer des objets séries-temporelles à partir un vecteur (ou une matrice). La syntaxe de base est ts(vector, start=, end=, frequency=) où start et end sont la première et la dernière observation, frequency est le nombre d’observations par unité de temps (1=annuelle, 2=semestrielle, 4=trimestrielle, 6=bi-mestrielle, 12=mensuelle, etc.).\nPar exemple pour créer une série trimestrielle ayant les valeurs de 1 à 10 et commençant en 1959Q2 :\n\nts(1:10, frequency = 4, start = c(1959, 2)) # 2ème trimestre de 1959\n\n     Qtr1 Qtr2 Qtr3 Qtr4\n1959         1    2    3\n1960    4    5    6    7\n1961    8    9   10     \n\n# Équivalent à \nts(1:10, frequency = 4, start = 1959 + 1/4)\n\n     Qtr1 Qtr2 Qtr3 Qtr4\n1959         1    2    3\n1960    4    5    6    7\n1961    8    9   10     \n\n\nOn peut aussi définir l’objet à partir de sa date de fin :\n\nts(1:10, frequency = 4, end = c(1959, 2))\n\n     Qtr1 Qtr2 Qtr3 Qtr4\n1957    1    2    3    4\n1958    5    6    7    8\n1959    9   10          \n\n\nSi l’on directement extraire un sous-ensemble de la série on peut spécifier les paramètres end et start. Par exemple pour ne garder que les valeurs jusqu’en 1960 inclus :\n\nts(1:10, frequency = 4, start = c(1959, 2), end = c(1960, 4))\n\n     Qtr1 Qtr2 Qtr3 Qtr4\n1959         1    2    3\n1960    4    5    6    7\n\n\nOu alors utiliser la fonction window une fois l’objet créé :\n\nts_object &lt;- ts(1:10, frequency = 4, start = c(1959, 2))\nwindow(ts_object, end = c(1960, 4))\n\n     Qtr1 Qtr2 Qtr3 Qtr4\n1959         1    2    3\n1960    4    5    6    7\n\n\nOn peut récupérer les différents attributs avec les fonctions start(), end() et frequency() :\n\nstart(ts_object)\n\n[1] 1959    2\n\nend(ts_object)\n\n[1] 1961    3\n\nfrequency(ts_object)\n\n[1] 4\n\n\nDeux autres fonctions peuvent aussi être utiles : time() crée un série-temporelle à partir des dates de notre série-temporelle et cycle() donne la position dans le cycle de chaque observation.\n\ntime(ts_object)\n\n        Qtr1    Qtr2    Qtr3    Qtr4\n1959         1959.25 1959.50 1959.75\n1960 1960.00 1960.25 1960.50 1960.75\n1961 1961.00 1961.25 1961.50        \n\ncycle(ts_object)\n\n     Qtr1 Qtr2 Qtr3 Qtr4\n1959         2    3    4\n1960    1    2    3    4\n1961    1    2    3     \n\n\n\n\n\n\n\n\nExercice\n\n\n\nExtraire toutes les données du 2ème trimestre de l’objet ts_object\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nts_object[cycle(ts_object) == 2]\n\n[1] 1 5 9\n\n\nAutre option : utiliser la fonction window()\n\nwindow(ts_object, frequency = 1)\n\nTime Series:\nStart = 1959.25 \nEnd = 1961.25 \nFrequency = 1 \n[1] 1 5 9\n\n\nExplication : lorsque l’on spécifie le paramètre frequency dans la fonction window(), on change la fréquence de la série. Dans notre cas, on veut extraire les valeurs du deuxième trimestre : on veut donc une série annuelle qui contient toutes les valeurs des deuxièmes trimestres. La première observation de ts_object étant un deuxième trimestre, cela donne ce que l’on veut. Pour extraire les valeurs des troisièmes trimestres il faut en plus changer la date de début :\n\nwindow(ts_object, start = c(1950, 3), frequency = 1)\n\nTime Series:\nStart = 1959.25 \nEnd = 1961.25 \nFrequency = 1 \n[1] 1 5 9\n\n\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nCréer une série temporelle mensuelle qui commence en 2000, qui se termine en janvier 2020, qui vaut 1 en avril 2009 et 0 à toutes les autres dates.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 1 : utiliser la fonction window()\n\nindicatrice &lt;- ts(0, start = 2000, end = 2020, frequency = 12)\nwindow(indicatrice, start = c(2009, 4), end = c(2009, 4)) &lt;- 1\nindicatrice\n\n     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n2000   0   0   0   0   0   0   0   0   0   0   0   0\n2001   0   0   0   0   0   0   0   0   0   0   0   0\n2002   0   0   0   0   0   0   0   0   0   0   0   0\n2003   0   0   0   0   0   0   0   0   0   0   0   0\n2004   0   0   0   0   0   0   0   0   0   0   0   0\n2005   0   0   0   0   0   0   0   0   0   0   0   0\n2006   0   0   0   0   0   0   0   0   0   0   0   0\n2007   0   0   0   0   0   0   0   0   0   0   0   0\n2008   0   0   0   0   0   0   0   0   0   0   0   0\n2009   0   0   0   1   0   0   0   0   0   0   0   0\n2010   0   0   0   0   0   0   0   0   0   0   0   0\n2011   0   0   0   0   0   0   0   0   0   0   0   0\n2012   0   0   0   0   0   0   0   0   0   0   0   0\n2013   0   0   0   0   0   0   0   0   0   0   0   0\n2014   0   0   0   0   0   0   0   0   0   0   0   0\n2015   0   0   0   0   0   0   0   0   0   0   0   0\n2016   0   0   0   0   0   0   0   0   0   0   0   0\n2017   0   0   0   0   0   0   0   0   0   0   0   0\n2018   0   0   0   0   0   0   0   0   0   0   0   0\n2019   0   0   0   0   0   0   0   0   0   0   0   0\n2020   0                                            \n\n\nOption 2 : utiliser time()\n\nindicatrice &lt;- ts(0, start = 2000, end = 2020, frequency = 12)\n# Donne un vecteur de booléens\n(time(indicatrice) == 2009 + 3/12) \n\n       Jan   Feb   Mar   Apr   May   Jun   Jul   Aug   Sep   Oct   Nov   Dec\n2000 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2001 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2002 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2003 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2004 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2005 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2006 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2007 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2008 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2009 FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2010 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2011 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2012 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2013 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2014 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2015 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2016 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2017 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2018 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2019 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2020 FALSE                                                                  \n\n# on ajoute + 0 pour forcer la convertion en numérique\n(time(indicatrice) == 2009 + 3/12) + 0\n\n     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n2000   0   0   0   0   0   0   0   0   0   0   0   0\n2001   0   0   0   0   0   0   0   0   0   0   0   0\n2002   0   0   0   0   0   0   0   0   0   0   0   0\n2003   0   0   0   0   0   0   0   0   0   0   0   0\n2004   0   0   0   0   0   0   0   0   0   0   0   0\n2005   0   0   0   0   0   0   0   0   0   0   0   0\n2006   0   0   0   0   0   0   0   0   0   0   0   0\n2007   0   0   0   0   0   0   0   0   0   0   0   0\n2008   0   0   0   0   0   0   0   0   0   0   0   0\n2009   0   0   0   1   0   0   0   0   0   0   0   0\n2010   0   0   0   0   0   0   0   0   0   0   0   0\n2011   0   0   0   0   0   0   0   0   0   0   0   0\n2012   0   0   0   0   0   0   0   0   0   0   0   0\n2013   0   0   0   0   0   0   0   0   0   0   0   0\n2014   0   0   0   0   0   0   0   0   0   0   0   0\n2015   0   0   0   0   0   0   0   0   0   0   0   0\n2016   0   0   0   0   0   0   0   0   0   0   0   0\n2017   0   0   0   0   0   0   0   0   0   0   0   0\n2018   0   0   0   0   0   0   0   0   0   0   0   0\n2019   0   0   0   0   0   0   0   0   0   0   0   0\n2020   0                                            \n\n\n\n\n\nPour tracer un graphique il suffit maintenant d’utiliser les fonctions plot() et lines()\n\nplot(ts_object * 2)\nlines(ts_object, col = \"red\")"
  },
  {
    "objectID": "TP/R_0_Manipulation_series_temporelles.html#séries-multivariées",
    "href": "TP/R_0_Manipulation_series_temporelles.html#séries-multivariées",
    "title": "0 - Traitement des séries temporelles sous ",
    "section": "1.2 Séries multivariées",
    "text": "1.2 Séries multivariées\nDe la même façon que précédemment on peut créer une série temporelle multivariée. Cette fois-ci l’objet créé est à la fois mts, ts et matrix\n\nset.seed(1)\n# On génère 300 observations d'une loi normale (0, 1)\nloi_normale &lt;- rnorm(300)\nmts &lt;- ts(matrix(loi_normale, nrow = 100, ncol = 3),\n          start = c(1961, 1), frequency = 12)\n\nOn peut accéder à la première variable de la même façon que dans une matrice : par son nom ou son numéro de colonne :\n\ncolnames(mts)\n\n[1] \"Series 1\" \"Series 2\" \"Series 3\"\n\n# mts[,1] # ou de façon équivalente :\nmts[, \"Series 1\"]\n\n              Jan          Feb          Mar          Apr          May\n1961 -0.626453811  0.183643324 -0.835628612  1.595280802  0.329507772\n1962 -0.621240581 -2.214699887  1.124930918 -0.044933609 -0.016190263\n1963  0.619825748 -0.056128740 -0.155795507 -1.470752384 -0.478150055\n1964 -0.394289954 -0.059313397  1.100025372  0.763175748 -0.164523596\n1965 -0.112346212  0.881107726  0.398105880 -0.612026393  0.341119691\n1966  2.401617761 -0.039240003  0.689739362  0.028002159 -0.743273209\n1967  0.610726353 -0.934097632 -1.253633400  0.291446236 -0.443291873\n1968  0.593946188  0.332950371  1.063099837 -0.304183924  0.370018810\n1969 -1.276592208 -0.573265414 -1.224612615 -0.473400636             \n              Jun          Jul          Aug          Sep          Oct\n1961 -0.820468384  0.487429052  0.738324705  0.575781352 -0.305388387\n1962  0.943836211  0.821221195  0.593901321  0.918977372  0.782136301\n1963  0.417941560  1.358679552 -0.102787727  0.387671612 -0.053805041\n1964 -0.253361680  0.696963375  0.556663199 -0.688755695 -0.707495157\n1965 -1.129363096  1.433023702  1.980399899 -0.367221476 -1.044134626\n1966  0.188792300 -1.804958629  1.465554862  0.153253338  2.172611670\n1967  0.001105352  0.074341324 -0.589520946 -0.568668733 -0.135178615\n1968  0.267098791 -0.542520031  1.207867806  1.160402616  0.700213650\n1969                                                                 \n              Nov          Dec\n1961  1.511781168  0.389843236\n1962  0.074564983 -1.989351696\n1963 -1.377059557 -0.414994563\n1964  0.364581962  0.768532925\n1965  0.569719627 -0.135054604\n1966  0.475509529 -0.709946431\n1967  1.178086997 -1.523566800\n1968  1.586833455  0.558486426\n1969                          \n\n\nEt avec les même fonctions que pour les matrices on peut récupérer les noms des colonnes (colnames), le nombre de variables (ncol), etc.\n\n\n\n\n\n\nAttention\n\n\n\nUne source classique d’erreur est de manipuler des séries-temporelles uni et multivariées et de vouloir utiliser les fonctions liées aux matrices sur les séries univariées. Par exemple, colnames(ts_object) renverra toujours l’objet NULL. Une solution est de tester si l’objet est multivarié avec la fonction is.mts()."
  },
  {
    "objectID": "TP/R_0_Manipulation_series_temporelles.html#manipulation-basiques",
    "href": "TP/R_0_Manipulation_series_temporelles.html#manipulation-basiques",
    "title": "0 - Traitement des séries temporelles sous ",
    "section": "1.3 Manipulation basiques",
    "text": "1.3 Manipulation basiques\nPour concaténer plusieurs séries temporelles, les fonctions deux fonctions suivantes peuvent ts.union() et ts.intersect().\n\nts_object2 &lt;- ts(1:10, frequency = 4, start = c(1960, 1))\nts.union(ts_object, ts_object2) # on garde toute la couverture temporelle en rajoutant des NA\n\n        ts_object ts_object2\n1959 Q2         1         NA\n1959 Q3         2         NA\n1959 Q4         3         NA\n1960 Q1         4          1\n1960 Q2         5          2\n1960 Q3         6          3\n1960 Q4         7          4\n1961 Q1         8          5\n1961 Q2         9          6\n1961 Q3        10          7\n1961 Q4        NA          8\n1962 Q1        NA          9\n1962 Q2        NA         10\n\nts.intersect(ts_object, ts_object2) # on ne garde que les périodes communes\n\n        ts_object ts_object2\n1960 Q1         4          1\n1960 Q2         5          2\n1960 Q3         6          3\n1960 Q4         7          4\n1961 Q1         8          5\n1961 Q2         9          6\n1961 Q3        10          7\n\n\nOn va maintenant utiliser la série d’indice de production industrielle de la France (CVS-CJO) :\n\nipi_fr_manuf &lt;- ts(c(99, 99.4, 99.7, 99.4, 100.8, 100, 98.7, 100.2, 101.2, \n100.6, 99.9, 100.9, 102.4, 100.8, 99.5, 100.7, 99.8, 99.1, 99.8, \n101.6, 100.4, 99.4, 102.8, 101, 100.2, 101.1, 102.6, 101.8, 103.7, \n103, 103.6, 103.5, 104.4, 105.6, 105.5, 105.9, 103.6, 102.9, \n103.8, 103.8, 102.5, 104.2, 104, 104.6, 103.4, 104.2, 103.4, \n103.7, 104.9, 105.8, 104.4, 104.3, 106, 103.7, 104.1, 103.1, \n103.9, 104.4), start = 2015, frequency = 12)\n\nPour calculer la série retardée/avancée, il suffit d’utiliser la fonction lag() :\n\n# série retardée d'un mois : en février 2010 on a la valeur de janvier 2010\nlag(ipi_fr_manuf, k = -1) \n\n       Jan   Feb   Mar   Apr   May   Jun   Jul   Aug   Sep   Oct   Nov   Dec\n2015        99.0  99.4  99.7  99.4 100.8 100.0  98.7 100.2 101.2 100.6  99.9\n2016 100.9 102.4 100.8  99.5 100.7  99.8  99.1  99.8 101.6 100.4  99.4 102.8\n2017 101.0 100.2 101.1 102.6 101.8 103.7 103.0 103.6 103.5 104.4 105.6 105.5\n2018 105.9 103.6 102.9 103.8 103.8 102.5 104.2 104.0 104.6 103.4 104.2 103.4\n2019 103.7 104.9 105.8 104.4 104.3 106.0 103.7 104.1 103.1 103.9 104.4      \n\n\nLa fonction diff permet de calculer la différence entre deux périodes :\n\ndiff(ipi_fr_manuf, lag = 1)\n\n      Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec\n2015       0.4  0.3 -0.3  1.4 -0.8 -1.3  1.5  1.0 -0.6 -0.7  1.0\n2016  1.5 -1.6 -1.3  1.2 -0.9 -0.7  0.7  1.8 -1.2 -1.0  3.4 -1.8\n2017 -0.8  0.9  1.5 -0.8  1.9 -0.7  0.6 -0.1  0.9  1.2 -0.1  0.4\n2018 -2.3 -0.7  0.9  0.0 -1.3  1.7 -0.2  0.6 -1.2  0.8 -0.8  0.3\n2019  1.2  0.9 -1.4 -0.1  1.7 -2.3  0.4 -1.0  0.8  0.5          \n\n\nEn revanche, le paramètre lag ne peut prendre que une valeur. La fonction rjd3toolkit::differences() permet d’effectuer plusieurs différences et a également un paramètre mean pour centrer la série. Par exemple, pour effectuer à la fois une différenciation régulière et saisonnière (d’ordre 12) :\n\nrjd3toolkit::differences(ipi_fr_manuf, lags = c(1, 12))\n\n             Jan         Feb         Mar         Apr         May         Jun\n2016             -1.92888889 -1.52888889  1.57111111 -2.22888889  0.17111111\n2017 -2.22888889  2.57111111  2.87111111 -1.92888889  2.87111111  0.07111111\n2018 -1.42888889 -1.52888889 -0.52888889  0.87111111 -3.12888889  2.47111111\n2019  3.57111111  1.67111111 -2.22888889 -0.02888889  3.07111111 -3.92888889\n             Jul         Aug         Sep         Oct         Nov         Dec\n2016  2.07111111  0.37111111 -2.12888889 -0.32888889  4.17111111 -2.72888889\n2017 -0.02888889 -1.82888889  2.17111111  2.27111111 -3.42888889  2.27111111\n2018 -0.72888889  0.77111111 -2.02888889 -0.32888889 -0.62888889 -0.02888889\n2019  0.67111111 -1.52888889  2.07111111 -0.22888889                        \n\n\n\n\n\n\n\n\nExercice\n\n\n\nÉcrire une fonction ev() qui calcule l’évolution mensuelle si la série en entrée est mensuelle, l’évolution trimestrielle si la série en entrée est trimestrielle, etc.\nLa fonction ev() transformera donc toute série \\(X_t\\) en : \\[\nY_t=\\frac{X_t-X_{t-1}}{\nX_{t-1}\n}=\\frac{X_t}{\nX_{t-1}\n} - 1.\n\\]\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nev &lt;- function(x){\n  result &lt;- (x/stats::lag(x, k = -1) - 1) * 100\n  return(result)\n}\n# Ou de manière équivalente :\nev2 &lt;- function(x){\n  # Attention ici c'est bien k = 1 dans la fonction diff\n  # et k = -1 dans la fonction lag\n  result &lt;- (diff(x, lag = 1) /lag(x, k = -1)) * 100\n  return(result)\n}\n\nRemarque : pour des raisons informatiques ces deux fonctions ne donnent pas exactement le même résultat. C’est un problème récurrent lorsque l’on souhaite tester l’égalité entre deux séries temporelles :\n\nall(ev(ipi_fr_manuf) == ev2(ipi_fr_manuf))\n\n[1] FALSE\n\n\nUne solution est plutôt d’utiliser la fonction all.equal() :\n\nisTRUE(all.equal(ev(ipi_fr_manuf), ev2(ipi_fr_manuf)))\n\n[1] TRUE"
  },
  {
    "objectID": "TP/R_0_Manipulation_series_temporelles.html#utilisation-de-xts",
    "href": "TP/R_0_Manipulation_series_temporelles.html#utilisation-de-xts",
    "title": "0 - Traitement des séries temporelles sous ",
    "section": "2.1 Utilisation de xts",
    "text": "2.1 Utilisation de xts\nUn des avantages du package xts est qu’il permet d’appliquer une fonction à chaque période d’une série temporelle (par exemple à toutes les données trimestrielles, annuelles, etc.). Il s’agit des fonctions apply.monthly(), apply.quarterly(), apply.yearly(), etc. Pour cela il faut auparavant convertir les données au format xts.\nPar exemple pour calculer la moyenne annuelle :\n\nlibrary(xts)\nmoy_an &lt;- apply.yearly(as.xts(ipi_fr_manuf), mean)\nmoy_an\n\n              [,1]\nDec 2015  99.98333\nDec 2016 100.60833\nDec 2017 103.40833\nDec 2018 103.67500\nOct 2019 104.46000\n\n\n\n\n\n\n\n\nExercice\n\n\n\nCalculer l’évolution trimestrielle de ipi_fr_manuf.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nTout d’abord on prolonge l’IPI par des valeurs manquantes jusqu’à la fin de l’année, sinon la dernière somme sur le trimestre est fausse.\n\nipi_fr_manuf_prolonge &lt;- window(ipi_fr_manuf, end = c(2019, 12), extend = TRUE)\nsomme_trim &lt;- apply.quarterly(as.xts(ipi_fr_manuf_prolonge), sum)\n\nAttention la fonction lag n’agit pas pareil pour les objets xts et ts : il faut ici utiliser l’option k = 1. Voir l’aide associée à ?lag.xts. Pour garder la même convention entre lag.ts() et lag.xts() on peut utiliser l’option options(xts.compat.zoo.lag=TRUE).\n\nevol_trim &lt;- (somme_trim/lag(somme_trim, k = 1) - 1) * 100\n\nOn peut utiliser la fonction format() si l’on veut convertir automatiquement en un objet ts :\n\nstart_year &lt;- as.numeric(format(start(evol_trim), \"%Y\"))\nstart_quarter &lt;- as.numeric(substr(quarters(start(evol_trim)), 2, 2))\nts(evol_trim, start = c(start_year, start_quarter), frequency = 4)\n\n            Qtr1        Qtr2        Qtr3        Qtr4\n2015          NA  0.70446159 -0.03331113  0.43318894\n2016  0.43132050 -1.02411629  0.73431242  0.46388337\n2017  0.23087071  1.51365581  0.97244733  1.76565008\n2018 -2.11356467  0.06445375  0.48309179 -0.22435897\n2019  1.22068744 -0.34909553 -0.92356688          NA\n\n\nOn peut aussi directement utiliser le package ts_box et la fonction ts_ts() :\n\ntsbox::ts_ts(evol_trim)\n\n            Qtr1        Qtr2        Qtr3        Qtr4\n2015                      NA  0.70446159 -0.03331113\n2016  0.43318894  0.43132050 -1.02411629  0.73431242\n2017  0.46388337  0.23087071  1.51365581  0.97244733\n2018  1.76565008 -2.11356467  0.06445375  0.48309179\n2019 -0.22435897  1.22068744 -0.34909553 -0.92356688\n2020          NA                                    \n\n\n\n\n\nOn aurait en fait pu le faire directement avec les fonctions de base R ! Par contre la situation aurait été plus compliquée avec des données haute fréquence (du type journalières) non correctement gérées par ts :\n\nstats::aggregate.ts(ipi_fr_manuf, nfrequency = 4,\n          FUN = mean)\n\n          Qtr1      Qtr2      Qtr3      Qtr4\n2015  99.36667 100.06667 100.03333 100.46667\n2016 100.90000  99.86667 100.60000 101.06667\n2017 101.30000 102.83333 103.83333 105.66667\n2018 103.43333 103.50000 104.00000 103.76667\n2019 105.03333 104.66667 103.70000          \n\n\nCette fonction fait ici une somme sur 4 périodes consécutives mais ne reconnait pas les différents mois des trimestres :\n\nstats::aggregate.ts(window(ipi_fr_manuf, start = c(2015,2)), nfrequency = 4,\n          FUN = mean)\n\nTime Series:\nStart = 2015.08333333333 \nEnd = 2019.58333333333 \nFrequency = 4 \n [1]  99.50000  99.83333 100.66667 101.06667 100.33333  99.56667 100.46667\n [8] 101.33333 101.83333 103.43333 104.50000 105.00000 103.50000 103.56667\n[15] 104.06667 104.00000 104.83333 104.60000 103.80000\n\n\nUne autre possibilité est d’utiliser la fonction rjd3toolkit::aggregate() (mais dont les fonctions d’agrégation sont limitées) :\n\nrjd3toolkit::aggregate(window(ipi_fr_manuf, start = c(2015,2)),\n                       nfreq = 4)\n\n      Qtr1  Qtr2  Qtr3  Qtr4\n2015       300.2 300.1 301.4\n2016 302.7 299.6 301.8 303.2\n2017 303.9 308.5 311.5 317.0\n2018 310.3 310.5 312.0 311.3\n2019 315.1 314.0 311.1"
  },
  {
    "objectID": "TP/R_0_Manipulation_series_temporelles.html#utilisation-de-zoo",
    "href": "TP/R_0_Manipulation_series_temporelles.html#utilisation-de-zoo",
    "title": "0 - Traitement des séries temporelles sous ",
    "section": "2.2 Utilisation de zoo",
    "text": "2.2 Utilisation de zoo\nLe package zoo donne un ensemble d’outils qui permettent de manipuler les séries-temporelles. De nombreux packages (dont xts) sont d’ailleurs basés sur ce format. Il permet notamment de faire des imputations de données manquantes selon différentes fonctions (toutes les fonctions commençant par na.) et de mieux gérer le format des dates associées aux séries temporelles (ce qui permet de faire des manipulations avec la fonction format, ce qui permet par exemple plus facilement exporter des séries temporelles sous Excel). Le calcul de l’évolution trimestrielle aurait par exemple pu être faite avec ce package :\n\nsomme_trim &lt;- aggregate(as.zoo(ipi_fr_manuf_prolonge), yearqtr, sum)\nsomme_trim &lt;- as.ts(somme_trim) #La conversion en ts est plus simple depuis un objet zoo\nevol_trim &lt;- ev(somme_trim)\nevol_trim\n\n            Qtr1        Qtr2        Qtr3        Qtr4\n2015              0.70446159 -0.03331113  0.43318894\n2016  0.43132050 -1.02411629  0.73431242  0.46388337\n2017  0.23087071  1.51365581  0.97244733  1.76565008\n2018 -2.11356467  0.06445375  0.48309179 -0.22435897\n2019  1.22068744 -0.34909553 -0.92356688          NA\n\n\nPour le prochain exercice, utiliser la série suivante :\n\nserie_avec_NA &lt;- ts(c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0, 0, 0, 0, \n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NA, \n  NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, \n  NA, NA, NA, NA, NA, NA, NA, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, NA, NA, NA, NA, NA, NA, \n  NA, NA, NA, NA, NA, NA), start = 2000, frequency = 12)\n\n\n\n\n\n\n\nExercice\n\n\n\nSur la série serie_avec_NA, utiliser les différentes fonctions du package zoo pour :\n\nEnlever les valeurs manquantes au début de la série ;\n\nRemplacer les valeurs manquantes à la fin de la série par la dernière valeur observée.\n\nInterpoler de manière linéaire les valeurs manquantes entre les 0 et les 1.\n\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nLes trois fonctions à utiliser sont : na.trim(), na.locf() et na.approx(). Il faudra peut-être inverser deux étapes pour que cela marche.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nD’abord on enlève les valeurs manquantes au début de la série\n\netape_1 &lt;- na.trim(serie_avec_NA, sides = \"left\")\netape_1\n\n     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n2001   0   0   0   0   0   0   0   0   0   0   0   0\n2002   0   0   0   0   0   0   0   0   0   0   0   0\n2003  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA\n2004  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA\n2005   1   1   1   1   1   1   1   1   1   1   1   1\n2006   1   1   1   1   1   1   1   1   1   1   1   1\n2007  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA\n\n\nEnsuite on interpole\n\netape_2 &lt;- na.approx(etape_1, na.rm = FALSE)\netape_2\n\n      Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec\n2001 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n2002 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n2003 0.04 0.08 0.12 0.16 0.20 0.24 0.28 0.32 0.36 0.40 0.44 0.48\n2004 0.52 0.56 0.60 0.64 0.68 0.72 0.76 0.80 0.84 0.88 0.92 0.96\n2005 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00\n2006 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00\n2007   NA   NA   NA   NA   NA   NA   NA   NA   NA   NA   NA   NA\n\n\nEnfin on remplace les valeurs à la fin de la série\n\netape_3 &lt;- na.locf(etape_2)\netape_3\n\n      Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec\n2001 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n2002 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n2003 0.04 0.08 0.12 0.16 0.20 0.24 0.28 0.32 0.36 0.40 0.44 0.48\n2004 0.52 0.56 0.60 0.64 0.68 0.72 0.76 0.80 0.84 0.88 0.92 0.96\n2005 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00\n2006 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00\n2007 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00\n\n\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nÀ l’aide des fonctions as.yearmon() et format(), créer un data.frame contenant une colonne “date” qui contient les dates au format JJ/MM/YYYY et une deuxième colonnes avec les valeurs de ipi_fr_manuf.\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nLa fonction as.yearmon() doit être appliquée sur time(ipi_fr_manuf). Pour la fonction format regarder l’aide ?format.Date.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ndates &lt;- as.yearmon(time(ipi_fr_manuf))\ndates &lt;- format(dates, \"%d/%m/%Y\")\ndonnees_formatees &lt;- data.frame(date = dates, ipi = ipi_fr_manuf)\nhead(donnees_formatees)\n\n        date   ipi\n1 01/01/2015  99.0\n2 01/02/2015  99.4\n3 01/03/2015  99.7\n4 01/04/2015  99.4\n5 01/05/2015 100.8\n6 01/06/2015 100.0\n\n\n\n\n\nIl peut également être utile d’exporter un objet R ts ou mts vers un fichier Excel, tout en rajoutant une colonne “date” qui sera au format date. Ci-dessous un exemple en utilisant le package XLConnect :\n\nlibrary(XLConnect)\nts2xls &lt;- function(x, file, sheet=\"Feuille 1\", format = \"dd/mm/yyyy\"){\n  wb &lt;- loadWorkbook(file, create = TRUE)\n  createSheet(wb, sheet)\n  if(is.mts(x)){\n    col &lt;- c(\"date\", colnames(x))\n  }else{\n    col &lt;- c(\"date\", \"x\")\n  }\n  # Le titre\n  writeWorksheet(wb,matrix(col,nrow = 1),\n                 sheet = sheet,startCol = 1,startRow =1,\n                 header = FALSE)\n\n  # Petit trick pour que la colonne date soit au format date d'Excel\n  csDate &lt;- getOrCreateCellStyle(wb, name = \"date\")\n  setDataFormat(csDate, format = format)\n  date &lt;- as.Date(format(zoo::as.Date((time(x))), \"%d/%m/%Y\"),\n                  \"%d/%m/%Y\")\n  writeWorksheet(wb,date,sheet = sheet,\n                 startCol = 1,startRow = 2,\n                 header = FALSE)\n  setCellStyle(wb, sheet = sheet, row = seq_along(date)+1,\n               col = 1,\n               cellstyle = csDate)\n  # Fin colonne date\n\n  # Autres colonnes\n  writeWorksheet(wb,x,sheet = sheet,startCol = 2,startRow = 2,\n                 header = FALSE)\n  setColumnWidth(wb, sheet, column = seq_along(col), width = -1)\n  saveWorkbook(wb, file)\n}"
  },
  {
    "objectID": "TP/JD_6_X11.html",
    "href": "TP/JD_6_X11.html",
    "title": "6 - X11",
    "section": "",
    "text": "L’objectif de ce TP est d’analyser la décomposition et de changer la spécification si nécessaire"
  },
  {
    "objectID": "TP/JD_6_X11.html#filtre-saisonnier",
    "href": "TP/JD_6_X11.html#filtre-saisonnier",
    "title": "6 - X11",
    "section": "2.1 Filtre saisonnier",
    "text": "2.1 Filtre saisonnier\n\nEssayer de changer le filtre saisonnier dans X11 &gt; Seasonal filter :\n\nLorsque vous prenez un filtre plus long ou plus court, qu’observez vous sur les M statistics, S-I ratios, la saisonnalité et la série désaisonnalisée ?\nEn quoi cela affecte les autres diagnostics (en particulier la saisonnalité résiduelle) ?"
  },
  {
    "objectID": "TP/JD_6_X11.html#filtre-de-henderson",
    "href": "TP/JD_6_X11.html#filtre-de-henderson",
    "title": "6 - X11",
    "section": "2.2 Filtre de Henderson",
    "text": "2.2 Filtre de Henderson\n\nEssayer de changer le filtre de Henderson dans X11 &gt; Henderson filter :\n\nLorsque vous prenez un filtre plus long ou plus court, qu’observez vous sur les M statistics, S-I ratios, la saisonnalité et la série désaisonnalisée ?\nEn quoi cela affecte les autres diagnostics ?"
  },
  {
    "objectID": "TP/JD_6_X11.html#lsigma-and-usigma",
    "href": "TP/JD_6_X11.html#lsigma-and-usigma",
    "title": "6 - X11",
    "section": "2.3 Lsigma and Usigma",
    "text": "2.3 Lsigma and Usigma\n\nEssayer de changer les paramètres Lsigma et Usigma :\n\nQu’observez-vous sur les statistiques M ?\nEn quoi cela affecte les autres diagnostics ?"
  },
  {
    "objectID": "TP/JD_6_X11.html#calendar-sigma",
    "href": "TP/JD_6_X11.html#calendar-sigma",
    "title": "6 - X11",
    "section": "2.4 Calendar sigma",
    "text": "2.4 Calendar sigma\n\nAller dans la fenêtre Decomposition (X11) &gt; Quality measures &gt; Details et descendre jusqu’au test de Cochran :\n\nEst-ce que le test est rejeté ? Si oui qu’est-ce que cela implique ? Regarder les S-I ratios : est-ce que vous êtes d’accord avec ce test ?\nChanger le paramètre calendarsigma à “Signif” : en quoi les différents diagnostics sont impactés ?"
  },
  {
    "objectID": "TP/JD_4_CVS_CJO.html",
    "href": "TP/JD_4_CVS_CJO.html",
    "title": "4 - Désaisonnalisation avec correction des jours ouvrables",
    "section": "",
    "text": "Dans JDemetra+ 2.x.y, si l’on crée soit-même un calendrier seul deux types de régresseurs sont possibles (trading days et working days) : il est donc vite utile de créer soit même des régresseurs de calendrier et de les importer dans JDemetra+ (section 2). Dans JDemetra+ 3.x.y, il est possible d’utiliser bien plus de régresseurs de calendrier à partir d’un calendrier personnalisé. Dans la majorité des cas il n’est donc plus utile d’exporter les régresseurs et ce calendrier peut directeur être utilisé (section 1) : c’est la solution que nous privilégierons."
  },
  {
    "objectID": "TP/JD_4_CVS_CJO.html#création-du-calendrier-depuis-jdemetra",
    "href": "TP/JD_4_CVS_CJO.html#création-du-calendrier-depuis-jdemetra",
    "title": "4 - Désaisonnalisation avec correction des jours ouvrables",
    "section": "1.1 Création du calendrier depuis JDemetra+",
    "text": "1.1 Création du calendrier depuis JDemetra+\n\nDans l’onglet Workspace, cliquer droit sur Utilities &gt; Calendars puis Add Calendar &gt; National\nDonner un nom au calendrier (par exemple CAL)\nAjouter des jours en cliquant sur le + :\n\nFixed pour ajouter un jour férié qui tombe à date fixe (par exemple 8 mai)\nEaster Related pour ajouter un jour férié dont le jour dépend de Pâques (le dimanche) : le paramètre offset permet de spécifier le nombre de jours avant (si négatif) ou après Pâques (si positif).\nFixed week qui permet d’ajouter des jours fériés qui apparaissent certaines semaines de certains mois (par exemple le premier lundi du mois de septembre aux USA)\nSingle Date pour ajouter un jour ferié qui n’a eu lieu qu’une seule fois (i.e. une année seulement).\nSpecial Day qui permet d’ajouter des jours fériés par rapport à des dates déjà connues dans JDemetra+ (voir tableau ci-dessous). Comme pour la fonction easter_day(), le paramètre offset permet de spécifier la position du jour voulu par rapport rapport à la fête pré-spécifié (par défaut offset = 0, le jour férié coïncide avec le jour pré-spécifié).\n\n\n\n\n\n\nJours pré-spécifiés (`Special Day`)\n\n\nEvent\nDéfinition\n\n\n\n\nNEWYEAR\nFête fixe, 1er janvier.\n\n\nSHROVEMONDAY\nFête mobile, lundi avant le mecredi des cendres (48 jours avant pâques).\n\n\nSHROVETUESDAY\nFête mobile, mardi avant le mecredi des cendres (47 jours avant pâques).\n\n\nASHWEDNESDAY\nFête mobile, 46 jours avant Pâques.\n\n\nEASTER\nFête mobile, Pâques, varie entre le 22 mars et le 25 avril.\n\n\nMAUNDYTHURSDAY\nFête mobile, le jeudi avant Pâques.\n\n\nGOODFRIDAY\nFête mobile, le vendredi avant Pâques.\n\n\nEASTERMONDAY\nFête mobile, le lendemain de Pâques.\n\n\nASCENSION\nFête mobile, célébrée un jeudi, 40 jours après Pâques.\n\n\nPENTECOST\nFête mobile, 50 jours après Pâques.\n\n\nCORPUSCHRISTI\nFête mobile, 60 jours après Pâques.\n\n\nWHITMONDAY\nFête mobile, le jour après la Pentecôte.\n\n\nMAYDAY\nFête fixe, 1er mai.\n\n\nASSUMPTION\nFête fixe, 15 août.\n\n\nHALLOWEEN\nFête fixe, 31 octobre.\n\n\nALLSAINTSDAY\nFête fixe, 1er novembre.\n\n\nARMISTICE\nFête fixe, 11 novembre.\n\n\nCHRISTMAS\nFête fixe, 25 décembre."
  },
  {
    "objectID": "TP/JD_4_CVS_CJO.html#création-du-calendrier-depuis-r-v3.x.y",
    "href": "TP/JD_4_CVS_CJO.html#création-du-calendrier-depuis-r-v3.x.y",
    "title": "4 - Désaisonnalisation avec correction des jours ouvrables",
    "section": "1.2 Création du calendrier depuis R (v3.x.y)",
    "text": "1.2 Création du calendrier depuis R (v3.x.y)\n\n\n\n\n\n\nExemple de calendrier associé à la France\n\n\n\n\n\n\nif (! \"rjd3toolkit\" %in% installed.packages()[,\"Package\"]) {\n  install.packages(\"rjd3toolkit\", repos = c(\"https://aqlt.r-universe.dev\", \"https://cloud.r-project.org\"))\n}\nif (! \"rjd3workspace\" %in% installed.packages()[,\"Package\"]) {\n  install.packages(\"rjd3workspace\", repos = c(\"https://aqlt.r-universe.dev\", \"https://cloud.r-project.org\"))\n}\nlibrary(rjd3toolkit)\n# Exemple de calendrier associé à la France\nFR &lt;- national_calendar(list(\n    special_day(\"NEWYEAR\"),\n    special_day(\"EASTERMONDAY\"), # Lundi de Pâques\n    special_day(\"MAYDAY\"), # 1er mai\n    special_day(\"ASCENSION\"), # Jour de l'Ascension\n    fixed_day(5, 8),\n    special_day(\"WHITMONDAY\"), # Lundi de Pentecôte\n    fixed_day(7, 14),\n    special_day(\"ASSUMPTION\"), # Assomption\n    special_day(\"ALLSAINTSDAY\"), # Toussaint\n    special_day(\"ARMISTICE\")\n))\nCAL &lt;- national_calendar(FR)\n\n\n\n\n\n\n\n\n\n\nExemple de calendrier associé à la Macronia\n\n\n\n\n\nIci certains jours fériés sont associés à des fêtes mobiles qui sont inscrites dans un fichier Excel\n\nif (! \"rjd3toolkit\" %in% installed.packages()[,\"Package\"]) {\n  install.packages(\"rjd3toolkit\", repos = c(\"https://aqlt.r-universe.dev\", \"https://cloud.r-project.org\"))\n}\nlibrary(rjd3toolkit)\njours_macronia &lt;- list(\n  special_day(\"NEWYEAR\"),\n    special_day(\"EASTERMONDAY\"), # Lundi de Pâques\n  fixed_day(4, 4), # Jour de l'indépendance de la Macronia\n  special_day(\"MAYDAY\"), # 1er mai\n  special_day(\"ASCENSION\"), # Jour de l'Ascension\n    special_day(\"WHITMONDAY\"), # Lundi de Pentecôte\n  special_day(\"ASSUMPTION\"), # Assomption de Marie\n    special_day(\"ALLSAINTSDAY\"), # Toussaint\n  special_day(\"CHRISTMAS\") # Noël\n)\njours_macronia &lt;- c(\n  jours_macronia,\n  list(\n    # DEBUT_RAMADAN,\nsingle_day(\"2000-11-28\"),\nsingle_day(\"2001-11-17\"),\nsingle_day(\"2002-11-07\"),\nsingle_day(\"2003-10-27\"),\nsingle_day(\"2004-10-15\"),\nsingle_day(\"2005-10-05\"),\nsingle_day(\"2006-09-24\"),\nsingle_day(\"2007-09-14\"),\nsingle_day(\"2008-09-02\"),\nsingle_day(\"2009-08-22\"),\nsingle_day(\"2010-08-12\"),\nsingle_day(\"2011-08-01\"),\nsingle_day(\"2012-07-20\"),\nsingle_day(\"2013-07-10\"),\nsingle_day(\"2014-06-29\"),\nsingle_day(\"2015-07-18\"),\nsingle_day(\"2016-06-07\"),\nsingle_day(\"2017-05-27\"),\nsingle_day(\"2018-05-17\"),\nsingle_day(\"2019-05-06\"),\nsingle_day(\"2020-04-24\"),\nsingle_day(\"2021-04-14\"),\nsingle_day(\"2022-04-03\"),\nsingle_day(\"2023-03-23\"),\nsingle_day(\"2024-03-12\")\n  ))\nCAL &lt;- national_calendar(jours_macronia)\n\n\n\n\nUne fois le calendrier défini, un workspace peut être créé de la façon suivante :\n\n# On va créer deux groupes de variables, on peut donc simplifier les noms\nctxt &lt;- rjd3toolkit::modelling_context(\n    # on appelle \"CAL\" le calendrier\n    calendars = list(CAL = CAL)\n) \n\njws &lt;- rjd3workspace::jws_new(ctxt)\nrjd3workspace::save_workspace(jws, \"wk_CJO_v3.xml\")\n# # Si le workspace existe déjà on peut utiliser le code suivant :\n# jws &lt;- rjd3workspace::.jws_open(\"chemin_vers_workspace\")\n# rjd3workspace::add_calendar(jws, \"CAL\", CAL)\n# rjd3workspace::save_workspace(jws, \"chemin_vers_nouveau_workspace\")"
  },
  {
    "objectID": "TP/JD_4_CVS_CJO.html#créer-une-spécification-incluant-le-calendrier-personnalisé",
    "href": "TP/JD_4_CVS_CJO.html#créer-une-spécification-incluant-le-calendrier-personnalisé",
    "title": "4 - Désaisonnalisation avec correction des jours ouvrables",
    "section": "1.3 Créer une spécification incluant le calendrier personnalisé",
    "text": "1.3 Créer une spécification incluant le calendrier personnalisé\n\nCliquer sur l’onglet Workspace.\nDouble cliquer sur Seasonal adjustment.\nDouble cliquer sur specifications.\nDouble cliquer sur x13.\nClic-droit sur RSA5c (ou RSA5 dans la version 3.x.y).\nCliquer sur Clone.\nQue se passe-t-il ?\nDouble-cliquer sur X13Spec-1.\nCliquer sur le + à côté de Calendar.\nCliquer sur le + à côté de tradingDays.\nCliquer sur Default à côté de option (ligne 1) et choisir l’option Holidays.\nCliquer sur Default à côté de holidays (ligne 3) et choisir votre calendrier\n\nPar défaut l’option trading days (TD7) les autres options possibles dans JDemetra+ 3.x.y sont :\n\n\n\n\n\n\n\n\n\n\n\nModèle\nDéfinition\nRéférence (contraste)\nNombre de régresseurs\n\n\n\n\nTD7\n(Lundi), (Mardi), \\(\\dots\\), (Samedi)\nDimanche\n6 + LPY\n\n\nTD4\n(Lundi = \\(\\dots\\) = Jeudi), (Vendredi), (Samedi)\nDimanche\n3 + LPY\n\n\nTD3\n(Lundi = \\(\\dots\\) = Vendredi), (Samedi)\nDimanche\n2 + LPY\n\n\nTD3c\n(Lundi = \\(\\dots\\) = Jeudi), (Vendredi = Samedi)\nDimanche\n2 + LPY\n\n\nTD2c\n(Lundi = \\(\\dots\\) = Samedi)\nDimanche\n1 + LPY\n\n\nTD2\n(Lundi = \\(\\dots\\) = Vendredi)\nSamedi + Dimanche\n1+LPY\n\n\n\n\n\nMême si un raisonnement économique est à privilégier pour le choix des régresseurs, une sélection automatique peut être faite par JDemetra+ (option automatic, ligne 2) en utilisant des tests de Wald ou en minimisant un critère d’information (BIC ou AIC).\n\n\n\n\n\n\nExporter son calendrier dans un autre workspace\n\n\n\nSi vous souhaitez exporter votre calendrier (sans utiliser R), il est possible de créer un fichier config depuis l’interface qui peut ensuite être importé :\n\nDans l’onglet Workspace &gt; Utilities &gt; Calendars, clic-droit sur le calendrier souhaité puis Export to &gt; File... celui crée un fichier .cfgx.\nSi vous créer un nouveau workspace, cet objet est importable dans JDemetra+ via l’onglet Workspace &gt; Utilities &gt; Calendars, clic-droit sur Calendars puis Import from &gt; File... et en sélectionnant le fichier .cfgx précédemment créé."
  },
  {
    "objectID": "TP/JD_4_CVS_CJO.html#importer-des-régresseurs-manuellement",
    "href": "TP/JD_4_CVS_CJO.html#importer-des-régresseurs-manuellement",
    "title": "4 - Désaisonnalisation avec correction des jours ouvrables",
    "section": "2.1 Importer des régresseurs manuellement",
    "text": "2.1 Importer des régresseurs manuellement\n\nCliquer sur l’onglet Providers.\nClic-droit sur Spreadsheets.\nCliquer sur Open.\nCliquer sur le bouton ….\nSélectionner le fichier Excel « reg_cjo_macronia.xlsx » contenant les régresseurs « Jours Ouvrables » de la Macronia.\nCliquer sur OK.\nCliquer sur l’onglet Workspace.\nCliquer sur le + à côté d’Utilities.\nClic-droit sur Variables.\nCliquer sur New.\nCliquer sur le + à côté de Variables.\nDouble cliquer sur l’icône Vars-1.\nQue se passe-t-il ?\nRetourner dans l’onglet Providers.\nFaire glisser l’ensemble des séries du fichier « regcjo.xls » dans l’onglet Vars-1.\nRenommer les séries en reprenant leur nom d’origine dans le fichier excel « regcjo.xls ».\n\nCe travail peut être très fastidieux… Heureusement depuis R il existe une solution plus automatique !"
  },
  {
    "objectID": "TP/JD_4_CVS_CJO.html#importer-des-régresseurs-grâce-à-r",
    "href": "TP/JD_4_CVS_CJO.html#importer-des-régresseurs-grâce-à-r",
    "title": "4 - Désaisonnalisation avec correction des jours ouvrables",
    "section": "2.2 Importer des régresseurs grâce à R",
    "text": "2.2 Importer des régresseurs grâce à R\nIl existe deux façons de faire, en fonction de si l’on utilise une version 2.x.y ou 3.x.y de JDemetra+. Repartons déjà des régresseurs jours ouvrables (pour leur création, voir le TP R associé en V2 ou V3) :\n\n\n\n\n\n\nExemple de calendrier associé à la France\n\n\n\n\n\n\nif (! \"rjd3toolkit\" %in% installed.packages()[,\"Package\"]) {\n  install.packages(\"rjd3toolkit\", repos = c(\"https://aqlt.r-universe.dev\", \"https://cloud.r-project.org\"))\n}\nif (! \"rjd3workspace\" %in% installed.packages()[,\"Package\"]) {\n  install.packages(\"rjd3workspace\", repos = c(\"https://aqlt.r-universe.dev\", \"https://cloud.r-project.org\"))\n}\nlibrary(rjd3toolkit)\n# Exemple de calendrier associé à la France\nFR &lt;- national_calendar(list(\n    special_day(\"NEWYEAR\"),\n    special_day(\"EASTERMONDAY\"), # Lundi de Pâques\n    special_day(\"MAYDAY\"), # 1er mai\n    special_day(\"ASCENSION\"), # Jour de l'Ascension\n    fixed_day(5, 8),\n    special_day(\"WHITMONDAY\"), # Lundi de Pentecôte\n    fixed_day(7, 14),\n    special_day(\"ASSUMPTION\"), # Assomption\n    special_day(\"ALLSAINTSDAY\"), # Toussaint\n    special_day(\"ARMISTICE\")\n))\nCAL &lt;- national_calendar(FR)\n\ngen_calendrier &lt;- function(cal, frequency, start = c(1990, 1), end = c(2030, 1)) {\n    length = (end[1] - start[1]) * frequency + end[2] - start[2]\n    ly &lt;- rjd3toolkit::lp_variable(frequency = frequency, start = start,\n                                   length = length)\n    # N'hésitez pas à ajouter les votre !\n    TD7 &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                       groups = c(1, 2, 3, 4, 5, 6, 0))\n    TD4 &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                       groups = c(1, 1, 1, 1, 2, 3, 0))\n    TD3 &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                       groups = c(1, 1, 1, 1, 1, 2, 0))\n    TD3c &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                        groups = c(1, 1, 1, 1, 2, 2, 0))\n    TD2 &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                       groups = c(1, 1, 1, 1, 1, 0, 0))\n    TD2c &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                        groups = c(1, 1, 1, 1, 1, 1, 0))\n    \n    reg_jo &lt;- ts(cbind(TD2, TD2c, TD3, TD3c, TD4, TD7),\n                 start = start, frequency = frequency)\n    reg_jo &lt;- ts.intersect(reg_jo,\n                           ly)\n    colnames(reg_jo) &lt;- c(\n        \"TD2_semaine\",\n        \"TD2c_lundi_samedi\",\n        sprintf(\"TD3_%s\", c(\"semaine\", \"samedi\")),\n        sprintf(\"TD3c_%s\", c(\"lundi_jeudi\", \"vendredi_samedi\")),\n        sprintf(\"TD4_%s\", c(\"lundi_jeudi\", \"vendredi\", \"samedi\")),\n        sprintf(\"TD7_%s\", c(\"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\")),\n        \"leap_year\")\n    reg_jo\n}\nregresseurs_JO_trim &lt;- gen_calendrier(CAL, frequency = 4)\nregresseurs_JO_mens &lt;- gen_calendrier(CAL, frequency = 12)\n\ncolnames(regresseurs_JO_trim) &lt;- paste0(colnames(regresseurs_JO_trim), \"_trim\")\ncolnames(regresseurs_JO_mens) &lt;- paste0(colnames(regresseurs_JO_mens), \"_mens\")\n\n\n\n\n\n\n\n\n\n\nExemple de calendrier associé à la Macronia\n\n\n\n\n\nIci certains jours fériés sont associés à des fêtes mobiles qui sont inscrites dans un fichier Excel\n\nif (! \"rjd3toolkit\" %in% installed.packages()[,\"Package\"]) {\n  install.packages(\"rjd3toolkit\", repos = c(\"https://aqlt.r-universe.dev\", \"https://cloud.r-project.org\"))\n}\nlibrary(rjd3toolkit)\njours_macronia &lt;- list(\n  special_day(\"NEWYEAR\"),\n    special_day(\"EASTERMONDAY\"), # Lundi de Pâques\n  fixed_day(4, 4), # Jour de l'indépendance de la Macronia\n  special_day(\"MAYDAY\"), # 1er mai\n  special_day(\"ASCENSION\"), # Jour de l'Ascension\n    special_day(\"WHITMONDAY\"), # Lundi de Pentecôte\n  special_day(\"ASSUMPTION\"), # Assomption de Marie\n    special_day(\"ALLSAINTSDAY\"), # Toussaint\n  special_day(\"CHRISTMAS\") # Noël\n)\njours_macronia &lt;- c(\n  jours_macronia,\n  list(\n    # DEBUT_RAMADAN,\nsingle_day(\"2000-11-28\"),\nsingle_day(\"2001-11-17\"),\nsingle_day(\"2002-11-07\"),\nsingle_day(\"2003-10-27\"),\nsingle_day(\"2004-10-15\"),\nsingle_day(\"2005-10-05\"),\nsingle_day(\"2006-09-24\"),\nsingle_day(\"2007-09-14\"),\nsingle_day(\"2008-09-02\"),\nsingle_day(\"2009-08-22\"),\nsingle_day(\"2010-08-12\"),\nsingle_day(\"2011-08-01\"),\nsingle_day(\"2012-07-20\"),\nsingle_day(\"2013-07-10\"),\nsingle_day(\"2014-06-29\"),\nsingle_day(\"2015-07-18\"),\nsingle_day(\"2016-06-07\"),\nsingle_day(\"2017-05-27\"),\nsingle_day(\"2018-05-17\"),\nsingle_day(\"2019-05-06\"),\nsingle_day(\"2020-04-24\"),\nsingle_day(\"2021-04-14\"),\nsingle_day(\"2022-04-03\"),\nsingle_day(\"2023-03-23\"),\nsingle_day(\"2024-03-12\")\n  ))\nCAL &lt;- national_calendar(jours_macronia)\n\ngen_calendrier &lt;- function(cal, frequency, start = c(1990, 1), end = c(2030, 1)) {\n    length = (end[1] - start[1]) * frequency + end[2] - start[2]\n    ly &lt;- rjd3toolkit::lp_variable(frequency = frequency, start = start,\n                                   length = length)\n    # N'hésitez pas à ajouter les votre !\n    TD7 &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                       groups = c(1, 2, 3, 4, 5, 6, 0))\n    TD4 &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                       groups = c(1, 1, 1, 1, 2, 3, 0))\n    TD3 &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                       groups = c(1, 1, 1, 1, 1, 2, 0))\n    TD3c &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                        groups = c(1, 1, 1, 1, 2, 2, 0))\n    TD2 &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                       groups = c(1, 1, 1, 1, 1, 0, 0))\n    TD2c &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                        groups = c(1, 1, 1, 1, 1, 1, 0))\n    \n    reg_jo &lt;- ts(cbind(TD2, TD2c, TD3, TD3c, TD4, TD7),\n                 start = start, frequency = frequency)\n    reg_jo &lt;- ts.intersect(reg_jo,\n                           ly)\n    colnames(reg_jo) &lt;- c(\n        \"TD2_semaine\",\n        \"TD2c_lundi_samedi\",\n        sprintf(\"TD3_%s\", c(\"semaine\", \"samedi\")),\n        sprintf(\"TD3c_%s\", c(\"lundi_jeudi\", \"vendredi_samedi\")),\n        sprintf(\"TD4_%s\", c(\"lundi_jeudi\", \"vendredi\", \"samedi\")),\n        sprintf(\"TD7_%s\", c(\"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\")),\n        \"leap_year\")\n    reg_jo\n}\nregresseurs_JO_trim &lt;- gen_calendrier(CAL, frequency = 4)\nregresseurs_JO_mens &lt;- gen_calendrier(CAL, frequency = 12)\n\ncolnames(regresseurs_JO_trim) &lt;- paste0(colnames(regresseurs_JO_trim), \"_trim\")\ncolnames(regresseurs_JO_mens) &lt;- paste0(colnames(regresseurs_JO_mens), \"_mens\")\n\n\n\n\nUne fois votre calendrier créé, vous pouvez l’exporter dans un workspace JDemetra+ :\n\n\n\n\n\n\nJDemetra+ 2.x.y\n\n\n\n\n\nCi-dessous un code pour vous éviter de faire le travail manuel. Il est un peu peu compliqué mais une fois le code écrit, vous pouvez l’utiliser tel quel ! Vous pourrez ensuite repartir du workspace créé pour y ajouter vos propres séries.\n\n# On va créer un nouveau workspace où l'on va ajouter les nouvelles variables\nlibrary(RJDemetra)\nlibrary(rJava)\ncomplete_variables &lt;- function(liste_var, workspace){\n    if(!is.mts(liste_var))\n        stop(\"liste_var doit être de type mts\")\n    context_dictionary &lt;- .jcall(workspace,\"Lec/tstoolkit/algorithm/ProcessingContext;\", \"getContext\")\n    ts_variable_managers &lt;- context_dictionary$getTsVariableManagers()\n    ts_variables &lt;- .jnew(\"ec/tstoolkit/timeseries/regression/TsVariables\")\n    jd_r_variables &lt;- ts_variable_managers$get(\"r\")\n    if (is.null(jd_r_variables)) {\n        ts_variable_managers$set(\"r\",\n                                 .jnew(\"ec/tstoolkit/timeseries/regression/TsVariables\"))\n        jd_r_variables &lt;- ts_variable_managers$get(\"r\")\n    }\n    jd_var_names &lt;- jd_r_variables$getNames()\n    \n    model_var_names &lt;- colnames(liste_var)\n    \n    for (i in seq_along(model_var_names)) {\n        name &lt;- model_var_names[i]\n        dictionary_var &lt;- jd_r_variables$get(name)\n        tsvar &lt;- .jnew(\"ec/tstoolkit/timeseries/regression/TsVariable\",\n                       name, RJDemetra:::ts_r2jd(liste_var[, i]))\n        if (is.null(dictionary_var)) {\n            jd_r_variables$set(name, tsvar)\n        } else {\n            warning(sprintf(\"La variable %s existe déjà\", name))\n        }\n    }\n}\n\n# Création d'un nouveaux\njws &lt;- new_workspace()\n# regresseurs_JO est l'objet mts qui contient tous vos régresseurs\n# Il doit donc déjà être créé (voir code ci-dessus) !\ncomplete_variables(regresseurs_JO_mens, jws)\ncomplete_variables(regresseurs_JO_trim, jws)\nsave_workspace(jws,\"wk_CJO.xml\")\n\n\n\n\n\n\n\n\n\n\nJDemetra+ 3.x.y\n\n\n\n\n\nPour la version 3 de JDemetra+, le code est plus simple. Le code ci-dessous permet également d’ajouter le calendrier en tant qu’objet calendrier de JDemetra+ (et donc pas nécessairement besoin de passer par l’ajout de variables externes).\n\n# On va créer deux groupes de variables, on peut donc simplifier les noms\ncolnames(regresseurs_JO_mens) &lt;- \n    colnames(regresseurs_JO_trim) &lt;- \n    gsub(\"_mens\", \"\", colnames(regresseurs_JO_mens))\nctxt &lt;- rjd3toolkit::modelling_context(\n    # on appelle \"CAL\" le calendrier\n    calendars = list(CAL = CAL), \n    # on crée un groupe de variables \"cjo_mens\" contenant les régresseurs mensuels\n    # et un groupe de variables \"cjo_trim\" contenant les régresseurs trimestriels\n    variables = list(cjo_mens = regresseurs_JO_mens,\n                     cjo_trim = regresseurs_JO_trim)\n) \n\njws &lt;- rjd3workspace::jws_new(ctxt)\n# On peut également ajouter les calendriers et les variables avec les fonctions :\n# rjd3workspace::add_variables()\n# rjd3workspace::add_calendar()\n# Pour modifier un workspace existant :\n# rjd3workspace::set_context()\nrjd3workspace::save_workspace(jws, \"wk_CJO_v3.xml\")"
  },
  {
    "objectID": "TP/JD_4_CVS_CJO.html#créer-une-spécification-incluant-les-jeux-de-régresseurs-jours-ouvrables-personnalisés",
    "href": "TP/JD_4_CVS_CJO.html#créer-une-spécification-incluant-les-jeux-de-régresseurs-jours-ouvrables-personnalisés",
    "title": "4 - Désaisonnalisation avec correction des jours ouvrables",
    "section": "2.3 Créer une spécification incluant les jeux de régresseurs « jours ouvrables » personnalisés",
    "text": "2.3 Créer une spécification incluant les jeux de régresseurs « jours ouvrables » personnalisés\n\nCliquer sur l’onglet Workspace.\nDouble cliquer sur Seasonal adjustment.\nDouble cliquer sur specifications.\nDouble cliquer sur x13.\nClic-droit sur RSA5c (ou RSA5 dans la version 3.x.y).\nCliquer sur Clone.\nQue se passe-t-il ?\nDouble-cliquer sur X13Spec-1.\nCliquer sur le + à côté de Calendar.\nCliquer sur le + à côté de tradingDays.\nCliquer sur Default à côté de option et cliquer ensuite sur UserDefined.\nCliquer sur Unused à côté de userVariables.\nQue se passe-t-il ?\nFaire passer les 6 régresseurs du jeu de régresseurs TD6 + leap_year de la gauche vers la droite.\nCliquer sur le bouton Done.\nCliquer sur OK."
  },
  {
    "objectID": "TP/JD_2_Analyse_exploratoire.html",
    "href": "TP/JD_2_Analyse_exploratoire.html",
    "title": "2 - Analyse exploratoire",
    "section": "",
    "text": "L’objectif de ce TP est d’apprendre à faire une analyse exploratoire sous JDemetra+.\n\n\n1 Tracer un graphique dans JDemetra+\n\nCliquer sur la commande Tools&gt;Container&gt;Chart de la barre de menus en haut de l’écran\n\nQue se passe-t-il ?\n\nFaire glisser une série de l’onglet Providers vers l’onglet Chart.\n\nQue peut-on dire ?\n\nEst-ce que la série présente une tendance ?\nEst-ce que la série semble saisonnière ?\n\n\nEst-ce que la série présente des pics ?\n\nSi oui, ces pics ont-ils ont toujours la même amplitude ?\n\nCliquer sur la courbe.\nClic-droit sur la courbe.\nCliquer sur Split into yearly components :\n\nQue se passe-t-il ?\nQue peut-on dire en analysant ce graphique ?\n\n\n\n\n2 Tracer les taux de croissance d’une série dans JDemetra+\n\nCliquer sur la commande Tools&gt;Container&gt;GrowthChart de la barre de menus en haut de l’écran :\n\nQue se passe-t-il ?\n\nFaire glisser une série de l’onglet Providers vers l’onglet GrowthChart.\n\nQuel est le taux de croissance représenté par défaut sur ce graphique ?\nReprésenter le taux de croissance en glissement annuel par un clic droit sur le graphique et en sélectionnant ensuite dans le menu qui s’affiche l’item Kind puis Previous Year.\nPlacer le curseur de la souris sur une des « barres » du graphique : que se passe-t-il ?\n\nQuelles informations peut-on tirer de ces graphiques ?\n\n\n\n3 Tracer le spectre d’une série sous JDemetra+\n\nCliquer sur la commande Tools&gt;Spectral analysis&gt;Periodogram de la barre de menus en haut de l’écran\n\nQue se passe-t-il ?\n\nFaire glisser une série de l’onglet Providers vers l’onglet Periodogram Window.\n\nLe spectre présente-il des pics ?\n\nSi oui, à quelles fréquences ?\n\n\nFaire la même chose en utilisant le spectre auto-régressif (Auto-regressive Spectrum)."
  },
  {
    "objectID": "TP/JD_1_Premiere_manipulation_JD.html",
    "href": "TP/JD_1_Premiere_manipulation_JD.html",
    "title": "1 - Première manipulation de JDemetra+",
    "section": "",
    "text": "L’objectif de ce TP est de faire une première manipulation de JDemetra+ : créer un workspace, importer des données, lancer une première désaisonnalisation."
  },
  {
    "objectID": "TP/JD_1_Premiere_manipulation_JD.html#importation-dun-fichier-excel-sous-jdemetra",
    "href": "TP/JD_1_Premiere_manipulation_JD.html#importation-dun-fichier-excel-sous-jdemetra",
    "title": "1 - Première manipulation de JDemetra+",
    "section": "2.1 Importation d’un fichier Excel sous JDemetra+",
    "text": "2.1 Importation d’un fichier Excel sous JDemetra+\nOn se place ici dans le cas où les données brutes figurent dans un fichier Excel qui respecte les règles suivantes :\n\nla première colonne correspond à la date au format JJ/MM/AAAA ;\nla première ligne contient le nom des séries.\n\n\n\n\n\n\n\nPour information\n\n\n\nPour créer un tel fichier Excel depuis R, voir le TP 0 - Traitement des séries temporelles sous R.\n\n\n\nRetourner sous JDemetra+.\nCliquer sur l’onglet Providers.\nClic-droit sur Spreadsheets.\nCliquer sur Open.\nCliquer sur le bouton ….\nSélectionner un fichier Excel contenant les séries à désaisonnaliser.\nCliquer sur OK :\n\nQue voit-on sous Spreadsheets ?"
  },
  {
    "objectID": "TP/JD_1_Premiere_manipulation_JD.html#mettre-un-fichier-en-favori",
    "href": "TP/JD_1_Premiere_manipulation_JD.html#mettre-un-fichier-en-favori",
    "title": "1 - Première manipulation de JDemetra+",
    "section": "2.2 Mettre un fichier en « favori »",
    "text": "2.2 Mettre un fichier en « favori »\n\nSauvegarder le workspace puis l’ouvrir de nouveau.\nCliquer sur l’onglet Providers.\nQue voit-on ?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nLes données ont disparues ! La partie Providers est en effet indépendante du Workspace.\n\n\n\n\nImporter de nouveau votre fichier Excel.\nClic-droit sur le nom du fichier Excel qui est apparu sous Spreadsheets.\nCliquer sur Add star.\nQue se passe-t-il ?\nSauvegarder le workspace, fermer le logiciel puis l’ouvrir de nouveau.\nCliquer sur l’onglet Providers :\n\nQue voit-on ?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nLes données restent ! Si on utilise souvent ce fichier Excel c’est un moyen de le garder en mémoire.\n\n\n\n\n\n\n\n\n\nPour information\n\n\n\nJDemetra+ stocke l’emplacement du fichier Excel, si vous le changez de répertoire, les données ne seront plus reconnues ! Peu pratique me direz-vous mais c’est en fait indispensable si l’on souhaite mettre à jour. Évitez donc de laisser votre fichier dans le dossier “Téléchargements” !"
  },
  {
    "objectID": "TP/JD_1_Premiere_manipulation_JD.html#création-dun-nouveau-multi-document",
    "href": "TP/JD_1_Premiere_manipulation_JD.html#création-dun-nouveau-multi-document",
    "title": "1 - Première manipulation de JDemetra+",
    "section": "3.1 Création d’un nouveau « multi-document »",
    "text": "3.1 Création d’un nouveau « multi-document »\n\nCliquer sur l’onglet Workspace.\nDouble-clic sur Seasonal adjustment.\nClic-droit sur multi-documents.\nCliquer sur New.\nDouble-clic sur multi-documents :\n\nQue voit-on ?\n\nDouble-clic sur le « multi-document » créé, nommé SAProcessing-1 par défaut\n\nQue se passe-t-il ?\n\n\n\n\n\n\n\n\nPour information\n\n\n\nDe façon équivalente vous pouvez cliquer sur le Menu Statistical methods &gt; Seasonal Adjustment &gt; Multi Processing &gt; New."
  },
  {
    "objectID": "TP/JD_1_Premiere_manipulation_JD.html#choisir-une-spécfication-pré-définie",
    "href": "TP/JD_1_Premiere_manipulation_JD.html#choisir-une-spécfication-pré-définie",
    "title": "1 - Première manipulation de JDemetra+",
    "section": "3.2 Choisir une spécfication pré-définie",
    "text": "3.2 Choisir une spécfication pré-définie\n\nAller dans l’onglet SAProcessing-1\nCliquer sur la flèche située à côté de la petite « calculatrice »\nCliquer sur le + à côté de « x13 » puis cliquer sur RSA5c (ou RSA5 si l’on utilise JDemetra+ &gt; 3.0.0)\nCliquer quelque part dans SAProcessing-1"
  },
  {
    "objectID": "TP/JD_1_Premiere_manipulation_JD.html#lancer-une-désaisonnalisation",
    "href": "TP/JD_1_Premiere_manipulation_JD.html#lancer-une-désaisonnalisation",
    "title": "1 - Première manipulation de JDemetra+",
    "section": "3.3 Lancer une désaisonnalisation",
    "text": "3.3 Lancer une désaisonnalisation\n\nCliquer sur Providers.\nFaire glisser l’ensemble des séries de votre fichier dans l’onglet SAProcessing-1 :\n\nQue voit-on ?\n\nCliquer sur la flèche verte figurant dans l’onglet SAProcessing-1.\n\n\n\nQue se passe-t-il ?\nCliquer sur une série :\n\nQue voit-on ?\n\nSauvegarder le workspace.\n\n\n\n\n\n\n\nPour information\n\n\n\nIl y a de grandes chances pour qu’un jour vous oubliiez l’étape 3.2 avant de “faire glisser” vos séries. Dans ce cas, vous aurez beau changer la spécification, cela n’affectera pas vos séries déjà importées. Deux solutions s’offrent à vous :\n\nSolution brutale : fermer JDemetra+, supprimer toutes les séries, bref, tout recommencer.\nSolution maligne : sélectionner toutes les séries (ctrl + clic gauche ou ctrl + a, ou ctrl + maj…), clic droit, Spécification &gt; Select &gt; choisir la spécification voulue.\n\n\nDans JDemetra+ &gt; 3.0.0 le choix d’une spécification est obligatoire pour ajouter des séries. Pour modifier la spécification par défaut il faut sélectionner les séries, clic droit, Edit &gt; Reference specification &gt; Select &gt; choisir la spécification voulue."
  },
  {
    "objectID": "TP/JD_3_CVS_sans_CJO.html",
    "href": "TP/JD_3_CVS_sans_CJO.html",
    "title": "3 - Désaisonnalisation sans correction des jours ouvrables",
    "section": "",
    "text": "L’objectif de ce TP est d’apprendre à faire une désaisonnalisation sans correction des jours ouvrables (CJO)."
  },
  {
    "objectID": "TP/JD_3_CVS_sans_CJO.html#schéma-de-décomposition",
    "href": "TP/JD_3_CVS_sans_CJO.html#schéma-de-décomposition",
    "title": "3 - Désaisonnalisation sans correction des jours ouvrables",
    "section": "2.1 Schéma de décomposition",
    "text": "2.1 Schéma de décomposition\n\nDans la fenêtre Main results :\n\nQuel est le schéma de décomposition choisi par JDemetra+ ? Est-ce que vous êtes d’accord ?"
  },
  {
    "objectID": "TP/JD_3_CVS_sans_CJO.html#outliers",
    "href": "TP/JD_3_CVS_sans_CJO.html#outliers",
    "title": "3 - Désaisonnalisation sans correction des jours ouvrables",
    "section": "2.2 Outliers",
    "text": "2.2 Outliers\n\nDans la fenêtre Main results :\n\nCombien d’outliers ont été détectés par JDemetra+ ?\n\nY en a-t-il trop ?\n\n\nDans la fenêtre Pre-processing :\n\nQuels sont les différents types d’outliers détéctés par JDemetra+ ?\n\nRetourner dans la fenêtre Main results :\n\nAller dans Main results &gt; Charts :\n\nRegarder les différents graphiques : pouvez-vous repérer, sur la série brute, les points atypiques détéctés dans le modèle ?"
  },
  {
    "objectID": "TP/JD_3_CVS_sans_CJO.html#s-i-ratio",
    "href": "TP/JD_3_CVS_sans_CJO.html#s-i-ratio",
    "title": "3 - Désaisonnalisation sans correction des jours ouvrables",
    "section": "2.3 S-I Ratio",
    "text": "2.3 S-I Ratio\n\nAller dans la fenêtre Main results &gt; S-I ratio.\nPouvez-vous repérer le schéma de décomposition ?\nQuel est l’objectif de ce graphique ?\nLes coefficients saisonniers sont-ils stables ?"
  },
  {
    "objectID": "TP/JD_5_Preajustment.html",
    "href": "TP/JD_5_Preajustment.html",
    "title": "5 - Pré-ajustement",
    "section": "",
    "text": "L’objectif de ce TP est d’analyser la qualité du pre-ajustement et de modifier, si nécessaire, la spécification"
  },
  {
    "objectID": "TP/JD_5_Preajustment.html#transformation",
    "href": "TP/JD_5_Preajustment.html#transformation",
    "title": "5 - Pré-ajustement",
    "section": "2.1 Transformation",
    "text": "2.1 Transformation\n\nEssayez de changer le schéma de décomposition (onglet TRANSFORMATION &gt; function) :\n\nQu’est-ce que vous remarquez ? Est-ce qu’il y a eu des changements dans la partie le pré-ajustement ?\nEst-ce que les critères AICc et BIC ont été modifiés ?"
  },
  {
    "objectID": "TP/JD_5_Preajustment.html#régresseurs-calendaires",
    "href": "TP/JD_5_Preajustment.html#régresseurs-calendaires",
    "title": "5 - Pré-ajustement",
    "section": "2.2 Régresseurs calendaires",
    "text": "2.2 Régresseurs calendaires\n\nEssayez de changer le jeu de régresseurs jours ouvrables :\nQue pouvez-vous noter sur les tests de Student, Fischer, coefficients, AICc et BIC ?\nEst-ce qu’il y a des effets calendaires résiduels ?\nQuelle est la qualité du modèle Reg-ARIMA ?"
  },
  {
    "objectID": "TP/JD_5_Preajustment.html#outliers",
    "href": "TP/JD_5_Preajustment.html#outliers",
    "title": "5 - Pré-ajustement",
    "section": "2.3 Outliers",
    "text": "2.3 Outliers\n\nDans la partie REGRESSION &gt; Pre-specified outliers :\n\nAjouter des outliers qui vous semblent pertinents et qui ne sont pas détectés par JDemetra+ (si vous avez connaissance d’un évènement particulier)\n\nEssayer de changer le seuil critique de détection des outliers (Critical value.\nQue remarquez vous sur le nombre d’outliers, l’AICc et le BIC ?\nEn quoi cela affecte la qualité de l’ajustement et des résidus du modèle ?\nEssayer de changer le type d’outliers détectés."
  },
  {
    "objectID": "TP/JD_5_Preajustment.html#forecasts-results",
    "href": "TP/JD_5_Preajustment.html#forecasts-results",
    "title": "5 - Pré-ajustement",
    "section": "2.4 Forecasts results",
    "text": "2.4 Forecasts results\n\nAller dans la partie Pre-processing &gt; Forecasts &gt; Out-of-sample test :\nQue comprenez-vous ?\nEn quoi c’est utile ?"
  },
  {
    "objectID": "TP/JD_7_Etude_de_cas.html",
    "href": "TP/JD_7_Etude_de_cas.html",
    "title": "7 - Étude de cas",
    "section": "",
    "text": "L’objectif de ce TP est de faire une étude de cas spécifique pour voir des problèmes possibles et une proposition de solution.\nDisclaimer : il peut exister plusieurs solutions, celles données dans ce TP ne sont que des propositions qui peuvent être discuté.\nPour télécharger le workspace, cliquer ici et dézipper le fichier."
  },
  {
    "objectID": "TP/JD_7_Etude_de_cas.html#série-rf2932",
    "href": "TP/JD_7_Etude_de_cas.html#série-rf2932",
    "title": "7 - Étude de cas",
    "section": "1.1 Série RF2932",
    "text": "1.1 Série RF2932\n\n\n\n\n\n\nExercice\n\n\n\nIl y a un problème d’hétéroscédasticité (au seuil de 1 %) et un léger problème de non-normalité (au seuil de 1 %).\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nQue pensez-vous du schéma de décomposition ?\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nDécision : forcer le schéma en multiplicatif."
  },
  {
    "objectID": "TP/JD_7_Etude_de_cas.html#série-rf2813",
    "href": "TP/JD_7_Etude_de_cas.html#série-rf2813",
    "title": "7 - Étude de cas",
    "section": "1.2 Série RF2813",
    "text": "1.2 Série RF2813\nL’analyse de cette série nécessite d’avoir vu les statistiques M qui jugent la qualité de la décomposition.\n\n\n\n\n\n\nExercice\n\n\n\nIl y a un problème d’autocorrélation des résidus (au seuil de 1 %) et une mauvaise décomposition (Q-M2).\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nQue pensez-vous du schéma de décomposition ?\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nLe problème d’autocorrélation peut être atténué en forçant le schéma additif (p-valeur du test est alors égale à 0,04).\nLa mauvaise décomposition vient du fait que la tendance est plate et donc que la composante irrégulière est plus variable que la composante tendance-cycle.\nDécision : forcer le schéma en additif."
  },
  {
    "objectID": "TP/JD_7_Etude_de_cas.html#série-rf2223",
    "href": "TP/JD_7_Etude_de_cas.html#série-rf2223",
    "title": "7 - Étude de cas",
    "section": "1.3 Série RF2223",
    "text": "1.3 Série RF2223\n\n\n\n\n\n\nExercice\n\n\n\nIl y a un effet JO résiduel (au seuil de 5 % mais pas 1 %) et un problème d’hétéroscédasticité (au seuil de 5 % mais pas 1 %).\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nRéduire le seuil de détection des outliers pour voir ce qu’il se passe.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nDécision : Ajouter deux AO en 8-2007 et 7-2009.\nIl est préférable de rajouter les outliers à la main plutôt que de modifier de manière permanente le seuil de détection des outliers : cela évitera, pour les futures révisions du modèle,de détecter trop d’outliers."
  },
  {
    "objectID": "TP/JD_7_Etude_de_cas.html#série-rf2453-tc-or-not-tc",
    "href": "TP/JD_7_Etude_de_cas.html#série-rf2453-tc-or-not-tc",
    "title": "7 - Étude de cas",
    "section": "1.4 Série RF2453 : TC or not TC",
    "text": "1.4 Série RF2453 : TC or not TC\n\n\n\n\n\n\nExercice\n\n\n\nIl y a un effet JO résiduel (au seuil de 1 %).\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nQue pensez-vous des outliers détectés ?\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nSupprimer la détection des TC permet de corriger le problème sur l’irrégulier mais pas sur la série désaisonnalisée.\nDécision : désactiver la détection automatique de TC."
  },
  {
    "objectID": "TP/JD_7_Etude_de_cas.html#série-rf1101",
    "href": "TP/JD_7_Etude_de_cas.html#série-rf1101",
    "title": "7 - Étude de cas",
    "section": "2.1 Série RF1101",
    "text": "2.1 Série RF1101\n\n\n\n\n\n\nExercice\n\n\n\nAnalyser les S-I ratios et le graphique yearly components de la série brute : que remarquez vous ?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nPour cette série, le modèle est estimé depuis 2004 mais les CVS-CJO ne sont mises à jour qu’à partir de 2012.\nIl y a une nette rupture de saisonnalité en 2008 qui n’affecte pas la période après 2012 (filtre M3X5 utilisé, soit pour l’estimation des coefficients saisonniers de l’année A utilise les moyennes de l’année A-3 à A+3). Ainsi, commencer l’estimation du modèle à partir de 2008 permet d’avoir un modèle de pré-ajustement mieux estimé sur le présent et la rupture de saisonnalité n’affectera pas les coefficients publiés.\nUne autre solution est de rajouter un seasonal outlier en août 2008."
  },
  {
    "objectID": "TP/JD_7_Etude_de_cas.html#série-rf2561",
    "href": "TP/JD_7_Etude_de_cas.html#série-rf2561",
    "title": "7 - Étude de cas",
    "section": "3.1 Série RF2561",
    "text": "3.1 Série RF2561\n\n\n\n\n\n\nExercice\n\n\n\nIl y a de la saisonnalité résiduelle et une mauvaise qualité des résidus du modèle RegARIMA.\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nAnalyser la série sur la fin de la période pour voir d’où vient la saisonnalité résiduelle. Comment pourrait-on la corriger ? Est-ce qu’il s’agit d’une rupture brute ou progressive ?\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nUne rupture de saisonnalité s’observe en juin 2011 : avant cette date juin était un point haut alors qu’à partir de 2011 il est au même niveau que les mois de mai et juillet. Ajout un SO à cette date corrige la rupture mais laisse une saisonnalité résiduelle qui vient du mois de décembre : on observe sur la série désaisonnalisée des pics systématiques en décembre sur les dernières années. Cette fois-ci ce n’est pas une rupture brute de la saisonnalité : le point de décembre qui était également un point haut avant 2011 devient progressivement de plus en plus bas. Le MSR de décembre (à 0,77) est d’ailleurs bien plus bas que celui des autres mois (qui sont autour de 2) ce qui suggère de prendre un filtre saisonnier plus court en décembre (le filtre actuellement choisi est M3X3). La mauvaise qualité des résidus est difficilement corrigeable, il faudrait prendre une période d’estimation beaucoup plus courtes qui ajouterait donc une instabilité des estimations.\nDécision : rajouter un SO en juin 2011 et utiliser le filtre M3X1 pour le mois de décembre. Pas d’intervention pour corriger la qualité des résidus."
  },
  {
    "objectID": "TP/JD_7_Etude_de_cas.html#série-rf3299",
    "href": "TP/JD_7_Etude_de_cas.html#série-rf3299",
    "title": "7 - Étude de cas",
    "section": "3.2 Série RF3299",
    "text": "3.2 Série RF3299\n\n\n\n\n\n\nExercice\n\n\n\nIl y a de la saisonnalité résiduelle.\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nAnalyser correctement le problème de saisonnalité résiduelle.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nAjouter des SO en 10-2012 et 12-2015."
  },
  {
    "objectID": "TP/JD_7_Etude_de_cas.html#séries-c4672",
    "href": "TP/JD_7_Etude_de_cas.html#séries-c4672",
    "title": "7 - Étude de cas",
    "section": "3.3 Séries C4672",
    "text": "3.3 Séries C4672\n\n\n\n\n\n\nExercice\n\n\n\nDans cet exercice il y a deux séries à étudier : la série C4672 depuis 1999 et la même série mais estimée à partir de 2005.\n\nCommencez par la série qui commence en 1999. Comment vous parait le modèle ?\nAnalyser le modèle de la série qui commence en 2005 et comparer les résultats.\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nSaisonnalité résiduelle non détectée pour modèle ensemble mais détectée si modèle coupé à partir de 2005.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nAjouter un SO 11-2008."
  },
  {
    "objectID": "TP/JD_7_Etude_de_cas.html#série-c4773",
    "href": "TP/JD_7_Etude_de_cas.html#série-c4773",
    "title": "7 - Étude de cas",
    "section": "3.4 Série C4773",
    "text": "3.4 Série C4773\n\n\n\n\n\n\nExercice\n\n\n\nSaisonnalité résiduelle détectée.\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nÉtudier les S-I ratio : la saisonnalité est-elle stable ?\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOn observe une saisonnalité plutôt stable sauf en juillet et août (étude des S-I ratio). Les S-I ratio montrent aussi en juillet et août un comportement « atypique » de l’irrégulier en début de période. On n’observe pas de changement brusque de saisonnalité. L’étude des MSR par mois suggère de prendre un filtre plus court en juillet et en août : cela permet de corriger la saisonnalité résiduelle."
  },
  {
    "objectID": "TP/R_1_R_et_JD_v2.html",
    "href": "TP/R_1_R_et_JD_v2.html",
    "title": "1 - R et JDemetra+ (V2)",
    "section": "",
    "text": "L’objectif de ce TP est d’apprendre à manipuler JDemetra+ sous R à travers le package RJDemetra.\n\nPour manipuler JDemetra+ sous R il y a actuellement deux façons :\n\nUtiliser le JWSACruncher qui permet, à partir de la console, de mettre à jour un workspace JDemetra+ et d’exporter les résultats sans devoir ouvrir le logiciel. Pour faciliter son utilisation depuis R, le package rjwsacruncher peut être utilisé (voir TP5 - JDemetra+ en production).\nUtiliser le package RJDemetra qui permet d’effectuer des désaisonnalisations avec les mêmes algorithmes et paramètres que JDemetra+ et de manipuler des workspaces.\n\nDans ce TP on utilisera les données du package RJDemetra mais n’hésitez pas à utiliser vos propres séries !\nPour faire de la désaisonnalisation sous R il existe plusieurs packages :\n\nseasonal et x12 qui permettent de faire du X-13ARIMA-SEATS en utilisant les programmes du US Census Bureau\nRJDemetra qui est une interface R à JDemetra+ et c’est ce package que l’on va étudier.\n\nRJDemetra est sur le CRAN et se base sur les librairies Java de JDemetra+. Pour l’utiliser il faut avoir Java 8 ou plus. En cas de problème d’installation voir le manuel d’installation.\nLe package a aussi un site web (https://rjdverse.github.io/rjdemetra/).\nRJDemetra permet :\n\nDe faire des modèles RegARIMA, TRAMO-SEATS and X-13-ARIMA comme dans JDemetra+ en définissant sa propre spécification\nManipuler les workspaces de JDemetra+\nImporter les modèles workspaces sauvegardés par JDemetra+\nExporter les modèles créés sous RJDemetra\n\nCommencez par charger le package RJDemetra :\n\nlibrary(RJDemetra)\n\n\n1 Créer une specification\nDans les prochains exercices, la série utilisée sera ipi_c_eu[, \"FR\"] qui est l’IPI français. Vous pouvez bien sûr adapter le code pour utiliser vos propres séries. Les fonctions utilisées seront x13(), x13_spec(), regarima_x13, regarima_x13_spec ou regarima. Le détail des spécifications pré-définies par JDemetra+ sont disponibles ici.\n\n\n\n\n\n\nExercice\n\n\n\nFaire la désaisonnalisation d’une série avec X-13 avec la spécification suivante :\n\ndétection automatique du schéma de décomposition, des outliers et du modèle ARIMA ;\nune correction des jours ouvrables “working days” et un effet graduel de Pâques.\n\nFaire ensuite un graphique avec la série brute et la série désaisonnalisée.\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nUtiliser la spécification RSA4c pour la désaisonnalisation.\nSi le modèle créé s’appelle mysa, regarder les valeurs de mysa$final, mysa$final$series et mysa$final$forecasts.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nlibrary(RJDemetra)\nmysa &lt;- x13(ipi_c_eu[, \"FR\"], spec = \"RSA4c\")\nmysa\n\nRegARIMA\ny = regression model + arima (2, 1, 1, 0, 1, 1)\nLog-transformation: no\nCoefficients:\n          Estimate Std. Error\nPhi(1)     0.05291      0.108\nPhi(2)     0.18672      0.074\nTheta(1)  -0.52137      0.103\nBTheta(1) -0.66132      0.042\n\n             Estimate Std. Error\nWeek days      0.6927      0.031\nLeap year      2.0903      0.694\nEaster [1]    -2.5476      0.442\nTC (4-2020)  -35.6481      2.092\nAO (3-2020)  -21.1492      2.122\nAO (5-2011)   13.1869      1.810\nLS (11-2008)  -9.2744      1.758\nLS (1-2009)   -7.2838      1.756\n\n\nResidual standard error: 2.193 on 346 degrees of freedom\nLog likelihood = -795.1, aic =  1616 aicc =  1617, bic(corrected for length) = 1.767\n\n\n\nDecomposition\nMonitoring and Quality Assessment Statistics:\n      M stats\nM(1)    0.127\nM(2)    0.079\nM(3)    1.094\nM(4)    0.558\nM(5)    1.093\nM(6)    0.022\nM(7)    0.085\nM(8)    0.242\nM(9)    0.064\nM(10)   0.261\nM(11)   0.247\nQ       0.355\nQ-M2    0.389\n\nFinal filters: \nSeasonal filter:  3x5\nTrend filter:  13 terms Henderson moving average\n\n\nFinal\nLast observed values\n             y        sa        t           s           i\nJan 2020 101.0 102.87273 103.0457  -1.8727280  -0.1730003\nFeb 2020 100.1 103.69025 103.0626  -3.5902540   0.6276448\nMar 2020  91.8  82.69170 103.2654   9.1083000 -20.5736602\nApr 2020  66.7  66.55184 103.6945   0.1481625 -37.1426277\nMay 2020  73.7  79.28883 104.1379  -5.5888279 -24.8490764\nJun 2020  98.2  87.35362 104.4539  10.8463757 -17.1002284\nJul 2020  97.4  92.26057 104.5518   5.1394323 -12.2912806\nAug 2020  71.7  97.54392 104.3369 -25.8439193  -6.7929846\nSep 2020 104.7  97.75728 103.8361   6.9427184  -6.0788659\nOct 2020 106.7  97.87016 103.1969   8.8298396  -5.3267823\nNov 2020 101.6 100.01475 102.6601   1.5852540  -2.6453446\nDec 2020  96.6  99.61740 102.4081  -3.0173983  -2.7907314\n\nForecasts:\n               y_f     sa_f      t_f         s_f        i_f\nJan 2021  94.29728 101.0937 102.3876  -6.7963909 -1.2939310\nFeb 2021  97.89298 101.6869 102.4525  -3.7939488 -0.7655396\nMar 2021 113.65190 102.1478 102.4593  11.5041248 -0.3115701\nApr 2021 102.34532 102.1806 102.3419   0.1647274 -0.1612727\nMay 2021  96.14552 101.6436 102.1712  -5.4980759 -0.5276194\nJun 2021 112.15785 101.2156 102.0241  10.9422549 -0.8085520\nJul 2021 104.38495 101.5439 101.9635   2.8410057 -0.4195241\nAug 2021  79.02901 102.3820 102.0412 -23.3530134  0.3408366\nSep 2021 109.40288 102.3705 102.1977   7.0323700  0.1728109\nOct 2021 108.22472 101.8558 102.3655   6.3689511 -0.5096780\nNov 2021 106.22014 102.4265 102.5266   3.7936049 -0.1000754\nDec 2021  99.67523 102.9462 102.6812  -3.2709156  0.2649189\n\n\nDiagnostics\nRelative contribution of the components to the stationary\nportion of the variance in the original series,\nafter the removal of the long term trend\n Trend computed by Hodrick-Prescott filter (cycle length = 8.0 years)\n           Component\n Cycle         1.830\n Seasonal     51.089\n Irregular     0.927\n TD & Hol.     2.179\n Others       44.916\n Total       100.941\n\nCombined test in the entire series\n Non parametric tests for stable seasonality\n                                                          P.value\n   Kruskall-Wallis test                                      0.000\n   Test for the presence of seasonality assuming stability   0.000\n   Evolutive seasonality test                                0.014\n \n Identifiable seasonality present\n\nResidual seasonality tests\n                                      P.value\n qs test on sa                          0.924\n qs test on i                           0.643\n f-test on sa (seasonal dummies)        0.671\n f-test on i (seasonal dummies)         0.453\n Residual seasonality (entire series)   0.415\n Residual seasonality (last 3 years)    0.954\n f-test on sa (td)                      0.091\n f-test on i (td)                       0.333\n\n\nAdditional output variables\n\ny &lt;- mysa$final$series[,\"y\"]\n# De façon équivalente :\ny &lt;- get_ts(mysa)\nsa &lt;- mysa$final$series[,\"sa\"]\nplot(y)\nlines(sa, col = \"red\")\n\n\n\n\n\n\n\n# ou on peut directement utiliser les fonctions de RJDemetra :\nplot(mysa, first_date = 2000, #Pour n'afficher le graphique qu'à partir de 200\n     type_chart = \"sa-trend\" # Pour faire le graphique avec y, sa et tendance\n)\n\n\n\n\n\n\n\n\nPour des graphiques ggplot2, on peut également utiliser le package ggdemetra :\n\nlibrary(ggdemetra)\n# y &lt;- ggdemetra::raw(mysa)\n# sa &lt;- ggdemetra::seasonaladj(mysa)\np_sa &lt;- \n    ggplot(data = ggdemetra::ts2df(y), \n           mapping = aes(x = date, y = y)) +\n    geom_line(color = \"#F0B400\") +\n    labs(title = \"Y, Sa, Trend\",\n         x = NULL, y = NULL) +\n    geom_sa(component = \"y_f\", linetype = 2,\n            spec = x13_spec(mysa), frequency = 12,\n            color = \"#F0B400\") + \n    geom_sa(component = \"sa\", color = \"#155692\") +\n    geom_sa(component = \"sa_f\", color = \"#155692\", linetype = 2)+ \n    geom_sa(component = \"t\", color = \"#1E6C0B\") +\n    geom_sa(component = \"t_f\", color = \"#1E6C0B\", linetype = 2) + \n    theme_bw()\np_sa\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nModifier le modèle précédent pour enlever l’effet graduel de Pâques.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nspec_sans_easter &lt;- x13_spec(mysa,\n                             easter.enabled = FALSE)\nmysa2 &lt;- x13(ipi_c_eu[, \"FR\"], spec_sans_easter)\nmysa2$regarima\n\ny = regression model + arima (2, 1, 1, 0, 1, 1)\nLog-transformation: yes\nCoefficients:\n          Estimate Std. Error\nPhi(1)     0.05032      0.118\nPhi(2)     0.09575      0.082\nTheta(1)  -0.55559      0.110\nBTheta(1) -0.73033      0.039\n\n              Estimate Std. Error\nWeek days     0.007179      0.000\nAO (5-2011)   0.124297      0.018\nLS (11-2008) -0.086926      0.017\nLS (1-2009)  -0.071005      0.017\n\n\nResidual standard error: 0.02133 on 338 degrees of freedom\nLog likelihood =   838, aic =  1548 aicc =  1548, bic(corrected for length) = -7.561\n\n\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nCalculer les p-valeurs associées au modèle Reg-ARIMA de la précédente spécification.\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nRécupérer le modèle Reg-ARIMA et utiliser la fonction summary().\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nreg_sum &lt;- summary(mysa2$regarima)\nreg_sum\n\ny = regression model + arima (2, 1, 1, 0, 1, 1)\n\nModel: RegARIMA - X13\nEstimation span: from 1-1990 to 12-2019\nLog-transformation: yes\nRegression model: no mean, trading days effect(1), no leap year effect, no Easter effect, outliers(3)\n\nCoefficients:\nARIMA: \n          Estimate Std. Error  T-stat Pr(&gt;|t|)    \nPhi(1)     0.05032    0.11801   0.426    0.670    \nPhi(2)     0.09575    0.08224   1.164    0.245    \nTheta(1)  -0.55559    0.10956  -5.071 6.45e-07 ***\nBTheta(1) -0.73033    0.03938 -18.545  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nRegression model: \n               Estimate Std. Error T-stat Pr(&gt;|t|)    \nWeek days     0.0071788  0.0003171 22.637  &lt; 2e-16 ***\nAO (5-2011)   0.1242970  0.0180390  6.890 2.63e-11 ***\nLS (11-2008) -0.0869263  0.0171661 -5.064 6.69e-07 ***\nLS (1-2009)  -0.0710049  0.0171449 -4.141 4.34e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nResidual standard error: 0.02133 on 338 degrees of freedom\nLog likelihood =   838, aic =  1548, aicc =  1548, bic(corrected for length) = -7.561\n\n\nOn peut récupérer ces valeurs en exploitant l’objet reg_sum :\n\nreg_sum$coefficients\n\n$arima\n             Estimate Std. Error     T-stat     Pr(&gt;|t|)\nPhi(1)     0.05031546 0.11801332   0.426354 6.701142e-01\nPhi(2)     0.09575287 0.08224054   1.164303 2.451013e-01\nTheta(1)  -0.55559277 0.10955864  -5.071191 6.449100e-07\nBTheta(1) -0.73033107 0.03938071 -18.545401 0.000000e+00\n\n$regression\n                 Estimate   Std. Error    T-stat     Pr(&gt;|t|)\nWeek days     0.007178836 0.0003171301 22.636876 0.000000e+00\nAO (5-2011)   0.124296961 0.0180390210  6.890449 2.628564e-11\nLS (11-2008) -0.086926347 0.0171661398 -5.063826 6.685537e-07\nLS (1-2009)  -0.071004892 0.0171448840 -4.141462 4.338403e-05\n\n$fixed_out\nNULL\n\n$fixed_var\nNULL\n\n\n\n\n\n\n\n2 Créer un workspace\nDans cette partie nous allons créer un workspace depuis R. Pour cela les fonctions qui peuvent être utilisées sont new_workspace(), load_workspace(), new_multiprocessing(), add_sa_item(), save_workspace(), compute(), get_object(), get_name(), get_ts() ou count().\n\n\n\n\n\n\nExercice\n\n\n\nCréer un workspace qui va contenir une série désaisonnalisée selon 3 spécifications différentes.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\njws &lt;- new_workspace()\nnew_multiprocessing(jws, \"MP-1\")\nadd_sa_item(jws, \"MP-1\", mysa, \"X13 avec Pâques\")\nadd_sa_item(jws, \"MP-1\", mysa2, \"X13 sans Pâques\")\nadd_sa_item(jws, \"MP-1\", tramoseats(ipi_c_eu[, \"FR\"]), \"TRAMO-SEATS\")\nsave_workspace(jws, \"mon_premier_workspace.xml\")\n\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nImporter le workspace précédent et récupérer :\n\nLe nom du premier multi-processing\nLe nombre de modèles dans ce premier multi-processing\nL’ensemble des séries brutes\nLe 2ème modèle\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\njws &lt;- load_workspace(\"mon_premier_workspace.xml\")\ncompute(jws)\ncount(jws) # Nombre de multiprocessing\n\n[1] 1\n\njmp1 &lt;- get_object(jws, 1) # Le premier multiprocessing\nget_name(jmp1)\n\n[1] \"MP-1\"\n\ncount(jmp1)\n\n[1] 3\n\nall_y &lt;- get_ts(jmp1) # toutes les séries brutes\nmodel2 &lt;- get_object(jmp1, 2) # On récupère l'objet associé au 2ème modèle\nget_model(model2, jws)\n\nRegARIMA\ny = regression model + arima (2, 1, 1, 0, 1, 1)\nLog-transformation: yes\nCoefficients:\n          Estimate Std. Error\nPhi(1)     0.05032      0.118\nPhi(2)     0.09575      0.082\nTheta(1)  -0.55559      0.110\nBTheta(1) -0.73033      0.039\n\n              Estimate Std. Error\nWeek days     0.007179      0.000\nAO (5-2011)   0.124297      0.018\nLS (11-2008) -0.086926      0.017\nLS (1-2009)  -0.071005      0.017\n\n\nResidual standard error: 0.02133 on 338 degrees of freedom\nLog likelihood =   838, aic =  1548 aicc =  1548, bic(corrected for length) = -7.561\n\n\n\nDecomposition\nMonitoring and Quality Assessment Statistics:\n      M stats\nM(1)    0.080\nM(2)    0.044\nM(3)    0.925\nM(4)    0.324\nM(5)    1.018\nM(6)    0.172\nM(7)    0.075\nM(8)    0.207\nM(9)    0.069\nM(10)   0.229\nM(11)   0.207\nQ       0.311\nQ-M2    0.344\n\nFinal filters: \nSeasonal filter:  3x5\nTrend filter:  13 terms Henderson moving average\n\n\nFinal\nLast observed values\n             y       sa        t         s         i\nJan 2019 103.9 104.9497 104.8872 0.9899977 1.0005966\nFeb 2019 101.9 106.2130 105.1277 0.9593928 1.0103234\nMar 2019 111.0 104.7070 105.2207 1.0601007 0.9951182\nApr 2019 107.4 105.0688 105.1200 1.0221871 0.9995130\nMay 2019 105.5 108.7078 104.9337 0.9704918 1.0359658\nJun 2019 105.8 101.5038 104.6881 1.0423256 0.9695826\nJul 2019 110.1 105.4918 104.3766 1.0436828 1.0106850\nAug 2019  78.7 102.6361 104.0097 0.7667871 0.9867928\nSep 2019 108.5 104.0439 103.5870 1.0428287 1.0044106\nOct 2019 116.8 104.5857 103.1442 1.1167879 1.0139754\nNov 2019 103.8 101.7786 102.7722 1.0198610 0.9903319\nDec 2019  97.7 101.5883 102.5735 0.9617252 0.9903948\n\nForecasts:\n               y_f     sa_f      t_f       s_f       i_f\nJan 2020 101.86190 102.9804 102.5981 0.9891385 1.0037265\nFeb 2020 100.79119 103.1440 102.8002 0.9771887 1.0033443\nMar 2020 111.43956 102.5781 103.0224 1.0863878 0.9956869\nApr 2020 105.54428 103.3790 103.2028 1.0209447 1.0017079\nMay 2020  96.34392 104.3346 103.2155 0.9234131 1.0108422\nJun 2020 112.45079 102.5347 103.0496 1.0967099 0.9950029\nJul 2020 106.92345 102.3231 102.8558 1.0449593 0.9948203\nAug 2020  76.61765 102.5744 102.7208 0.7469472 0.9985747\nSep 2020 110.47115 103.3476 102.6644 1.0689277 1.0066554\nOct 2020 111.53872 102.2010 102.6987 1.0913668 0.9951530\nNov 2020 104.52886 102.5479 102.7719 1.0193176 0.9978206\nDec 2020 101.73775 103.4319 102.9459 0.9836210 1.0047204\n\n\nDiagnostics\nRelative contribution of the components to the stationary\nportion of the variance in the original series,\nafter the removal of the long term trend\n Trend computed by Hodrick-Prescott filter (cycle length = 8.0 years)\n           Component\n Cycle         1.984\n Seasonal     62.978\n Irregular     0.998\n TD & Hol.     2.273\n Others       33.676\n Total       101.909\n\nCombined test in the entire series\n Non parametric tests for stable seasonality\n                                                          P.value\n   Kruskall-Wallis test                                      0.000\n   Test for the presence of seasonality assuming stability   0.000\n   Evolutive seasonality test                                0.429\n \n Identifiable seasonality present\n\nResidual seasonality tests\n                                      P.value\n qs test on sa                          1.000\n qs test on i                           0.965\n f-test on sa (seasonal dummies)        0.625\n f-test on i (seasonal dummies)         0.474\n Residual seasonality (entire series)   0.779\n Residual seasonality (last 3 years)    0.878\n f-test on sa (td)                      0.076\n f-test on i (td)                       0.385\n\n\nAdditional output variables\n\n\n\n\n\n\n\n3 Manipuler les objets Java\nL’objectif de cette partie est de manipuler la fonction jx13() pour gagner en temps de calcul.\n\n\n\n\n\n\nExercice\n\n\n\nCréer un modèle à partir de la fonction jx13() et la spécification sans effet graduel de pâques crée dans la section 1.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nmyjsa &lt;- jx13(ipi_c_eu[, \"FR\"], spec_sans_easter)\nget_indicators(myjsa, \"sa\")\n\n$sa\n           Jan       Feb       Mar       Apr       May       Jun       Jul\n1990  93.27297  96.29529  94.47992  93.73334  93.94507  92.83948  94.28898\n1991  93.61809  93.12145  92.56800  92.23966  88.02740  94.55282  92.48219\n1992  91.62891  91.43164  92.38484  92.19526  91.08704  90.59578  89.51814\n1993  87.30634  87.99736  86.85921  86.97894  86.99296  87.29234  86.76534\n1994  88.69622  87.77278  88.37550  89.30617  91.27332  91.48108  90.65425\n1995  95.09916  94.52731  93.92731  93.90941  92.37904  92.04264  93.77960\n1996  93.06670  91.54362  94.26169  93.30918  91.32878  94.96354  94.26156\n1997  93.06742  95.67044  95.13059 101.85852  96.43204  98.44794  98.23010\n1998 102.13804 103.25275 102.01932 102.89690 103.62209 101.81934 103.60992\n1999 103.71964 102.64444 103.76759 104.04665 106.13300 106.82584 105.69365\n2000 110.38789 107.38428 109.60527 110.17270 114.61835 106.35539 110.67086\n2001 112.45025 113.34404 113.88119 110.73914 111.61677 111.49774 112.13527\n2002 110.26696 110.99285 111.13280 111.58735 107.54579 111.87216 110.92070\n2003 108.72641 109.77205 109.75157 109.85823 105.81090 105.36978 108.56247\n2004 109.12622 109.43552 109.52322 110.42603 111.47708 112.70525 111.38248\n2005 114.72877 111.07384 106.23729 114.40231 113.83685 111.14636 109.33782\n2006 112.84431 110.57123 111.88826 111.79247 114.34733 112.62975 111.48879\n2007 112.53191 114.29580 114.23700 113.06787 112.93424 115.43386 116.32302\n2008 114.06045 113.94480 111.07963 118.83142 111.92185 110.96502 111.54674\n2009  93.60983  93.32624  92.17978  92.82197  94.61843  94.29186  94.42552\n2010  95.51379  96.12075  98.46494  99.01596 102.81820 100.22951  99.30088\n2011 104.88512 104.72507 103.63569 102.25128 116.10802  97.55663 101.60353\n2012 102.83064  98.48657 101.60323  99.95552  99.30289 100.25687 101.48753\n2013  97.45647  98.45690  97.93752 100.35136  99.79029 100.14504 100.08302\n2014  97.89835 100.00657  98.78845  99.56271  98.29814  97.26484  98.38400\n2015  98.27255  99.53811  99.50288  99.07983  99.28072 101.49169  96.66780\n2016 101.32397  99.22467  96.95194 102.97678 105.03035 100.37169  96.68839\n2017 102.72859 101.41668 102.63069 100.60801 106.58076 101.54655 100.67684\n2018 103.19713 103.14126 103.70513 103.35321 102.04279 105.47625 105.16178\n2019 104.94974 106.21301 104.70704 105.06883 108.70777 101.50380 105.49182\n           Aug       Sep       Oct       Nov       Dec\n1990  92.81532  93.42471  93.21965  92.25071  90.06120\n1991  91.72254  92.21808  91.96428  92.02285  90.46195\n1992  91.95223  89.69252  89.81277  90.02832  88.33305\n1993  87.30196  87.03081  87.21300  84.45288  87.46656\n1994  91.37247  91.19741  91.98386  92.78677  95.17153\n1995  92.38821  93.99473  92.85706  93.36671  94.38969\n1996  93.75684  94.14529  93.72433  93.79062  93.43034\n1997 101.81145  99.64928 101.86478 100.90774 101.70138\n1998 103.62658 103.60456 103.09096 104.46065 102.99964\n1999 106.07083 107.12621 108.29389 107.17738 110.10121\n2000 111.01860 110.92744 111.42763 113.10692 114.51591\n2001 115.50617 111.31601 110.65583 110.20538 108.13496\n2002 112.75124 109.55689 109.18036 109.90888 106.38982\n2003 107.51695 108.10694 110.01758 109.50133 108.16481\n2004 110.31329 111.75188 112.44658 108.46909 111.73847\n2005 110.00423 112.59573 109.23754 111.65979 113.81029\n2006 112.62602 113.48750 112.76155 112.55067 113.59525\n2007 115.82841 112.91803 115.49734 113.69439 112.28630\n2008 109.36385 109.09852 108.03726 100.63716  99.86454\n2009  96.91866  97.94748  97.85917  97.60414  96.07651\n2010  99.54513 100.43464 100.75477  98.83302 102.97020\n2011 101.60617 101.45456 102.21445 102.59847 103.85017\n2012 101.83135  99.96547  98.23490  98.64730  97.23489\n2013  96.84385  97.95614  99.86479  98.42704  97.79728\n2014  96.12996  99.28707  98.34888  97.27581  99.01780\n2015 102.05354 101.35873 100.66252 100.76102 100.45864\n2016 101.62022 100.64268  98.76241 100.83623 102.82647\n2017 103.73341 103.82246 105.29816 106.59767 105.53516\n2018 105.03058 103.00706 104.49092 104.89205 103.66170\n2019 102.63605 104.04393 104.58566 101.77858 101.58827\n\n\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nToujours avec la même spécification, extraire les révisions de la séries désaisonnalisée du point de janvier 2005 (i.e. : série désaisonnalisée lorsqu’on a les données jusqu’en janvier 2005, puis jusqu’en février 2005, etc.).\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nRécupérer l’ensemble des dates de fin d’estimation avec la fonction window(time(ipi_c_eu[, \"FR\"]), start = 2005).\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ndates &lt;- as.numeric(window(time(ipi_c_eu[, \"FR\"]), start = 2005))\nestimations &lt;- sapply(dates, function(last_date_estimation){\n    myjsa &lt;- jx13(window(ipi_c_eu[, \"FR\"], end = last_date_estimation), spec_sans_easter)\n    sa &lt;- get_indicators(myjsa, \"sa\")$sa\n    window(sa, start = 2005, end = 2005) # Pour ne récupérer que la valeur en 2005\n})\nestimations &lt;- ts(estimations, start = 2005, frequency = 12)\nplot(estimations)"
  },
  {
    "objectID": "TP/R_2_CJO_v2.html",
    "href": "TP/R_2_CJO_v2.html",
    "title": "2 - Correction des jours ouvrables",
    "section": "",
    "text": "L’objectif de ce TP est d’apprendre à créer des régresseurs jours ouvrables personnalisés, à les utiliser dans RJDemetra/JDemetra+ et à vérifier la qualité de la correction.\nPour installer tous les packages utiles de ce TP, lancer le programme :\npackages_to_install &lt;- c(\"RJDemetra\", \"rjd3toolkit\", \"rjd3x13\", \"rjd3tramoseats\", \"rjd3providers\", \"rjd3workspace\")\n\npackages &lt;- packages_to_install[! packages_to_install %in% installed.packages()[,\"Package\"]]\nif (length(packages) &gt; 0) {\n    install.packages(\n      packages, \n      repos = c(\"https://aqlt.r-universe.dev\", \"https://cloud.r-project.org\")\n      )\n}\nPour créer des régresseurs jours ouvrables personnalisés, deux solutions :\nDans ce TP, nous nous intéresserons uniquement à la seconde option. En effet, le package R est plus flexible et permet de créer des régresseurs moins classiques que les working days et trading days."
  },
  {
    "objectID": "TP/R_2_CJO_v2.html#création-dun-calendrier",
    "href": "TP/R_2_CJO_v2.html#création-dun-calendrier",
    "title": "2 - Correction des jours ouvrables",
    "section": "1.1 Création d’un calendrier",
    "text": "1.1 Création d’un calendrier\nPar défaut, les régresseurs jours ouvrables de JDemetra+ ne prennent pas en compte les spécificité calendaires des pays : on ne prend pas en compte les jours fériés. Pour les prendre en compte, il faut créer son propre calendrier où l’on supposera qu’un jour férié de plus dans le mois a le même effet qu’un dimanche.\n\nlibrary(rjd3toolkit)\n\nTrois fonctions peuvent être utilisées pour ajouter des jours fériés :\n\nfixed_day() pour ajouter un jour férié qui tombe à date fixe. Par exemple, pour ajouter le 8 mai :\n\n\nfixed_day(month =  5, day = 8)\n\n\neaster_day() pour ajouter un jour férié dont le jour dépend de Pâques : le paramètre offset permet de spécifier le nombre de jours avant (si négatif) ou après Pâques (si positif). Par exemple, pour ajouter la Pentecôte qui a lieu 60 jours après Pâques :\n\n\neaster_day(offset = 60)\n\n\nsingle_day() pour ajouter un jour ferié qui n’a eu lieu qu’une seule fois.\n\n\nsingle_day(\"1993-01-15\")\n\n\nfixed_week_day() qui permet d’ajouter des jours fériés qui apparaissent certaines semaines de certains mois (par exemple le premier lundi du mois de septembre aux USA)\n\n\nfixed_week_day(9, 1, 1) # first Monday(1) of September.\n\n\nspecial_day() qui permet d’ajouter des jours fériés par rapport à des dates déjà connues dans JDemetra+ (voir tableau ci-dessous). Comme pour la fonction easter_day(), le paramètre offset permet de spécifier la position du jour voulu par rapport rapport à la fête pré-spécifié (par défaut offset = 0, le jour férié coïncide avec le jour pré-spécifié). Par exemple, pour ajouter le nouvel an :\n\n\nspecial_day(\"NEWYEAR\")\n\n\n\n\n\nJours pré-spécifiés\n\n\nEvent\nDéfinition\n\n\n\n\nNEWYEAR\nFête fixe, 1er janvier.\n\n\nSHROVEMONDAY\nFête mobile, lundi avant le mecredi des cendres (48 jours avant pâques).\n\n\nSHROVETUESDAY\nFête mobile, mardi avant le mecredi des cendres (47 jours avant pâques).\n\n\nASHWEDNESDAY\nFête mobile, 46 jours avant Pâques.\n\n\nEASTER\nFête mobile, Pâques, varie entre le 22 mars et le 25 avril.\n\n\nMAUNDYTHURSDAY\nFête mobile, le jeudi avant Pâques.\n\n\nGOODFRIDAY\nFête mobile, le vendredi avant Pâques.\n\n\nEASTERMONDAY\nFête mobile, le lendemain de Pâques.\n\n\nASCENSION\nFête mobile, célébrée un jeudi, 40 jours après Pâques.\n\n\nPENTECOST\nFête mobile, 50 jours après Pâques.\n\n\nCORPUSCHRISTI\nFête mobile, 60 jours après Pâques.\n\n\nWHITMONDAY\nFête mobile, le jour après la Pentecôte.\n\n\nMAYDAY\nFête fixe, 1er mai.\n\n\nASSUMPTION\nFête fixe, 15 août.\n\n\nHALLOWEEN\nFête fixe, 31 octobre.\n\n\nALLSAINTSDAY\nFête fixe, 1er novembre.\n\n\nARMISTICE\nFête fixe, 11 novembre.\n\n\nCHRISTMAS\nFête fixe, 25 décembre.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nCréer un calendrier qui contient tous les jours fériés de votre pays.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nDeux exemples :\n\nCalendrier associé à la France :\n\n\nFR &lt;- list(\n    special_day(\"NEWYEAR\"),\n    special_day(\"EASTERMONDAY\"), # Lundi de Pâques\n    special_day(\"MAYDAY\"), # 1er mai\n    special_day(\"ASCENSION\"), # Jour de l'Ascension\n    fixed_day(5, 8),\n    special_day(\"WHITMONDAY\"), # Lundi de Pentecôte\n    fixed_day(7, 14),\n    special_day(\"ASSUMPTION\"), # Assomption\n    special_day(\"ALLSAINTSDAY\"), # Toussaint\n    special_day(\"ARMISTICE\")\n)\nCAL &lt;- national_calendar(FR)\n\n\nCalendrier associé à la Macronia, la difficulté étant qu’il faut ajouter à la main des jours associés aux fêtes musulmanes\n\n\njours_macronia &lt;- list(\n  special_day(\"NEWYEAR\"),\n    special_day(\"EASTERMONDAY\"), # Lundi de Pâques\n  fixed_day(4, 4), # Jour de l'indépendance de la Macronia\n  special_day(\"MAYDAY\"), # 1er mai\n  special_day(\"ASCENSION\"), # Jour de l'Ascension\n    special_day(\"WHITMONDAY\"), # Lundi de Pentecôte\n  special_day(\"ASSUMPTION\"), # Assomption de Marie\n    special_day(\"ALLSAINTSDAY\"), # Toussaint\n  special_day(\"CHRISTMAS\") # Noël\n)\n# # Manque Début ramadan et jours décrétés\n# # On récupère ces jours construisant un fichier Excel\n# jours_mobiles &lt;- readxl::read_excel(\"../data/DateFetesMusulmanes_Macronia.xlsx\") |&gt;\n#   as.data.frame()\n# jours_mobiles &lt;- jours_mobiles[,-1, drop = FALSE] # on enlève l'année\n\njours_macronia &lt;- c(\n  jours_macronia,\n  list(\n    # DEBUT_RAMADAN,\nsingle_day(\"2000-11-28\"),\nsingle_day(\"2001-11-17\"),\nsingle_day(\"2002-11-07\"),\nsingle_day(\"2003-10-27\"),\nsingle_day(\"2004-10-15\"),\nsingle_day(\"2005-10-05\"),\nsingle_day(\"2006-09-24\"),\nsingle_day(\"2007-09-14\"),\nsingle_day(\"2008-09-02\"),\nsingle_day(\"2009-08-22\"),\nsingle_day(\"2010-08-12\"),\nsingle_day(\"2011-08-01\"),\nsingle_day(\"2012-07-20\"),\nsingle_day(\"2013-07-10\"),\nsingle_day(\"2014-06-29\"),\nsingle_day(\"2015-07-18\"),\nsingle_day(\"2016-06-07\"),\nsingle_day(\"2017-05-27\"),\nsingle_day(\"2018-05-17\"),\nsingle_day(\"2019-05-06\"),\nsingle_day(\"2020-04-24\"),\nsingle_day(\"2021-04-14\"),\nsingle_day(\"2022-04-03\"),\nsingle_day(\"2023-03-23\"),\nsingle_day(\"2024-03-12\")\n  ))\n\nCAL &lt;- national_calendar(jours_macronia)"
  },
  {
    "objectID": "TP/R_2_CJO_v2.html#création-de-régresseurs-jo",
    "href": "TP/R_2_CJO_v2.html#création-de-régresseurs-jo",
    "title": "2 - Correction des jours ouvrables",
    "section": "1.2 Création de régresseurs JO",
    "text": "1.2 Création de régresseurs JO\nLe modèle général de correction de jours ouvrables peut s’écrire de la façon suivante : \\[\nX_t = \\sum_{i=1}^{7} \\alpha_i N_{it} + \\varepsilon_t\n\\] Avec :\n\n\\(N_{it}\\) le nombre de jours de lundis (\\(i=1\\)), …, dimanches et jours fériés (\\(i=7\\))\n\\(\\alpha_i\\) l’effet d’un jour de type \\(i\\)\n\nPour éviter les problèmes de multi-colinéarité, on réécrit le modèle en utilisant une modalité de référence (ici dimanche). On désaisonnalise également les régresseurs en enlevant la moyenne de long-terme : \\[X_t =  \\sum_{i=1}^{6} \\beta_i (N_{it} - N_{7t}) +\n\\bar{\\alpha} \\underbrace{(N_t - \\bar{N}_t)}_{LY_t} +  \\varepsilon_t\\] Ce modèle peut être simplifié si en faisant des hypothèses sur les effets des jours ouvrés :\n\nL’hypothèse working days correspond au cas où l’on suppose que tous les jours de la semaine (lundi à vendredi) ont le même effet (\\(\\alpha_1=\\dots=\\alpha_5\\)), les samedis et les dimanches (et jours fériés) ont le même effet (\\(\\alpha_6=\\alpha_7\\)) et sont utilisés en tant que variable de contraste.\nL’hypothèse trading days correspond au cas où l’on suppose que tous les jours ont un effet différent et les dimanches (et jours fériés) sont utilisés en tant que variable de constrate.\n\nSous JDemetra+ on ne peut utiliser que ces deux hypothèses mais rjd3toolkit permet de construire d’autres types de JO.\nDe manière plus générale, lorsque l’on utilise une variable de contraste, les régresseurs \\(CJO_{t,i}\\) associé au groupe \\(i\\) est calculé de la façon suivante : \\[\nCJO_{t,i} = \\underbrace{\\sum_{j\\in\\text{groupe }i}N_{jt}}_{\n\\text{nb de jours du groupe }i\n} -\n\\frac{\\sum_{j\\in\\text{groupe }i}1}{\\sum_{j\\in\\text{groupe }0}1}\n\\times\n\\underbrace{\\sum_{j\\in\\text{groupe }0}N_{jt}}_{\n\\text{nb de jours du groupe contraste}\n}\n\\] Dans le cas working days, il y a 2 jours dans le groupe contraste (samedi et dimanche, \\(\\sum_{j\\in\\text{groupe }0}1=2\\)) et 5 jours dans le groupe 1 (lundi à vendredi, \\(\\sum_{j\\in\\text{groupe }1}1=5\\)). Au mois \\(t\\), le régresseurs JO type de jours est donc égal au nombre de jours de la semaine dans le mois, mois \\(5/2\\times\\) nombre de jours de week-end.\nLes régresseurs JO peuvent être créés à partir de 2 fonctions : htd() qui permet de les créer à partir d’un calendrier spécifique et td(). Dans ces fonctions, le paramètre le plus important est groups pour permet de faire des hypothèses sur les jours. C’est un vecteur de longueur 7 (le nombre de jours de la semaine) dont chaque élément indique à quel groupe le jour de la semaine associé correspond. La variable de contraste est associé au groupe 0.\nPar exemple, groups = c(1,2,3,4,5,6,0) correspond au trading days et groups = c(1,1,1,1,1,0,0) correspond au working days.\nPar exemple :\n\ngroups &lt;- c(1, 2, 3, 4, 5, 6, 0)\nfrequency &lt;- 12\nstart &lt;- c(2000,1)\nwkd &lt;- calendar_td(CAL, frequency = frequency, start = start, length = 12*35,\n                   groups = groups)\nwkd &lt;- ts(wkd, start = start, frequency = frequency)\n\n\n\n\n\n\n\nExercice\n\n\n\nComparer le régresseurs JO working days créé avec personnalisé et celui sans hypothèse sur les jours fériés (fonction td()).\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nLes régresseurs sont bien différents :\n\ngroups &lt;- c(1, 1, 1, 1, 1, 0, 0)\nfrequency &lt;- 12\nstart &lt;- c(2000,1)\nwkd &lt;- calendar_td(CAL, frequency = frequency, start = start, length = 12*35,\n                   groups = groups)\nwkd_def &lt;- td(frequency = frequency, start = start, length = 12*35,\n              groups = groups)\nround(wkd - wkd_def,1)\n\n      Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec\n2000  2.5  0.0  0.7 -1.7  4.5 -5.5  0.0 -1.0  0.0  0.0 -4.5 -1.0\n2001 -1.0  0.0  0.7 -1.7  1.0 -2.0  0.0 -1.0  0.0  0.0 -1.0 -1.0\n2002 -1.0  0.0  0.7 -1.7 -2.5  1.5  0.0 -1.0  0.0  0.0 -4.5 -1.0\n2003 -1.0  0.0  0.7 -1.7  1.0 -2.0  0.0 -1.0  0.0 -3.5  2.5 -1.0\n2004 -1.0  0.0  0.7  1.8  1.0  1.5  0.0  2.5  0.0 -3.5 -1.0  2.5\n2005  2.5  0.0 -2.8  1.8  1.0  1.5  0.0 -1.0  0.0 -3.5 -1.0  2.5\n2006  2.5  0.0  0.7 -1.7  1.0 -2.0  0.0 -1.0  0.0  0.0 -1.0 -1.0\n2007 -1.0  0.0  0.7 -1.7 -2.5  1.5  0.0 -1.0 -3.5  0.0 -1.0 -1.0\n2008 -1.0  0.0 -2.8  1.8  1.0  1.5  0.0 -1.0 -3.5  0.0  2.5 -1.0\n2009 -1.0  0.0  0.7  1.8  1.0 -2.0  0.0  2.5  0.0  0.0  2.5 -1.0\n2010 -1.0  0.0  0.7  1.8  1.0  1.5  0.0 -1.0  0.0  0.0 -1.0  2.5\n2011  2.5  0.0  0.7 -1.7  8.0 -5.5  0.0 -4.5  0.0  0.0 -1.0  2.5\n2012  2.5  0.0  0.7 -1.7 -2.5  1.5 -3.5 -1.0  0.0  0.0 -1.0 -1.0\n2013 -1.0  0.0  0.7 -1.7 -2.5  1.5 -3.5 -1.0  0.0  0.0 -1.0 -1.0\n2014 -1.0  0.0  0.7 -1.7  1.0 -2.0  0.0 -1.0  0.0  0.0  2.5 -1.0\n2015 -1.0  0.0  0.7  1.8 -2.5  1.5  0.0  2.5  0.0  0.0  2.5 -1.0\n2016 -1.0  0.0 -2.8  1.8  1.0 -2.0  0.0 -1.0  0.0  0.0 -1.0  2.5\n2017  2.5  0.0  0.7 -1.7  1.0 -2.0  0.0 -1.0  0.0  0.0 -1.0 -1.0\n2018 -1.0  0.0  0.7 -1.7 -6.0  1.5  0.0 -1.0  0.0  0.0 -1.0 -1.0\n2019 -1.0  0.0  0.7 -1.7 -2.5 -2.0  0.0 -1.0  0.0  0.0 -1.0 -1.0\n2020 -1.0  0.0  0.7 -1.7  1.0 -2.0  0.0  2.5  0.0  0.0  2.5 -1.0\n2021 -1.0  0.0  0.7 -1.7  1.0  1.5  0.0  2.5  0.0  0.0 -1.0  2.5\n2022  2.5  0.0  0.7 -1.7  4.5 -2.0  0.0 -1.0  0.0  0.0 -1.0  2.5\n2023  2.5  0.0 -2.8 -1.7 -2.5  1.5  0.0 -1.0  0.0  0.0 -1.0 -1.0\n2024 -1.0  0.0 -2.8 -1.7 -2.5  1.5  0.0 -1.0  0.0  0.0 -1.0 -1.0\n2025 -1.0  0.0  0.7 -1.7  1.0 -2.0  0.0 -1.0  0.0  0.0  2.5 -1.0\n2026 -1.0  0.0  0.7  1.8 -2.5  1.5  0.0  2.5  0.0  0.0  2.5 -1.0\n2027 -1.0  0.0 -2.8  5.3  1.0  1.5  0.0  2.5  0.0  0.0 -1.0  2.5\n2028  2.5  0.0  0.7 -1.7  1.0 -2.0  0.0 -1.0  0.0  0.0 -1.0 -1.0\n2029 -1.0  0.0  0.7 -1.7 -2.5  1.5  0.0 -1.0  0.0  0.0 -1.0 -1.0\n2030 -1.0  0.0  0.7 -1.7  1.0 -2.0  0.0 -1.0  0.0  0.0 -1.0 -1.0\n2031 -1.0  0.0  0.7 -1.7  1.0 -2.0  0.0 -1.0  0.0  0.0  2.5 -1.0\n2032 -1.0  0.0 -2.8  5.3  1.0  1.5  0.0  2.5  0.0  0.0 -1.0  2.5\n2033  2.5  0.0  0.7 -1.7  4.5 -2.0  0.0 -1.0  0.0  0.0 -1.0  2.5\n2034  2.5  0.0  0.7 -1.7 -2.5  1.5  0.0 -1.0  0.0  0.0 -1.0 -1.0"
  },
  {
    "objectID": "TP/R_2_CJO_v2.html#régresseur-leap-year",
    "href": "TP/R_2_CJO_v2.html#régresseur-leap-year",
    "title": "2 - Correction des jours ouvrables",
    "section": "1.3 Régresseur leap year",
    "text": "1.3 Régresseur leap year\nLe régresseur année bissextile (leap year), \\(LY_t\\) doit être créé à la main. Il est égal à la différence entre le nombre de jours dans le mois \\(t\\) et le nombre de jours moyens dans le mois \\(t\\), \\(\\bar N_t\\). Tous les mois ont le même nombre de jours, sauf le mois de février qui est de 29 jours tous les 4 ans. \\(\\bar N_t\\) est donc égal à 30 ou 31 si le mois considéré n’est pas un mois de février (et donc \\(N_t - \\bar N_t=0\\)) à 28,25 en février1. \\[\nLY_{t} =\n\\begin{cases}\n0,75 & \\mbox{si } t \\mbox{ est un mois de février bissextil } \\\\\n-0,25 & \\mbox{si } t \\mbox{ est un mois de février non bissextil } \\\\\n0 & \\mbox{sinon}\n\\end{cases}\n\\]\n\n\n\n\n\n\nExercice\n\n\n\nCréer une fonction leap_year qui permet de générer le régresseur leap year.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nleap_year &lt;- function(start = 1990, end = 2030, frequency = 12){\n    ly &lt;- ts(0, start = start, end = end, frequency = 12)\n    mois_feb &lt;- cycle(ly) == 2\n    annees &lt;- trunc(round(time(ly), 3)) # arrondi car parfois des pbs avec fonction time\n    # On utilise la définition exacte\n    is_ly &lt;- (annees %% 400 == 0) |\n        ((annees %% 4 == 0) & (annees %% 100 != 0))\n    ly[mois_feb] &lt;- 28 - 28.2425\n    ly[mois_feb & is_ly] &lt;- 29 - 28.2425\n    # on change si besoin la fréquence\n    stats::aggregate(ly, nfrequency = frequency) \n}\nleap_year(frequency = 12)\n\n         Jan     Feb     Mar     Apr     May     Jun     Jul     Aug     Sep\n1990  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1991  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1992  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1993  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1994  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1995  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1996  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1997  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1998  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n1999  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2000  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2001  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2002  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2003  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2004  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2005  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2006  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2007  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2008  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2009  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2010  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2011  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2012  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2013  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2014  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2015  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2016  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2017  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2018  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2019  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2020  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2021  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2022  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2023  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2024  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2025  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2026  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2027  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2028  0.0000  0.7575  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2029  0.0000 -0.2425  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000\n2030  0.0000                                                                \n         Oct     Nov     Dec\n1990  0.0000  0.0000  0.0000\n1991  0.0000  0.0000  0.0000\n1992  0.0000  0.0000  0.0000\n1993  0.0000  0.0000  0.0000\n1994  0.0000  0.0000  0.0000\n1995  0.0000  0.0000  0.0000\n1996  0.0000  0.0000  0.0000\n1997  0.0000  0.0000  0.0000\n1998  0.0000  0.0000  0.0000\n1999  0.0000  0.0000  0.0000\n2000  0.0000  0.0000  0.0000\n2001  0.0000  0.0000  0.0000\n2002  0.0000  0.0000  0.0000\n2003  0.0000  0.0000  0.0000\n2004  0.0000  0.0000  0.0000\n2005  0.0000  0.0000  0.0000\n2006  0.0000  0.0000  0.0000\n2007  0.0000  0.0000  0.0000\n2008  0.0000  0.0000  0.0000\n2009  0.0000  0.0000  0.0000\n2010  0.0000  0.0000  0.0000\n2011  0.0000  0.0000  0.0000\n2012  0.0000  0.0000  0.0000\n2013  0.0000  0.0000  0.0000\n2014  0.0000  0.0000  0.0000\n2015  0.0000  0.0000  0.0000\n2016  0.0000  0.0000  0.0000\n2017  0.0000  0.0000  0.0000\n2018  0.0000  0.0000  0.0000\n2019  0.0000  0.0000  0.0000\n2020  0.0000  0.0000  0.0000\n2021  0.0000  0.0000  0.0000\n2022  0.0000  0.0000  0.0000\n2023  0.0000  0.0000  0.0000\n2024  0.0000  0.0000  0.0000\n2025  0.0000  0.0000  0.0000\n2026  0.0000  0.0000  0.0000\n2027  0.0000  0.0000  0.0000\n2028  0.0000  0.0000  0.0000\n2029  0.0000  0.0000  0.0000\n2030                        \n\n# ou rjd3toolkit::lp_variable()\n\nOn peut également uiliser la fonction rjd3toolkit::ts_adjust() pour préajuster de l’effet année bissextile."
  },
  {
    "objectID": "TP/R_2_CJO_v2.html#exercice-bilan",
    "href": "TP/R_2_CJO_v2.html#exercice-bilan",
    "title": "2 - Correction des jours ouvrables",
    "section": "1.4 Exercice bilan",
    "text": "1.4 Exercice bilan\n\n\n\n\n\n\nExercice\n\n\n\nCréer un objet regresseurs_JO qui contiendra tous les jeux de régresseurs plausibles. Par exemple :\n\nle régresseur leap year\nle jeu de régresseur trading days (TD7, lundi à samedi, dimanche = contraste)\nle jeu de régresseur working days (TD2, lundi =… = vendredi, samedi=dimanche=contraste)\nle jeu TD3 : lundi = … = vendredi, samedi et dimanche = contraste\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nfrequency &lt;- 12\n\ngen_calendrier &lt;- function(cal, frequency, start = c(1990, 1), end = c(2030, 1)) {\n    length = (end[1] - start[1]) * frequency + end[2] - start[2]\n    ly &lt;- rjd3toolkit::lp_variable(frequency = frequency, start = start,\n                                   length = length)\n    # N'hésitez pas à ajouter les votres !\n    TD7 &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                       groups = c(1, 2, 3, 4, 5, 6, 0))\n    TD4 &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                       groups = c(1, 1, 1, 1, 2, 3, 0))\n    TD3 &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                       groups = c(1, 1, 1, 1, 1, 2, 0))\n    TD3c &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                        groups = c(1, 1, 1, 1, 2, 2, 0))\n    TD2 &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                       groups = c(1, 1, 1, 1, 1, 0, 0))\n    TD2c &lt;- calendar_td(cal, frequency = frequency, start = start, length = length,\n                        groups = c(1, 1, 1, 1, 1, 1, 0))\n    \n    reg_jo &lt;- ts(cbind(TD2, TD2c, TD3, TD3c, TD4, TD7),\n                 start = start, frequency = frequency)\n    reg_jo &lt;- ts.intersect(reg_jo,\n                           ly)\n    colnames(reg_jo) &lt;- c(\n        \"TD2_semaine\",\n        \"TD2c_lundi_samedi\",\n        sprintf(\"TD3_%s\", c(\"semaine\", \"samedi\")),\n        sprintf(\"TD3c_%s\", c(\"lundi_jeudi\", \"vendredi_samedi\")),\n        sprintf(\"TD4_%s\", c(\"lundi_jeudi\", \"vendredi\", \"samedi\")),\n        sprintf(\"TD7_%s\", c(\"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\")),\n        \"leap_year\")\n    reg_jo\n}\n\nregresseurs_JO_mens &lt;- gen_calendrier(CAL, frequency = 12)\nregresseurs_JO_trim &lt;- gen_calendrier(CAL, frequency = 4)\n# Si l'on utilise des séries mensuelles :\nregresseurs_JO &lt;- regresseurs_JO_mens\n\nSi l’on veut jongler entre R et JDemetra+, il faut ajouter les nouvelles variables dans le dictionnaire de variables de JDemetra+, voir le TP associé. Une solution est de créer un workspace vide depuis R et de l’utiliser pour charger vos données. Ci-dessous un code qui vous permet d’exporter ce workspace :\n\n# On va créer un nouveau workspace où l'on va ajouter les nouvelles variables\nlibrary(RJDemetra)\nlibrary(rJava)\ncomplete_variables &lt;- function(liste_var, workspace){\n    if(!is.mts(liste_var))\n        stop(\"liste_var doit être de type mts\")\n    context_dictionary &lt;- .jcall(workspace,\"Lec/tstoolkit/algorithm/ProcessingContext;\", \"getContext\")\n    ts_variable_managers &lt;- context_dictionary$getTsVariableManagers()\n    ts_variables &lt;- .jnew(\"ec/tstoolkit/timeseries/regression/TsVariables\")\n    jd_r_variables &lt;- ts_variable_managers$get(\"r\")\n    if (is.null(jd_r_variables)) {\n        ts_variable_managers$set(\"r\",\n                                 .jnew(\"ec/tstoolkit/timeseries/regression/TsVariables\"))\n        jd_r_variables &lt;- ts_variable_managers$get(\"r\")\n    }\n    jd_var_names &lt;- jd_r_variables$getNames()\n    \n    model_var_names &lt;- colnames(liste_var)\n    \n    for (i in seq_along(model_var_names)) {\n        name &lt;- model_var_names[i]\n        dictionary_var &lt;- jd_r_variables$get(name)\n        tsvar &lt;- .jnew(\"ec/tstoolkit/timeseries/regression/TsVariable\",\n                       name, RJDemetra:::ts_r2jd(liste_var[, i]))\n        if (is.null(dictionary_var)) {\n            jd_r_variables$set(name, tsvar)\n        } else {\n            warning(sprintf(\"La variable %s existe déjà\", name))\n        }\n    }\n}\n# On renmme les variables pour éviter des conflits sur les noms\ncolnames(regresseurs_JO_trim) &lt;- paste0(colnames(regresseurs_JO_trim), \"_trim\")\ncolnames(regresseurs_JO_mens) &lt;- paste0(colnames(regresseurs_JO_mens), \"_mens\")\n# Création d'un nouveaux\njws &lt;- new_workspace()\n# regresseurs_JO est l'objet mts qui contient tous vos régresseurs\n# Il doit donc déjà être créé (voir code ci-dessus) !\ncomplete_variables(regresseurs_JO_mens, jws)\ncomplete_variables(regresseurs_JO_trim, jws)\nsave_workspace(jws,\"wk_CJO.xml\")"
  },
  {
    "objectID": "TP/R_2_CJO_v2.html#effet-graduel-de-pâques",
    "href": "TP/R_2_CJO_v2.html#effet-graduel-de-pâques",
    "title": "2 - Correction des jours ouvrables",
    "section": "1.5 Effet graduel de Pâques",
    "text": "1.5 Effet graduel de Pâques\nPrenons l’exemple de la vente de chocolats. Il est assez commun d’offrir des chocolats à Pâques : il y a donc une hausse des ventes autour du lundi de Pâques. Toutefois, ces ventes ne se font pas le jour de Pâques mais plusieurs jours avant, et plus on se rapproche du jour J, plus ces ventes sont importantes. C’est ce que l’on appel l’effet graduel de Pâques. Sous JDemetra+ on peut définir le nombre de jours avant Pâques pour lequel on considère qu’il y a un effet (easter_day.duration, entre 1 et 20) ou laisser ce choix à JDemetra+.\n\n\n\n\n\n\nExercice\n\n\n\nSerait-il pertinent de considérer un effet graduel de Noël dans le modèle Reg-ARIMA ?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nNon car l’effet graduel de Noël est en fait saisonnier car c’est un jour fixe ! Pour Pâques, comme c’est une fête mobile, les jours précédents peuvent être dans des mois différents en fonction de l’année considérée. Je ne suis pas entré dans les détails mais le régresseur utilisé pour la correction de l’effet graduel de Pâques est désaisonnalisé pour ne prendre en compte que l’effet voulu\n\n\n\nLe régresseur associé à l’effet graduel de Pâques peut être généré en utilisant la fonction rjd3toolkit::easter_variable()."
  },
  {
    "objectID": "TP/R_2_CJO_v2.html#footnotes",
    "href": "TP/R_2_CJO_v2.html#footnotes",
    "title": "2 - Correction des jours ouvrables",
    "section": "Notes de bas de page",
    "text": "Notes de bas de page\n\n\n En réalité, la vraie valeur est 28,2425. En effet, une année bissextile est une année divisible par 4 mais pas par 100, sauf si elle est divisible par 400 : 1900 n’était pas une année bissextile mais 2000 l’était !↩︎\n Vous remarquerez que le résultat est différent de celui affiché dans JDemetra+ : cela vient de la méthode d’estimation du test utilisée !↩︎\n Vous pouvez également utiliser le code vu dans la section 2 pour estimer un modèle automatique.↩︎"
  },
  {
    "objectID": "TP/R_3_Preadjustment_v2.html",
    "href": "TP/R_3_Preadjustment_v2.html",
    "title": "3 - Qualité du préajustement sous R",
    "section": "",
    "text": "L’objectif de ce TP est d’apprendre à vérifier la qualité du pré-ajustement dans RJDemetra.\n\nPour installer tous les packages utiles de ce TP, lancer le programme :\n\npackages_to_install &lt;- c(\"RJDemetra\")\n\npackages &lt;- packages_to_install[! packages_to_install %in% installed.packages()[,\"Package\"]]\nif (length(packages) &gt; 0) {\n        install.packages(\n      packages, repos = c(\"https://aqlt.r-universe.dev\", \"https://cloud.r-project.org\")\n      )\n}\n\nPrenons une spécification par défaut :\n\nlibrary(RJDemetra)\nipi_fr &lt;- ipi_c_eu[, \"FR\"]\nmysa &lt;- RJDemetra::x13(ipi_fr)\n\nComme on l’a vu dans le TP2, les tests de Student peuvent être utilisés pour tester la significativité des coefficients, et on peut également faire des tests de Fisher avec le package car pour voir si l’on peut simplifier les régresseurs jours ouvrables. Voir également le TP2 pour les tests sur la présence de jours ouvrables résiduelle.\n\nsummary(mysa$regarima)\n\ny = regression model + arima (2, 1, 1, 0, 1, 1)\n\nModel: RegARIMA - X13\nEstimation span: from 1-1990 to 12-2020\nLog-transformation: no\nRegression model: no mean, trading days effect(7), leap year effect, Easter effect, outliers(4)\n\nCoefficients:\nARIMA: \n            Estimate Std. Error  T-stat Pr(&gt;|t|)    \nPhi(1)     0.0003269  0.1077296   0.003   0.9976    \nPhi(2)     0.1688192  0.0740996   2.278   0.0233 *  \nTheta(1)  -0.5485606  0.1016550  -5.396 1.24e-07 ***\nBTheta(1) -0.6660849  0.0422242 -15.775  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nRegression model: \n              Estimate Std. Error  T-stat Pr(&gt;|t|)    \nMonday         0.55932    0.22801   2.453 0.014638 *  \nTuesday        0.88221    0.22832   3.864 0.000132 ***\nWednesday      1.03996    0.22930   4.535 7.85e-06 ***\nThursday       0.04943    0.22944   0.215 0.829549    \nFriday         0.91132    0.22988   3.964 8.88e-05 ***\nSaturday      -1.57769    0.22775  -6.927 1.99e-11 ***\nLeap year      2.15403    0.70527   3.054 0.002425 ** \nEaster [1]    -2.37950    0.45391  -5.242 2.71e-07 ***\nTC (4-2020)  -35.59245    2.17330 -16.377  &lt; 2e-16 ***\nAO (3-2020)  -20.89026    2.18013  -9.582  &lt; 2e-16 ***\nAO (5-2011)   13.49850    1.85694   7.269 2.28e-12 ***\nLS (11-2008) -12.54901    1.63554  -7.673 1.60e-13 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nResidual standard error: 2.218 on 342 degrees of freedom\nLog likelihood = -799.1, aic =  1632, aicc =  1634, bic(corrected for length) = 1.855\n\nlibrary(car)\n# On rejette l'hypothèse de nullité globale des coefficients\nlinearHypothesis(mysa,\n                 c(\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"),\n                 c(0, 0, 0, 0, 0, 0), test = \"F\")\n\n\nLinear hypothesis test:\nMonday = 0\nTuesday = 0\nWednesday = 0\nThursday = 0\nFriday = 0\nSaturday = 0\n\nModel 1: restricted model\nModel 2: mysa\n\n  Res.Df Df      F    Pr(&gt;F)    \n1    348                        \n2    342  6 83.415 &lt; 2.2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n# On pourrait rassembler les jours de la semaine :\nlinearHypothesis(mysa,\n                 c(\"Monday = Tuesday\",\"Tuesday = Wednesday\",\"\n                   Wednesday = Thursday\", \"Thursday = Friday\"), test = \"F\")\n\n\nLinear hypothesis test:\nMonday - Tuesday = 0\nTuesday - Wednesday = 0\nWednesday - Thursday = 0\nThursday - Friday = 0\n\nModel 1: restricted model\nModel 2: mysa\n\n  Res.Df Df      F  Pr(&gt;F)  \n1    346                    \n2    342  4 2.1504 0.07429 .\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nConcernant la qualité du modèle RegARIMA, on peut citer trois tests :\n\nLe test d’indépendance des résidus\nLe test d’homoscédasticité des résidus\nLe test de normalité des résidus\n\nCes trois tests, également disponibles par des fonctions spécifiques sous R (la commande residuals(mysa) permet de récupérer les résidus du modèle), sont également disponibles dans le sous objet .$regarima$residuals.stat$tests :\n\nmysa$regarima$residuals.stat$tests\n\n\nNormality\n         Statistic P.value    \nmean       0.12648  0.8994 ***\nskewness  -0.01954  0.8799 ***\nkurtosis   3.54844  0.0339    \n\nSignif. codes:  H0 (normality of residuals) is not rejected at \nsignificance levels: 0.1 ***0.05 **\n\nIndependence\n                                       Statistic P.value    \nljung box                               55.08622  0.0000    \nljung box (residuals at seasonal lags)   3.09960  0.2123 ***\n\nSignif. codes: H0 (independence of residuals) is not rejected at \nsignificance levels: 0.1 ***0.05 **\n\nLinearity\n                              Statistic P.value  \nljung box (squared residuals)  34.36237  0.0238  \n\nSignif. codes:  H0 (no conditional heteroscedasticity of residuals) is not rejected at \nsignificance levels: 0.1 ***0.05 **\n\n\nL’hétéroscédasticité et la non-normalité proviennent souvent de la présence de points atypiques non corrigés (pour jouer sur le seuil de détection, rajouter dans la spécification outlier.usedefcv = FALSE et prendre une valeur de outlier.cv inférieur à 4, qui est la valeur par défaut). Changer le schéma de décomposition peut aussi aider (transform.function = \"None\" pour un modèle additif ou transform.function = \"Log\" pour un modèle multiplicatif) :\n\nmysa2 &lt;- RJDemetra::x13(\n  ipi_fr, \n  RJDemetra::x13_spec(\n    mysa, outlier.usedefcv = FALSE,\n    outlier.cv = 3\n  )\n)\n# Bien plus d'outliers sont détectés !\nsummary(mysa2$regarima)\n\ny = regression model + arima (3, 1, 1, 0, 1, 1)\n\nModel: RegARIMA - X13\nEstimation span: from 1-1990 to 12-2020\nLog-transformation: no\nRegression model: no mean, trading days effect(7), leap year effect, Easter effect, outliers(28)\n\nCoefficients:\nARIMA: \n          Estimate Std. Error T-stat Pr(&gt;|t|)    \nPhi(1)     0.27920    0.09413  2.966  0.00322 ** \nPhi(2)     0.36429    0.07687  4.739 3.10e-06 ***\nPhi(3)     0.11811    0.07680  1.538  0.12496    \nTheta(1)  -0.63217    0.08106 -7.799 6.84e-14 ***\nBTheta(1) -0.34211    0.05369 -6.372 5.72e-10 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nRegression model: \n             Estimate Std. Error  T-stat Pr(&gt;|t|)    \nMonday         0.3870     0.1811   2.137 0.033265 *  \nTuesday        0.9721     0.1818   5.348 1.58e-07 ***\nWednesday      0.8970     0.1830   4.903 1.43e-06 ***\nThursday       0.1836     0.1826   1.006 0.315205    \nFriday         0.9678     0.1846   5.244 2.69e-07 ***\nSaturday      -1.6723     0.1829  -9.145  &lt; 2e-16 ***\nLeap year      1.7207     0.5026   3.423 0.000690 ***\nEaster [1]    -2.3262     0.3536  -6.578 1.68e-10 ***\nTC (4-2020)  -34.9803     1.3450 -26.007  &lt; 2e-16 ***\nAO (3-2020)  -20.5598     1.6847 -12.204  &lt; 2e-16 ***\nAO (5-2011)   11.6856     1.3242   8.825  &lt; 2e-16 ***\nLS (11-2008)  -9.4587     1.0474  -9.030  &lt; 2e-16 ***\nLS (1-2009)   -7.8963     1.0256  -7.699 1.34e-13 ***\nAO (6-2019)   -5.7932     1.4256  -4.064 5.94e-05 ***\nLS (8-2009)    5.7013     0.8196   6.957 1.66e-11 ***\nTC (1-2011)    5.6019     1.0501   5.334 1.70e-07 ***\nAO (5-2018)   -4.5600     1.3401  -3.403 0.000743 ***\nLS (5-2008)   -4.7919     0.7824  -6.125 2.38e-09 ***\nAO (5-2000)    5.2033     1.3250   3.927 0.000103 ***\nAO (6-2003)   -5.4817     1.3322  -4.115 4.81e-05 ***\nAO (5-1991)   -4.5123     1.3544  -3.332 0.000953 ***\nLS (5-1994)    3.2027     0.7772   4.121 4.69e-05 ***\nTC (12-2009)  -4.5311     1.0961  -4.134 4.44e-05 ***\nLS (3-1997)    3.5716     0.7567   4.720 3.38e-06 ***\nLS (1-1993)   -3.4933     0.7611  -4.590 6.15e-06 ***\nAO (8-2020)    6.3136     1.6987   3.717 0.000234 ***\nTC (11-2000)   5.8864     1.0215   5.762 1.79e-08 ***\nTC (8-2015)    3.5207     0.9715   3.624 0.000332 ***\nTC (12-1999)   4.4543     1.0307   4.322 2.01e-05 ***\nLS (10-1997)   2.7159     0.7569   3.588 0.000379 ***\nTC (12-1994)   4.2812     0.9973   4.293 2.27e-05 ***\nTC (10-2017)   3.9944     0.9801   4.076 5.65e-05 ***\nLS (11-2019)  -3.0752     0.9235  -3.330 0.000959 ***\nLS (2-2004)    2.1923     0.7651   2.865 0.004409 ** \nAO (6-2011)   -4.8397     1.3372  -3.619 0.000338 ***\nTC (11-2011)   4.0079     1.0178   3.938 9.88e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nResidual standard error: 1.627 on 317 degrees of freedom\nLog likelihood = -685.6, aic =  1455, aicc =  1467, bic(corrected for length) = 1.646\n\n\nLa qualité des prévisions peut également être vérifiée à travers plusieurs tests :\n\nEst-ce que la moyenne des erreurs prévisions in sample (i.e. : modèle estimé sur toute la période) et la moyenne des prévisions out of sample (i.e. : modèle estimé de manière dynamique en ajoutant une a à une les nouvelles données) sont nulles ? Ces tests sont sensibles à la non-normalité des résidus\nEst-ce que les variances des erreurs de prévision in sample et out of sample sont les mêmes ? Ce test est sensible à la non-normalité des résidus\nEst-ce qu’il y a “trop” d’outliers ? Dans JDemetra+, on considère par défaut qu’il y a trop d’outliers si la proportion d’outliers par rapport aux nombres d’observations est supérieure à 5 %.\n\nLes trois premiers tests ne sont pas par défaut exportés dans RJDemetra : il faut les rajouter à la main avec le paramètre userdefined. Ils seront alors disponibles dans la sous-liste .$user_defined. Concernant la proportion d’outliers, elle peut être calculée à la main à partir du nombre d’outliers (par exemple disponible dans .$regarima$model$spec_rslt) :\n\nmysa &lt;- RJDemetra::x13(\n  ipi_fr, RJDemetra::x13_spec(mysa),\n  userdefined = c(\"diagnostics.fcast-insample-mean\",\n                  \"diagnostics.fcast-outsample-mean\",\n                  \"diagnostics.fcast-outsample-variance\")\n)\nmysa$regarima$model$spec_rslt\n\n           Model                 T.span Log transformation  Mean Trading days\n1 RegARIMA - X13 from 1-1990 to 12-2020              FALSE FALSE            7\n  Leap year Easter Outliers\n1      TRUE   TRUE        4\n\n# Pour éviter outputs trop longs, l'affichage est réduit :\nmysa$user_defined\n\nNames of additional variables (3):\ndiagnostics.fcast-insample-mean, diagnostics.fcast-outsample-mean, diagnostics.fcast-outsample-variance\n\n# Pour supprimer cela, vous pouvez par exemple utiliser le code suivant :\nc(mysa$user_defined)\n\n$`diagnostics.fcast-insample-mean`\n[1] 0.3057321 0.7599958\nattr(,\"description\")\n[1] \"T with 340 degrees of freedom\"\n\n$`diagnostics.fcast-outsample-mean`\n[1] -0.7781656  0.4370126\nattr(,\"description\")\n[1] \"T with 340 degrees of freedom\"\n\n$`diagnostics.fcast-outsample-variance`\n[1] 1.1383576 0.3128808\nattr(,\"description\")\n[1] \"F with 18 degrees of freedom in the nominator and 341 degrees of freedom in the denominator\"\n\n\nVous pouvez bien sûr utiliser votre tests préféré à partir de ceux disponibles sous R (autre test de normalité…).\nPour comparer différents modèles, vous pouvez également utiliser les critères d’information (mais il faut que les modèles ARIMA aient les mêmes ordres de différenciation !). Vous pouvez pour cela utiliser les fonctions de bases de R (AIC(), BIC()…) ou prendre ceux de JDemetra+ (affichés lors du summary(), qu’on peut également retrouver par la commande .$regarima$loglik) :\n\nAIC(mysa)\n\n[1] 1632.169\n\nBIC(mysa)\n\n[1] 1698.185\n\n# Il y a un peu plus de critères que dans base R : AICc et BICc\nmysa$regarima$loglik\n\n                         \nlogvalue      -799.084484\nnp              17.000000\nneffectiveobs  359.000000\naic           1632.168967\naicc          1633.963689\nbic           1698.185448\nbicc             1.855018\n\n\n\n\n\n\n\n\nExercice\n\n\n\nPrenez une série et étudier la qualité du modèle RegARIMA. Essayer de changer quelques paramètres : est-ce que le nouveau modèle vous parait meilleur ou moins bien que l’ancien ?"
  },
  {
    "objectID": "TP/R_4_X11_v2.html",
    "href": "TP/R_4_X11_v2.html",
    "title": "4 - Qualité de la décomposition sous R",
    "section": "",
    "text": "L’objectif de ce TP est d’apprendre à étudier la qualité de la décomposition depuis RJDemetra.\nPour installer tous les packages utiles de ce TP, lancer le programme :\npackages_to_install &lt;- c(\n  \"RJDemetra\",\n  )\n\npackages &lt;- packages_to_install[! packages_to_install %in% installed.packages()[,\"Package\"]]\nif (length(packages) &gt; 0) {\n        install.packages(\n      packages, repos = c(\"https://aqlt.r-universe.dev\", \"https://cloud.r-project.org\")\n      )\n}\nDans ce TP nous allons voir différentes façon de vérifier la qualité de la décomposition. Tout d’abord, on peut commencer par regarder les statistiques m dont les définitions sont rappelées ci-dessous\nPoids\nDescription\nSi problème\n\n\n\n\nM1\n10\nContribution de l’irrégulier à la variance totale (stationnarisation par différence d’ordre 3). Si trop élevé, difficile d’extraire la saisonnalité.\nPoints atypiques ou taille des filtres\n\n\nM2\n11\nContribution de l’irrégulier à la variance totale (stationnarisation par une droite).\nPoints atypiques ou taille des filtres\n\n\nM3\n10\nMesuré à partir du ratio I/C. Si trop grand on aura du mal à séparer les deux composantes.\nPoints atypiques ou taille des filtres\n\n\nM4\n8\nTest autocorrélation sur l’irrégulier (réduire le filtre saisonnier).\nFiltre saisonnier plus court\n\n\nM5\n11\nMesuré à partir du MCD (nombre de mois nécessaires pour que les variations absolues de la TC l’emporte sur I).\nPoints atypiques\n\n\nM6\n10\nVérifie si la moyenne mobile M3x5 est appropriée (\\(1.5 &lt; I/S &lt; 6.5\\)).\nPrendre filtre plus long\n\n\nM7\n18\nPermet de voir si la saisonnalité est identifiable (compare part relative de la saisonnalité stable et mobile).\nSchéma multiplicatif ?\n\n\nM8\n7\nMesure l’évolution de la S de court terme.\nChanger filtre saisonnier\n\n\nM9\n7\nMesure l’évolution de la S de long terme.\nChanger filtre saisonnier\n\n\nM10\n4\nM8 sur dernières années (\\(N-2\\) à \\(N-5\\)).\nChanger filtre saisonnier\n\n\nM11\n4\nM9 sur dernières années (\\(N-2\\) à \\(N-5\\)).\nChanger filtre saisonnier\nPrenons une spécification par défaut :\nlibrary(RJDemetra)\nipi_fr &lt;- ipi_c_eu[, \"FR\"]\nmysa &lt;- RJDemetra::x13(ipi_fr, \"RSA4\")\nÀ partir d’un objet \"X13\", les statistiques m disponibles dans la sous-liste .$decomposition :\nmysa$decomposition\n\nMonitoring and Quality Assessment Statistics:\n      M stats\nM(1)    0.127\nM(2)    0.079\nM(3)    1.094\nM(4)    0.558\nM(5)    1.093\nM(6)    0.022\nM(7)    0.085\nM(8)    0.242\nM(9)    0.064\nM(10)   0.261\nM(11)   0.247\nQ       0.355\nQ-M2    0.389\n\nFinal filters: \nSeasonal filter:  3x5\nTrend filter:  13 terms Henderson moving average\nAlors que pour changer le filtre saisonnier il suffit d’utiliser le paramètre x11.seasonalma, pour changer la longueur du filtre de Henderson il faut désactiver l’option de recherche automatique de la longueur du filtre (x11.trendAuto = FALSE) et spécifier la longueur dans le paramètre x11.trendma:\nnew_spec &lt;- x13_spec(mysa, x11.trendma = 15)\nnew_spec$x11# Colonne trendma inchangée !\n\n            x11.mode x11.seasonalComp x11.lsigma x11.usigma x11.trendAuto\nPredefined Undefined             TRUE        1.5        2.5          TRUE\nUser_modif      &lt;NA&gt;               NA         NA         NA            NA\nFinal      Undefined             TRUE        1.5        2.5          TRUE\n           x11.trendma x11.seasonalma x11.fcasts x11.bcasts x11.calendarSigma\nPredefined          13            Msr         -1          0              None\nUser_modif          15           &lt;NA&gt;         NA         NA              &lt;NA&gt;\nFinal               13            Msr         -1          0              None\n           x11.sigmaVector x11.excludeFcasts\nPredefined              NA             FALSE\nUser_modif              NA                NA\nFinal                   NA             FALSE\n\nnew_spec &lt;- x13_spec(mysa, x11.trendma = 15, x11.trendAuto = FALSE)\nnew_spec$x11\n\n            x11.mode x11.seasonalComp x11.lsigma x11.usigma x11.trendAuto\nPredefined Undefined             TRUE        1.5        2.5          TRUE\nUser_modif      &lt;NA&gt;               NA         NA         NA         FALSE\nFinal      Undefined             TRUE        1.5        2.5         FALSE\n           x11.trendma x11.seasonalma x11.fcasts x11.bcasts x11.calendarSigma\nPredefined          13            Msr         -1          0              None\nUser_modif          15           &lt;NA&gt;         NA         NA              &lt;NA&gt;\nFinal               15            Msr         -1          0              None\n           x11.sigmaVector x11.excludeFcasts\nPredefined              NA             FALSE\nUser_modif              NA                NA\nFinal                   NA             FALSE\nSur la qualité de la décomposition, la sous liste .$diagnostics contient les contributions des différentes composantes à la variance de la série, le test combiné et les tests sur la saisonnalité et jours ouvrables résiduels :\nmysa$diagnostics\n\nRelative contribution of the components to the stationary\nportion of the variance in the original series,\nafter the removal of the long term trend\n Trend computed by Hodrick-Prescott filter (cycle length = 8.0 years)\n           Component\n Cycle         1.830\n Seasonal     51.089\n Irregular     0.927\n TD & Hol.     2.179\n Others       44.916\n Total       100.941\n\nCombined test in the entire series\n Non parametric tests for stable seasonality\n                                                          P.value\n   Kruskall-Wallis test                                      0.000\n   Test for the presence of seasonality assuming stability   0.000\n   Evolutive seasonality test                                0.014\n \n Identifiable seasonality present\n\nResidual seasonality tests\n                                      P.value\n qs test on sa                          0.924\n qs test on i                           0.643\n f-test on sa (seasonal dummies)        0.671\n f-test on i (seasonal dummies)         0.453\n Residual seasonality (entire series)   0.415\n Residual seasonality (last 3 years)    0.954\n f-test on sa (td)                      0.091\n f-test on i (td)                       0.333\nCes tests sont effectués sur l’ensemble de la série, alors que dans le main result le f-test est effectué sur les 8 dernières années. Il n’est pour l’instant pas possible d’exporter les tests de saisonnalité résiduelle sur les 8 ou 10 dernières années. À partir du packages rjd3toolkit il est en revanche possible de calculer tous les tests à l’exception du f-test1.\nPar rapport aux éléments vus en cours, les msr par mois sont exportables en utilisant le paramètre userdefined de `x13 :\nmysa &lt;- RJDemetra::x13(ipi_fr, \n            userdefined = c(\"diagnostics.msr-global\",\n                            sprintf(\"diagnostics.msr(%i)\", 1:12)))\nc(mysa$user_defined)\n\n$`diagnostics.msr-global`\n[1] 4.224309\n\n$`diagnostics.msr(1)`\n[1] 6.918248\n\n$`diagnostics.msr(2)`\n[1] 4.679206\n\n$`diagnostics.msr(3)`\n[1] 4.351482\n\n$`diagnostics.msr(4)`\n[1] 5.808313\n\n$`diagnostics.msr(5)`\n[1] 4.446801\n\n$`diagnostics.msr(6)`\n[1] 3.175827\n\n$`diagnostics.msr(7)`\n[1] 5.102764\n\n$`diagnostics.msr(8)`\n[1] 2.756466\n\n$`diagnostics.msr(9)`\n[1] 4.216562\n\n$`diagnostics.msr(10)`\n[1] 4.750469\n\n$`diagnostics.msr(11)`\n[1] 5.088831\n\n$`diagnostics.msr(12)`\n[1] 2.95312"
  },
  {
    "objectID": "TP/R_4_X11_v2.html#footnotes",
    "href": "TP/R_4_X11_v2.html#footnotes",
    "title": "4 - Qualité de la décomposition sous R",
    "section": "Notes de bas de page",
    "text": "Notes de bas de page\n\n\nEntre JDemetra+ 2.x et JDemetra+ 3.x la spécification du f-test a été changée↩︎"
  },
  {
    "objectID": "TP/R_5_JD_in_production_v2.html",
    "href": "TP/R_5_JD_in_production_v2.html",
    "title": "5 - JDemetra+ en production",
    "section": "",
    "text": "L’objectif de ce TP est d’apprendre à manipuler des workspaces pour une mise en production.\nPour installer tous les packages utiles de ce TP, lancer le programme :\npackages_to_install &lt;- c(\n  \"RJDemetra\", \"rjdqa\", \"ggdemetra\", \"rjdmarkdown\", \"rjwsacruncher\", \"rjdworkspace\"\n  )\n\npackages &lt;- packages_to_install[! packages_to_install %in% installed.packages()[,\"Package\"]]\nif (length(packages) &gt; 0) {\n    install.packages(\n      packages, \n      repos = c(\"https://aqlt.r-universe.dev\", \"https://cloud.r-project.org\")\n      )\n}\nLors de la mise en production, le plus simple est de manipuler des workspaces et de mettre à jour les modèles, lors de l’arrivée de nouvelles données à travers le JWSACruncher. Pour faciliter son utilisation depuis R, le package rjwsacruncher peut être utilisé.\nLorsque les workspaces sont créés depuis R, on perd toutes les métadonnées (lien vers les fichiers, commentaires, etc.), une solution pour cela : utiliser rjdworkspace pour récupérer ces données depuis un autre workspace.\nDans ce TP on utilisera les données du package RJDemetra mais n’hésitez pas à utiliser vos propres séries."
  },
  {
    "objectID": "TP/R_5_JD_in_production_v2.html#sec-installation",
    "href": "TP/R_5_JD_in_production_v2.html#sec-installation",
    "title": "5 - JDemetra+ en production",
    "section": "1.1 Configuration du JWSACruncher",
    "text": "1.1 Configuration du JWSACruncher\nPour éviter que le package rjwsacruncher soit trop volumineux, il ne contient pas le JWSAcruncher de JDemetra+. Voir manuel d’installation pour le téléchargement et la configuration du JWSACruncher.\nPour indiquer à rjwsacruncher où se trouve le JWSACruncher, le plus simple est de mettre à jour l’option cruncher_bin_directory :\n\n# install.packages(\"rjwsacruncher\") # Si pas déjà installé\nlibrary(rjwsacruncher)\n# Chemin vers le dossier bin du JWSACruncher\n# Remplacer \"D:/jwsacruncher-2.2.4/bin\" par votre propre chemin.\noptions(cruncher_bin_directory =\n            \"D:/jwsacruncher-2.2.4/bin\") \ngetOption(\"cruncher_bin_directory\") # Pour afficher la valeur actuelle\n\n[1] \"D:/jwsacruncher-2.2.4/bin\""
  },
  {
    "objectID": "TP/R_5_JD_in_production_v2.html#utilisation-du-jwsacruncher",
    "href": "TP/R_5_JD_in_production_v2.html#utilisation-du-jwsacruncher",
    "title": "5 - JDemetra+ en production",
    "section": "1.2 Utilisation du JWSACruncher",
    "text": "1.2 Utilisation du JWSACruncher\nPour lancer le JWSACruncher il faut trois fichiers :\n\nun fichier contenant les paramètres sur la méthode de rafraîchissement à utilisée pour mettre à jour le workspace (créé à partir de la fonction create_param_file() ou list2param_file()) ;\n\nun workspace valide de JDemetra+ ;\n\nl’adresse vers le JWSACruncher (option cruncher_bin_directory).\n\nDans le package rjwsacruncher, les principales fonctions associées au lancement du JWSACruncher sont :\n\ncreate_param_file() ou list2param_file() qui permet de créer le fichier de paramètres ;\n\ncruncher() qui permet de lancer le JWSACruncher sur un workspace à partir d’un fichier de paramètres ;\n\ncruncher_and_param() qui permet de lancer le JWSACruncher tout en créant le fichier de paramètres et de personnaliser certaines sorties du JWSACruncher.\n\n\n1.2.1 Création du fichier de paramètres avec create_param_file()\nLes paramètres de la fonction create_param_file() sont les mêmes que ceux décrits dans le wiki du JWSACruncher de JDemetra+ (https://github.com/jdemetra/jwsacruncher/wiki). Les trois paramètres les plus importants de create_param_file() sont :\n\npolicy qui est la méthode de rafraîchissement utilisée (voir tableau ci-dessous).\n\n\n\n\n\nLes différentes politiques de rafraîchissement\n\n\nOption sous JDemetra+\nOption du cruncher\nNom court\nSignification\n\n\n\n\nCurrent[AO]: fixed model + AO for new data\ncurrent\nn\nLe modèle ARIMA, les outliers et les autres paramètres du modèle de régression ne sont ni ré-identifiés ni ré-estimés. Le schéma de décomposition est inchangé. Un additive outlier (AO) est ajouté à chaque nouvelle donnée. (depuis v.2.2.3)\n\n\nPartial concurrent adjustment -&gt; Fixed model\nfixed\nf\nLe modèle ARIMA, les outliers et les autres paramètres du modèle de régression ne sont ni ré-identifiés ni ré-estimés. Le schéma de décomposition est inchangé. (depuis v.2.2.3)\n\n\nPartial concurrent adjustment -&gt; Estimate regression coefficients\nfixedparameters\nfp\nLe modèle ARIMA, les outliers et les autres paramètres du modèle regARIMA ne sont pas ré-identifiés. Les coefficients du modèle ARIMA sont fixés et les autres paramètres du modèle de régression sont ré-estimés. Le schéma de décomposition est inchangé.\n\n\nPartial concurrent adjustment -&gt; Estimate regression coefficients + MA parameters of the ARIMA model\nfixedarparameters\nfarp\nLe modèle ARIMA, les outliers et les autres paramètres du modèle regARIMA ne sont pas ré-identifiés. Les coefficients AR du modèle ARIMA sont fixes, les autres coefficients sont réestimés (coefficients MA + régresseurs). Le schéma de décomposition est inchangé. (since v.3.4.0)\n\n\nPartial concurrent adjustment -&gt; Estimate regression coefficients + Arima parameters\nparameters (by default)\np\nLe modèle ARIMA, les outliers et les autres paramètres du modèle de régression ne sont pas ré-identifiés mais sont tous ré-estimés. Le schéma de décomposition est inchangé.\n\n\nPartial concurrent adjustment -&gt; Estimate regression coefficients + Last outliers\nlastoutliers\nl\nLe modèle ARIMA, les outliers (sauf ceux de la dernière année) et les autres paramètres du modèle de régression ne sont pas ré-identifiés mais sont tous ré-estimés. Les outliers de la dernière année sont ré-identifiés. Le schéma de décomposition est inchangé.\n\n\nPartial concurrent adjustment -&gt; Estimate regression coefficients + All outliers\noutliers\no\nLe modèle ARIMA et les paramètres du modèle regARIMA autres que les outliers ne sont pas ré-identifiés mais ré-estimés. Tous les outliers sont ré-identifiés. Le schéma de décomposition est inchangé.\n\n\nPartial concurrent adjustment -&gt; Estimate regression coefficients + Arima model\nstochastic\ns\nRé-identification de tous les paramètres du modèle regARIMA hormis les variables calendaires. Le schéma de décomposition est inchangé.\n\n\nConcurrent\ncomplete (or concurrent)\nc\nRé-identification de tout le modèle regARIMA.\n\n\n\n\n\n\n\n\n\nmatrix_item qui est une chaîne de caractères contenant les noms des paramètres à exporter. Par défaut, ce sont ceux de l’option default_matrix_item. On peut donc au choix modifier l’option default_matrix_item ou le paramètre matrix_item :\n\n\nlibrary(rjwsacruncher)\n# Pour afficher les paramètres par défaut :\ngetOption(\"default_matrix_item\")\n# Pour modifier les paramètres par défaut pour n'exporter par exemple\n# que les critères d'information :\noptions(default_matrix_item = c(\"likelihood.aic\",\n                                \"likelihood.aicc\",\n                                \"likelihood.bic\",\n                                \"likelihood.bicc\"))\n\n\ntsmatrix_series qui est une chaîne de caractères contenant les noms des paramètres à exporter. Par défaut, ce sont ceux de l’option default_tsmatrix_series. On peut donc au choix modifier l’option default_tsmatrix_series ou le paramètre tsmatrix_series :\n\n\n# Pour afficher les paramètres par défaut :\ngetOption(\"default_tsmatrix_series\")\n# Pour modifier les paramètres par défaut pour n'exporter par exemple que\n# la série désaisonnalisée et ses prévisions :\noptions(default_tsmatrix_series = c(\"sa\", \"sa_f\"))\n\nPour voir l’ensemble des paramètres, il suffit d’utiliser sous R la commande ?create_param_file.\nAprès cela, il ne reste plus qu’à créer le fichier de paramètres. Le fichier de paramètre est différent entre la version 3.0.0 de JDemetra+ et les versions antérieures. Les fonctions de création des fichiers de paramètres ont un paramètre v3 qui permet de spécifier si l’on veut que le fichier soit compatible avec la version 3.0.0. Sa valeur par défaut est getOption(\"is_cruncher_v3\") : si l’on utilise la version 3.0.0 ou plus, le plus simple est donc de changer cette option options(is_cruncher_v3 = TRUE). Ci-dessous quelques exemples.\n\nexport_dir &lt;- tempdir() # Remplacer ici par le dossier d'export souhaité\n# Un fichier parametres.param sera créé dans le dossier export_dir\n# avec la politique de rafraîchissement \"lastoutliers\" \n# et les autres paramètres par défaut\ncreate_param_file(dir_file_param = export_dir,\n                  policy = \"lastoutliers\")\n# Si l'on a modifié les options \"default_matrix_item\" et \"default_tsmatrix_series\" pour\n# n'exporter que les critères d'information, la série désaisonnalisée et ses\n# prévisions, la commande précédente est équivalent à : \ncreate_param_file(\n  dir_file_param = export_dir,\n  policy = \"lastoutliers\",\n  matrix_item = c(\"likelihood.aic\", \"likelihood.aicc\",\n                  \"likelihood.bic\", \"likelihood.bicc\"),\n  tsmatrix_series = c(\"sa\", \"sa_f\")\n)\n\nLes fichiers de paramètres peuvent être lus avec read_param_file() qui renvoie une liste qui peut être modifiée et exportée avec list2param_file() :\n\nparam_f &lt;- read_param_file(file.path(export_dir, \"parameters.param\"))\nstr(param_f)\n\nList of 7\n $ config         :List of 4\n  ..$ bundle       : chr \"10000\"\n  ..$ csv_layout   : chr \"list\"\n  ..$ csv_separator: chr \";\"\n  ..$ ndecs        : chr \"6\"\n $ policy         : chr \"lastoutliers\"\n $ refreshall     : logi TRUE\n $ output         : NULL\n $ matrix_item    : chr [1:4] \"likelihood.aic\" \"likelihood.aicc\" \"likelihood.bic\" \"likelihood.bicc\"\n $ tsmatrix_series: chr [1:2] \"sa\" \"sa_f\"\n $ paths_path     : NULL\n\n\nLes fichiers de paramètres par défaut peuvent être obtenus avec la fonction default_param_file().\n\n\n\n\n\n\nExercice\n\n\n\nUtiliser la fonction create_param_file() pour créé un fichier de paramètres permettant de mettre à jour un workspace :\n\nEn réestimant le modèle ARIMA, les outliers et les autres paramètres du modèle de régression et en re-identifiant les outliers uniquement sur la dernière année.\nEn exportant la statistique M7, la statistique Q-M2 et les tests de jours ouvrables résiduels ;\nEn exportant la série brute, la série désaisonnalisée et la tendance (de manière verticale).\n\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nPour voir les noms des paramètres, utiliser la fonction default_param_file() ou bien aller sur la page https://github.com/jdemetra/jwsacruncher/wiki/Output-dictionaries.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ndir &lt;- tempdir()\ncreate_param_file(\n    dir_file_param = dir,\n    policy = \"lastoutliers\",\n    matrix_item = c(\n        \"m-statistics.m7\",\n        \"m-statistics.q-m2\",\n        \"diagnostics.residual trading days tests.f-test on sa (td):2\",\n        \"diagnostics.residual trading days tests.f-test on i (td):2\"\n    ),\n    tsmatrix_series = c(\"y\", \"sa\", \"t\"),\n    csv_layout = \"vtable\" \n)\n\n\n\n\nLes fichiers de paramètres peuvent être lus avec read_param_file() qui renvoie une liste qui peut être modifiée et exportée avec list2param_file() :\n\nparam_f &lt;- read_param_file(file.path(dir, \"parameters.param\"))\nstr(param_f)\n\nList of 7\n $ config         :List of 4\n  ..$ bundle       : chr \"10000\"\n  ..$ csv_layout   : chr \"vtable\"\n  ..$ csv_separator: chr \";\"\n  ..$ ndecs        : chr \"6\"\n $ policy         : chr \"lastoutliers\"\n $ refreshall     : logi TRUE\n $ output         : NULL\n $ matrix_item    : chr [1:4] \"m-statistics.m7\" \"m-statistics.q-m2\" \"diagnostics.residual trading days tests.f-test on sa (td):2\" \"diagnostics.residual trading days tests.f-test on i (td):2\"\n $ tsmatrix_series: chr [1:3] \"y\" \"sa\" \"t\"\n $ paths_path     : NULL\n\n\nLes fichiers de paramètres par défaut peuvent être obtenus avec la fonction default_param_file().\n\n\n1.2.2 Lancement du JWSACruncher\nPour lancer le JWSACruncher avec cruncher() ou cruncher_and_param(), il faut spécifier le chemin d’accès au dossier contenant le JWSACruncher (paramètre cruncher_bin_directory) ainsi que celui du workspace à traiter (paramètre workspace). Si cela a déjà été fait dans la section 1.1, ne pas prendre en compte le paragraphe suivant\nPar défaut, le chemin d’accès au dossier du JWSACruncher est celui contenu dans le paramètre cruncher_bin_directory : il suffit donc de modifier une seule fois cette option afin qu’elle s’applique à toutes les exécutions du JWSACruncher. Le chemin à indiquer est celui du dossier contenant le fichier jwsacruncher.bat, situé dans le dossier “Bin” du dossier d’installation du JWSACruncher. Ainsi, s’il a été installé sous D:\\jdemetra-cli-2.2.4, le fichier jwsacruncher.bat sera présent sous D:\\jdemetra-cli-2.2.4\\bin. Il faut donc modifier l’option cruncher_bin_directory de la façon suivante :\n\noptions(cruncher_bin_directory = \"D:/jdemetra-cli-2.2.4/bin/\")\n\nSi aucun chemin de workspace n’est renseigné, une fenêtre s’ouvre, invitant à sélectionner le workspace sur lequel on souhaite lancer le JWSACruncher.\n\n# Remplacer ici \"workspace.xml\" par le chemin vers votre workspace\ncruncher(\n  workspace = \"workspace.xml\",\n  # Remplacer ici \"parameters.param\" par le chemin vers votre fichier de paramètres\n  param_file_path = \"parameters.param\"\n)\n\nSi vous n’avez pas de workspace vous pouvez utiliser le code suivant pour en générer un :\n\nlibrary(RJDemetra)\nspec_x13 &lt;- x13_spec(spec = \"RSA5c\")\njws &lt;- new_workspace()\nnew_multiprocessing(jws, \"sa1\")\n\nfor (nom_series in colnames(ipi_c_eu)){\n    model &lt;- jx13(ipi_c_eu[,nom_series], spec_x13)\n    add_sa_item(jws, \"sa1\", model, nom_series)\n}\n\nsave_workspace(jws, \"workspace.xml\")\n\nSi non spécifié dans le fichier des paramètres, les résultats sont exportés dans le sous dossier \"Output\" du workspace (pour le workspace.xml, les résultats seront donc sous workspace/Output/). On peut aussi créer le fichier des paramètres et lancer le JWSAcruncher avec la fonction cruncher_and_param. Cette fonction permet aussi de renommer les dossiers exportées avec les noms des multi-processings utilisés dans JDemetra+ (évite d’avoir des dossiers du type SAProcessing-1)1.\n\ncruncher_and_param(\n    workspace = \"workspace.xml\",\n    policy = \"lastoutliers\",\n    matrix_item = c(\n        \"m-statistics.m7\",\n        \"m-statistics.q-m2\",\n        \"diagnostics.residual trading days tests.f-test on sa (td):2\",\n        \"diagnostics.residual trading days tests.f-test on i (td):2\"\n    ),\n    tsmatrix_series = c(\"y\", \"sa\", \"t\"),\n    csv_layout = \"vtable\"\n)"
  },
  {
    "objectID": "TP/R_5_JD_in_production_v2.html#ggdemetra",
    "href": "TP/R_5_JD_in_production_v2.html#ggdemetra",
    "title": "5 - JDemetra+ en production",
    "section": "3.1 ggdemetra",
    "text": "3.1 ggdemetra\nggdemetra permet de faire de la désaisonnalisation comme une couche supplémentaire de ggplot2.\n\ngeom_sa() : pour ajouter une série temporelle associée à la désaisonnalisation (tendance, série désaisonnalisée, etc.) ;\ngeom_outlier() : pour ajouter les points atypiques corrigés dans le pre-ajustement ;\ngeom_arima() : pour ajouter le modèle ARIMA ;\ngeom_diagnostics() : pour ajouter un tableau avec des diagnostics.\n\nPar exemple, pour tracer les séries désaisonnalisées d’un ensemble de séries temporelles :\n\nlibrary(ggdemetra)\ndataGraph &lt;- ts2df(na.omit(ipi_c_eu[,c(\"FR\", \"UK\", \"IT\")]))\ndataGraph &lt;- reshape2::melt(dataGraph, id = \"date\")\nggplot(data = dataGraph, aes (x = date, y = value, color = variable)) +\n    geom_sa(component = \"sa\", frequency = 12, spec = x13_spec(\"RSA4c\"))\n\n\n\n\n\n\n\nFigure 1: Désaisonnalisation de plusieurs séries avec ggplot2 grâce à ggdemetra.\n\n\n\n\n\nSi vous avez déjà estimé un modèle avec RJDemetra, vous pouvez directement initialiser votre graphique grâce à la fonction init_ggplot :\n\nmod &lt;- x13(window(ipi_c_eu[,\"FR\"], end = 2019))\ndiagnostics &lt;- c(`Combined test` = \"diagnostics.combined.all.summary\",\n                 `Residual qs-test (p-value)` = \"diagnostics.qs\",\n                 `Residual f-test (p-value)` = \"diagnostics.ftest\")\np_sa &lt;- init_ggplot(mod) +\n    geom_line(color =  \"#F0B400\") +\n    geom_sa(component = \"y_f\", linetype = 2,\n            color =  \"#F0B400\") + \n    geom_sa(component = \"sa\", color = \"#155692\") +\n    geom_sa(component = \"sa_f\", color = \"#155692\", linetype = 2) + \n    geom_outlier(geom = \"label_repel\",\n                 coefficients = TRUE,\n                 ylim = c(NA, 65), \n                 arrow = arrow(length = unit(0.03, \"npc\"),\n                              type = \"closed\", ends = \"last\"),\n                 digits = 2) + \n    geom_arima(geom = \"label\",\n               x_arima = -Inf, y_arima = Inf, \n               vjust = 1.2, hjust = -0.1)\np_sa +   \n    geom_diagnostics(diagnostics = diagnostics,\n                     table_theme = gridExtra::ttheme_default(base_size = 6),\n                     ymin = 115, ymax = 130, xmin = 2010,\n                     message = FALSE)\n\n\n\n\n\n\n\nFigure 2: Exemple des différentes fonctionnalités de ggdemetra.\n\n\n\n\n\nPour combiner plusieurs graphiques on peut également utiliser le package patchwork :\n\nlibrary(patchwork)\n\nWarning: package 'patchwork' was built under R version 4.4.1\n\np_diag &lt;- init_ggplot(mod)  + \n    geom_diagnostics(diagnostics = diagnostics,\n                     table_theme = gridExtra::ttheme_default(base_size = 8),\n                     message = FALSE) +\n    theme_void()\np_sa / p_diag + \n  plot_layout(heights = unit(c(4, 1.5), \"null\"))\n\n\n\n\n\n\n\nFigure 3: Combinaison de plusieurs graphiques de ggdemetra avec patchwork.\n\n\n\n\n\nLa fonction ggsiratioplot() permet de tracer les SI ratios avec ggplot2 :\n\nggsiratioplot(mod)\n\n\n\n\n\n\n\nFigure 4: S-I ratio avec ggplot2 et ggdemetra::ggsiratioplot().\n\n\n\n\n\nLes différentes composantes du modèle (ainsi que leurs prévisions) peuvent être facilement extraites via les fonctions calendar(), calendaradj(), irregular(), trendcycle(), seasonal(), seasonaladj(), trendcycle() and raw().\n\n\n\n\n\n\nExercice\n\n\n\nCréer une fonction graph_synthetique() qui prend en paramètre un modèle de RJDemetra et qui fait deux graphiques :\n\nà gauche les séries brutes, désaisonnalisée et tendance sur les 10 dernières années ;\nà droite les SI-Ratio.\n\n\n\n\n\n\n\n\n\nIndice\n\n\n\n\n\nPour récupérer les 10 dernières années on pourra récupérer la dernière date connue avec la fonction time() et utiliser la fonction ggplot2::coord_cartesian() (à préférer à la fonction ggplot2::xlim() qui supprime des données et refait donc une désaisonnalisation sur une autre période).\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ngraph_synthetique &lt;- function (x, titre = NULL) {\n    y &lt;- raw(x)\n    last_date &lt;- time(y)[length(y)]\n    p_sa &lt;- init_ggplot(x) +\n        geom_line(color = \"#F0B400\") +\n        geom_sa(component = \"sa\", color = \"#155692\") +\n        geom_sa(component = \"t\", color = \"#1E6C0B\") +\n        coord_cartesian(xlim = c(last_date - 10, NA)) +\n        # On change l'affichage de l'axe des abscisses\n        scale_x_continuous(labels = zoo::as.yearmon)\n    p_siratio &lt;- ggsiratioplot(x,\n                               # supprime le titre\n                               main = NULL, \n                               start = last_date - 10) \n    ((p_sa + p_siratio) &\n        # on applique la fonction theme_bw à tous les graphiques\n            theme_bw()) +\n        # On ajoute un titre global\n        plot_annotation(\n            title = titre\n        )\n}\ngraph_synthetique(mod)\n\n\n\n\n\n\n\nFigure 5: Exemple de tableau de bord grâce à ggdemetra.\n\n\n\n\n\nCi-dessous un exemple de comparaison entre ggplot2::xlim() et ggplot2::coord_cartesian() :\n\np_cc &lt;- init_ggplot(mod) +\n    geom_sa(component = \"sa\", color = \"#155692\") +\n    geom_sa(component = \"t\", color = \"#1E6C0B\") +\n    coord_cartesian(xlim = c(2010, NA), ylim = c(95, 120)) \np_xlim &lt;- init_ggplot(mod) +\n    geom_sa(component = \"sa\", color = \"#155692\") +\n    geom_sa(component = \"t\", color = \"#1E6C0B\") +\n    xlim(c(2010, NA)) +\n    coord_cartesian(ylim = c(95, 120)) \np_cc / p_xlim\n\nWarning: Removed 240 rows containing non-finite outside the scale range\n(`stat_sa()`).\n\n\nFrequency used: 12\n\n\nWarning: Removed 240 rows containing non-finite outside the scale range\n(`stat_sa()`).\n\n\n\n\n\n\n\n\nFigure 6: Comparaison des fonctions ggplot2::xlim() et ggplot2::coord_cartesian().\n\n\n\n\n\nUn message et deux warnings sont générés : c’est parce que les données avant 2010 sont supprimées avec la fonction xlim() et qu’une nouvelle désaisonnalisation est alors effectuée (avec une spécification par défaut qui peut être différente de celle utilisée pour créer le modèle). Cela explique les différences entre les deux graphiques\n\n\n\nÀ partir de la fonction précédente, on peut par exemple faire une fonction qui va lire un workspace et faire un cahier pdf le graphique précédent pour tous les modèles de chaque multiprocessing :\n\n# Construisons d'abord un workspace exemple :\ny &lt;- ipi_c_eu[, \"FR\"]\njws &lt;- new_workspace()\nnew_multiprocessing(jws, \"X-13\")\nnew_multiprocessing(jws, \"TRAMO-SEATS\")\nfor (spec in c(\"RSA5c\", \"RSA0\", \"RSA1\", \"RSA2c\", \"RSA3\", \"RSA4c\")) {\n    add_sa_item(jws, \"X-13\", jx13(y, spec), spec)\n}\nfor (spec in c(\"RSAfull\", \"RSA0\", \"RSA1\", \"RSA2\", \"RSA3\", \"RSA4\", \"RSA5\")) {\n    add_sa_item(jws, \"TRAMO-SEATS\", jtramoseats(y, spec), spec)\n}\ndir &lt;- tempdir()\nsave_workspace(jws, file.path(dir, \"workspace.xml\"))\n\n\njws &lt;- load_workspace(file.path(dir, \"workspace.xml\"))\ncompute(jws)\nall_m &lt;- get_model(jws, progress_bar = FALSE)\nall_m &lt;- lapply(all_m, function(x){\n  # On enlève les espaces à la fin des noms,\n  # cela arrive souvent avec les fichiers Excel\n  names(x) &lt;- gsub(\" *$\", \"\", names(x))\n  x\n})\n# Booléen pour supprimer les fichiers existants\nreplace_existing_file &lt;- TRUE\n# dossier contenant tous les graphiques\ndir_exp &lt;- \"graph\"\nif (!dir.exists(dir_exp))\n  dir.create(dir_exp)\nfor (sap in names(all_m)) {\n  if (!dir.exists(file.path(dir_exp, sap)))\n    dir.create(file.path(dir_exp, sap))\n  for(series in names(all_m[[sap]])) {\n    # Si le fichier existe déjà on ne fait pas l'export\n    file &lt;- file.path(\n        dir_exp, sap, paste0(\n    # on ne prend que les 20 premiers caractères pour les noms des fichiers\n    # (vite trop long si on part de fichiers Excel)\n            substr(series, 1, 20), \n            \".pdf\"))\n\n    if (!replace_existing_file && file.exists(file))\n      next;\n    print(sprintf(\"%s : %s\", sap, series))\n    p_dashboard &lt;- graph_synthetique(x = all_m[[sap]][[series]],\n                                     titre = series)\n    ggsave(filename = file, plot = p_dashboard,\n           # format A4 paysage\n           width = 29.7, height = 21, units = \"cm\")\n  }\n}\n\n# Ensuite on va créer un cahier avec tous les pdfs\nfor (sap in names(all_m)) {\n  qpdf::pdf_combine(input = sprintf(\"%s/%s/%s.pdf\", dir_exp, sap,\n                                  substr(names(all_m[[sap]]), 1, 20)),\n                    output = sprintf(\"%s/%s.pdf\", dir_exp, sap))\n}"
  },
  {
    "objectID": "TP/R_5_JD_in_production_v2.html#rjdqa",
    "href": "TP/R_5_JD_in_production_v2.html#rjdqa",
    "title": "5 - JDemetra+ en production",
    "section": "3.2 rjdqa",
    "text": "3.2 rjdqa\nrjdqa permet de reproduire deux tableaux de bord différents (mais avec base R plutôt que ggplot2 pour des raisons de performance) :\n\nsc_dashboard() qui reproduit le tableau de bord de Statistique Canada : voir notamment chapitre 22 du Handbook sur la désaisonnalisation https://ec.europa.eu/eurostat/web/products-manuals-and-guidelines/-/KS-GQ-18-001 ;\nsimple_dashboard() qui reproduit un tableau de bord simplifié et simple_dashboard2() qui est une légère variante avec en plus les derniers points atypiques.\n\nSi vous avez d’autres idées n’hésitez pas à contribuer au package ou à faire une issue sur github !\n\nlibrary(rjdqa)\nmod &lt;- tramoseats(window(ipi_c_eu[,\"FR\"], end = 2019))\nplot(sc_dashboard(mod))\nplot(simple_dashboard2(mod))\n\n\n\n\n\n\n\nFigure 7: Tableau de bord de Statistique Canada avec sc_dashboard().\n\n\n\n\n\n\n\n\n\n\n\nFigure 8: Tableau de bord de simplifié avec simple_dashboard2()."
  },
  {
    "objectID": "TP/R_5_JD_in_production_v2.html#rjdmarkdown",
    "href": "TP/R_5_JD_in_production_v2.html#rjdmarkdown",
    "title": "5 - JDemetra+ en production",
    "section": "3.3 rjdmarkdown",
    "text": "3.3 rjdmarkdown\nrjdmarkdown fournit différentes fonctions pour améliorer le rendu des modèles avec rmarkdown. Voir :\n\nhttps://aqlt.github.io/rjdmarkdown/articles/rjdmarkdown-pdf.pdf pour le rendu en PDF ;\nhttps://aqlt.github.io/rjdmarkdown/articles/rjdmarkdown-html.html pour le rendu HTML.\n\nUn document peut également être généré de manière automatique à partir d’un workspace. Par exemple :\n\n# # On peut reprendre le workspace précédent\n# y &lt;- ipi_c_eu[, \"FR\"]\n# jws &lt;- new_workspace()\n# new_multiprocessing(jws, \"X-13\")\n# new_multiprocessing(jws, \"TRAMO-SEATS\")\n# for (spec in c(\"RSA5c\", \"RSA0\", \"RSA1\", \"RSA2c\", \"RSA3\", \"RSA4c\")) {\n#   add_sa_item(jws, \"X-13\", jx13(y, spec), spec)\n# }\n# for (spec in c(\"RSAfull\", \"RSA0\", \"RSA1\", \"RSA2\", \"RSA3\", \"RSA4\", \"RSA5\")) {\n#   add_sa_item(jws, \"TRAMO-SEATS\", jtramoseats(y, spec), spec)\n# }\n# dir &lt;- tempdir()\n# save_workspace(jws, file.path(dir, \"workspace.xml\"))\n\nlibrary(rjdmarkdown)\noutput_file &lt;- tempfile(fileext = \".Rmd\")\ncreate_rmd(jws, output_file, \n           output_format = c(\"html_document\", \"pdf_document\"),\n           output_options = list(toc = TRUE,\n                              number_sections = TRUE))\nbrowseURL(sub(\".Rmd\",\".pdf\", output_file, fixed = TRUE))\nbrowseURL(sub(\".Rmd\",\".html\", output_file, fixed = TRUE))\n\nEn réutilisant la fonction graph_synthetique() précédente :\n\noutput_file &lt;- tempfile(fileext = \".Rmd\")\nout &lt;- create_rmd(jws, output_file, \n           output_format = c(\"pdf_document\"),\n           preprocessing_fun = NULL,\n           decomposition_fun = graph_synthetique,\n           diagnostics_fun = NULL,\n           output_options = list(toc = TRUE,\n                                 number_sections = TRUE),\n           knitr_chunk_opts = list(fig.pos = \"h\", echo = FALSE,\n                                fig.cap = \"Tableau de bord\"))\nbrowseURL(out)"
  },
  {
    "objectID": "TP/R_5_JD_in_production_v2.html#footnotes",
    "href": "TP/R_5_JD_in_production_v2.html#footnotes",
    "title": "5 - JDemetra+ en production",
    "section": "Notes de bas de page",
    "text": "Notes de bas de page\n\n\n Lorsque l’on manipule un workspace de la V2, une autre façon de faire est d’importer le workspace jws &lt;- RJDemetra::load_workspace(\"workspace.xml\") et de le sauvegarder sans rien faire RJDemetra::save_workspace(\"workspace.xml\"). L’export va renommer les noms des fichiers des multi-processings en utilisant leur nom, ce qui évitera cette opération de renommage.↩︎"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Désaisonnaliser une série temporelle",
    "section": "",
    "text": "Supports de cours et exercices de la formation Désaisonnaliser une série temporelle au CEPE les 9, 10, 16, 17 octobre 2025."
  },
  {
    "objectID": "index.html#tp-jdemetra",
    "href": "index.html#tp-jdemetra",
    "title": "Désaisonnaliser une série temporelle",
    "section": "TP JDemetra+",
    "text": "TP JDemetra+\n\nPremière manipulation de JDemetra+\nAnalyse exploratoire\nDésaisonnalisation sans correction des jours ouvrables\nDésaisonnalisation avec correction des jours ouvrables\nPré-ajustement\nDécomposition (X11)\nÉtude de cas"
  },
  {
    "objectID": "index.html#tp",
    "href": "index.html#tp",
    "title": "Désaisonnaliser une série temporelle",
    "section": "TP ",
    "text": "TP \n\n(Complément) Traitement des séries temporelles sous \nR et JDemetra+ : V2 ou V3\nCorrection des jours ouvrables : V2 ou V3 et programme export_cjo.R\n(Complément) Preajustement : V2 ou V3\n(Complément) Décomposition (X11) : V2 ou V3\nJDemetra+ en production :\n\nEn V2 : TP5 et programmes 1-cruncher_v2.R, 2-lecture_donnees_v2.R et 3-tableau_de_bord_v2.R\nEn V3 : TP5 et programmes 1-cruncher.R, 2-lecture_donnees.R, 2b-lecture_tests.R et 3-tableau_de_bord.R\n\nAutres programmes : 4-imae_calage.R et 5-cvs_indirecte.R"
  }
]